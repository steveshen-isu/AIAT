{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { typeOf as _typeOf } from '../../utils/is.js';\nvar name = 'typeOf';\nvar dependencies = ['typed'];\nexport var createTypeOf = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\r\n   * Determine the type of an entity.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.typeOf(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    // This list is intended to include all relevant types, for testing\r\n   *    // purposes:\r\n   *    math.typeOf(3.5)                      // returns 'number'\r\n   *    math.typeOf(42n)                      // returns 'bigint'\r\n   *    math.typeOf(math.complex('2-4i'))     // returns 'Complex'\r\n   *    math.typeOf(math.unit('45 deg'))      // returns 'Unit'\r\n   *    math.typeOf('hello world')            // returns 'string'\r\n   *    math.typeOf(null)                     // returns 'null'\r\n   *    math.typeOf(true)                     // returns 'boolean'\r\n   *    math.typeOf([1, 2, 3])                // returns 'Array'\r\n   *    math.typeOf(new Date())               // returns 'Date'\r\n   *    math.typeOf(function () {})           // returns 'function'\r\n   *    math.typeOf({a: 2, b: 3})             // returns 'Object'\r\n   *    math.typeOf(/a regexp/)               // returns 'RegExp'\r\n   *    math.typeOf(undefined)                // returns 'undefined'\r\n   *    math.typeOf(math.bignumber('23e99'))  // returns 'BigNumber'\r\n   *    math.typeOf(math.chain(2))            // returns 'Chain'\r\n   *    math.typeOf(math.fraction(1, 3))      // returns 'Fraction'\r\n   *    math.typeOf(math.help('sqrt'))        // returns 'Help'\r\n   *    math.typeOf(math.index(1, 3))         // returns 'Index'\r\n   *    math.typeOf(math.matrix([[1],[3]]))   // returns 'DenseMatrix'\r\n   *    math.typeOf(math.matrix([],'sparse')) // returns 'SparseMatrix'\r\n   *    math.typeOf(new math.Range(0, 10))    // returns 'Range'\r\n   *    math.typeOf(math.evaluate('a=2\\na'))  // returns 'ResultSet'\r\n   *    math.typeOf(math.parse('A[2]'))       // returns 'AccessorNode'\r\n   *    math.typeOf(math.parse('[1,2,3]'))    // returns 'ArrayNode'\r\n   *    math.typeOf(math.parse('x=2'))        // returns 'AssignmentNode'\r\n   *    math.typeOf(math.parse('a=2; b=3'))   // returns 'BlockNode'\r\n   *    math.typeOf(math.parse('x<0?-1:1'))   // returns 'ConditionalNode'\r\n   *    math.typeOf(math.parse('2.3'))        // returns 'ConstantNode'\r\n   *    math.typeOf(math.parse('f(x)=x^2'))   // returns 'FunctionAssignmentNode'\r\n   *    math.typeOf(math.parse('sqrt(4)'))    // returns 'FunctionNode'\r\n   *    math.typeOf(math.parse('A[2]').index) // returns 'IndexNode'\r\n   *    math.typeOf(math.parse('{a:2}'))      // returns 'ObjectNode'\r\n   *    math.typeOf(math.parse('(2+3)'))      // returns 'ParenthesisNode'\r\n   *    math.typeOf(math.parse('1:10'))       // returns 'RangeNode'\r\n   *    math.typeOf(math.parse('a<b<c'))      // returns 'RelationalNode'\r\n   *    math.typeOf(math.parse('x'))          // returns 'SymbolNode'\r\n   *\r\n   * @param {*} x     The variable for which to test the type.\r\n   * @return {string} Returns the name of the type. Primitive types are lower case,\r\n   *                  non-primitive types are upper-camel-case.\r\n   *                  For example 'number', 'string', 'Array', 'Date'.\r\n   */\n  return typed(name, {\n    any: _typeOf\n  });\n});","map":{"version":3,"names":["factory","typeOf","_typeOf","name","dependencies","createTypeOf","_ref","typed","any"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/utils/typeOf.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { typeOf as _typeOf } from '../../utils/is.js';\r\nvar name = 'typeOf';\r\nvar dependencies = ['typed'];\r\nexport var createTypeOf = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed\r\n  } = _ref;\r\n  /**\r\n   * Determine the type of an entity.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.typeOf(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    // This list is intended to include all relevant types, for testing\r\n   *    // purposes:\r\n   *    math.typeOf(3.5)                      // returns 'number'\r\n   *    math.typeOf(42n)                      // returns 'bigint'\r\n   *    math.typeOf(math.complex('2-4i'))     // returns 'Complex'\r\n   *    math.typeOf(math.unit('45 deg'))      // returns 'Unit'\r\n   *    math.typeOf('hello world')            // returns 'string'\r\n   *    math.typeOf(null)                     // returns 'null'\r\n   *    math.typeOf(true)                     // returns 'boolean'\r\n   *    math.typeOf([1, 2, 3])                // returns 'Array'\r\n   *    math.typeOf(new Date())               // returns 'Date'\r\n   *    math.typeOf(function () {})           // returns 'function'\r\n   *    math.typeOf({a: 2, b: 3})             // returns 'Object'\r\n   *    math.typeOf(/a regexp/)               // returns 'RegExp'\r\n   *    math.typeOf(undefined)                // returns 'undefined'\r\n   *    math.typeOf(math.bignumber('23e99'))  // returns 'BigNumber'\r\n   *    math.typeOf(math.chain(2))            // returns 'Chain'\r\n   *    math.typeOf(math.fraction(1, 3))      // returns 'Fraction'\r\n   *    math.typeOf(math.help('sqrt'))        // returns 'Help'\r\n   *    math.typeOf(math.index(1, 3))         // returns 'Index'\r\n   *    math.typeOf(math.matrix([[1],[3]]))   // returns 'DenseMatrix'\r\n   *    math.typeOf(math.matrix([],'sparse')) // returns 'SparseMatrix'\r\n   *    math.typeOf(new math.Range(0, 10))    // returns 'Range'\r\n   *    math.typeOf(math.evaluate('a=2\\na'))  // returns 'ResultSet'\r\n   *    math.typeOf(math.parse('A[2]'))       // returns 'AccessorNode'\r\n   *    math.typeOf(math.parse('[1,2,3]'))    // returns 'ArrayNode'\r\n   *    math.typeOf(math.parse('x=2'))        // returns 'AssignmentNode'\r\n   *    math.typeOf(math.parse('a=2; b=3'))   // returns 'BlockNode'\r\n   *    math.typeOf(math.parse('x<0?-1:1'))   // returns 'ConditionalNode'\r\n   *    math.typeOf(math.parse('2.3'))        // returns 'ConstantNode'\r\n   *    math.typeOf(math.parse('f(x)=x^2'))   // returns 'FunctionAssignmentNode'\r\n   *    math.typeOf(math.parse('sqrt(4)'))    // returns 'FunctionNode'\r\n   *    math.typeOf(math.parse('A[2]').index) // returns 'IndexNode'\r\n   *    math.typeOf(math.parse('{a:2}'))      // returns 'ObjectNode'\r\n   *    math.typeOf(math.parse('(2+3)'))      // returns 'ParenthesisNode'\r\n   *    math.typeOf(math.parse('1:10'))       // returns 'RangeNode'\r\n   *    math.typeOf(math.parse('a<b<c'))      // returns 'RelationalNode'\r\n   *    math.typeOf(math.parse('x'))          // returns 'SymbolNode'\r\n   *\r\n   * @param {*} x     The variable for which to test the type.\r\n   * @return {string} Returns the name of the type. Primitive types are lower case,\r\n   *                  non-primitive types are upper-camel-case.\r\n   *                  For example 'number', 'string', 'Array', 'Date'.\r\n   */\r\n  return typed(name, {\r\n    any: _typeOf\r\n  });\r\n});"],"mappings":"AAAA,SAASA,OAAO,QAAQ,wBAAwB;AAChD,SAASC,MAAM,IAAIC,OAAO,QAAQ,mBAAmB;AACrD,IAAIC,IAAI,GAAG,QAAQ;AACnB,IAAIC,YAAY,GAAG,CAAC,OAAO,CAAC;AAC5B,OAAO,IAAIC,YAAY,GAAG,eAAeL,OAAO,CAACG,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EAC3E,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAK,CAACJ,IAAI,EAAE;IACjBK,GAAG,EAAEN;EACP,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}