{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { isNode } from '../../utils/is.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { escape, stringify } from '../../utils/string.js';\nvar name = 'ObjectNode';\nvar dependencies = ['Node'];\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  class ObjectNode extends Node {\n    /**\r\n     * @constructor ObjectNode\r\n     * @extends {Node}\r\n     * Holds an object with keys/values\r\n     * @param {Object.<string, Node>} [properties]   object with key/value pairs\r\n     */\n    constructor(properties) {\n      super();\n      this.properties = properties || {};\n\n      // validate input\n      if (properties) {\n        if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\n          return isNode(properties[key]);\n        })) {\n          throw new TypeError('Object containing Nodes expected');\n        }\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isObjectNode() {\n      return true;\n    }\n\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n    _compile(math, argNames) {\n      var evalEntries = {};\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          // we stringify/parse the key here to resolve unicode characters,\n          // so you cannot create a key like {\"co\\\\u006Estructor\": null}\n          var stringifiedKey = stringify(key);\n          var parsedKey = JSON.parse(stringifiedKey);\n          var prop = getSafeProperty(this.properties, key);\n          evalEntries[parsedKey] = prop._compile(math, argNames);\n        }\n      }\n      return function evalObjectNode(scope, args, context) {\n        var obj = {};\n        for (var _key in evalEntries) {\n          if (hasOwnProperty(evalEntries, _key)) {\n            obj[_key] = evalEntries[_key](scope, args, context);\n          }\n        }\n        return obj;\n      };\n    }\n\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n    forEach(callback) {\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n        }\n      }\n    }\n\n    /**\r\n     * Create a new ObjectNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ObjectNode} Returns a transformed copy of the node\r\n     */\n    map(callback) {\n      var properties = {};\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\n        }\n      }\n      return new ObjectNode(properties);\n    }\n\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ObjectNode}\r\n     */\n    clone() {\n      var properties = {};\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          properties[key] = this.properties[key];\n        }\n      }\n      return new ObjectNode(properties);\n    }\n\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n    _toString(options) {\n      var entries = [];\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n        }\n      }\n      return '{' + entries.join(', ') + '}';\n    }\n\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        properties: this.properties\n      };\n    }\n\n    /**\r\n     * Instantiate an OperatorNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ObjectNode}\r\n     */\n    static fromJSON(json) {\n      return new ObjectNode(json.properties);\n    }\n\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n    _toHTML(options) {\n      var entries = [];\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator\">' + ':</span>' + this.properties[key].toHTML(options));\n        }\n      }\n      return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n    }\n\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n    _toTex(options) {\n      var entries = [];\n      for (var key in this.properties) {\n        if (hasOwnProperty(this.properties, key)) {\n          entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\n        }\n      }\n      var tex = '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\n      return tex;\n    }\n  }\n  _defineProperty(ObjectNode, \"name\", name);\n  return ObjectNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","getSafeProperty","factory","isNode","hasOwnProperty","escape","stringify","name","dependencies","createObjectNode","_ref","Node","ObjectNode","constructor","properties","Object","keys","every","key","TypeError","type","isObjectNode","_compile","math","argNames","evalEntries","stringifiedKey","parsedKey","JSON","parse","prop","evalObjectNode","scope","args","context","obj","_key","forEach","callback","map","_ifNode","clone","_toString","options","entries","push","toString","join","toJSON","mathjs","fromJSON","json","_toHTML","toHTML","_toTex","toTex","tex","isClass"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/expression/node/ObjectNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { getSafeProperty } from '../../utils/customs.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { isNode } from '../../utils/is.js';\r\nimport { hasOwnProperty } from '../../utils/object.js';\r\nimport { escape, stringify } from '../../utils/string.js';\r\nvar name = 'ObjectNode';\r\nvar dependencies = ['Node'];\r\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n  class ObjectNode extends Node {\r\n    /**\r\n     * @constructor ObjectNode\r\n     * @extends {Node}\r\n     * Holds an object with keys/values\r\n     * @param {Object.<string, Node>} [properties]   object with key/value pairs\r\n     */\r\n    constructor(properties) {\r\n      super();\r\n      this.properties = properties || {};\r\n\r\n      // validate input\r\n      if (properties) {\r\n        if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\r\n          return isNode(properties[key]);\r\n        })) {\r\n          throw new TypeError('Object containing Nodes expected');\r\n        }\r\n      }\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isObjectNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var evalEntries = {};\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          // we stringify/parse the key here to resolve unicode characters,\r\n          // so you cannot create a key like {\"co\\\\u006Estructor\": null}\r\n          var stringifiedKey = stringify(key);\r\n          var parsedKey = JSON.parse(stringifiedKey);\r\n          var prop = getSafeProperty(this.properties, key);\r\n          evalEntries[parsedKey] = prop._compile(math, argNames);\r\n        }\r\n      }\r\n      return function evalObjectNode(scope, args, context) {\r\n        var obj = {};\r\n        for (var _key in evalEntries) {\r\n          if (hasOwnProperty(evalEntries, _key)) {\r\n            obj[_key] = evalEntries[_key](scope, args, context);\r\n          }\r\n        }\r\n        return obj;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a new ObjectNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ObjectNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      var properties = {};\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\r\n        }\r\n      }\r\n      return new ObjectNode(properties);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ObjectNode}\r\n     */\r\n    clone() {\r\n      var properties = {};\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          properties[key] = this.properties[key];\r\n        }\r\n      }\r\n      return new ObjectNode(properties);\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toString(options) {\r\n      var entries = [];\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\r\n        }\r\n      }\r\n      return '{' + entries.join(', ') + '}';\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        properties: this.properties\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an OperatorNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ObjectNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new ObjectNode(json.properties);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toHTML(options) {\r\n      var entries = [];\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator\">' + ':</span>' + this.properties[key].toHTML(options));\r\n        }\r\n      }\r\n      return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      var entries = [];\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\r\n        }\r\n      }\r\n      var tex = '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\r\n      return tex;\r\n    }\r\n  }\r\n  _defineProperty(ObjectNode, \"name\", name);\r\n  return ObjectNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}