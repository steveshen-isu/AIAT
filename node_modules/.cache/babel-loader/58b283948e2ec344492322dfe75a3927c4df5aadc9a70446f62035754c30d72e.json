{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'usolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'equalScalar', 'DenseMatrix'];\nexport var createUsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\r\n   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.\r\n   *\r\n   * `U * x = b`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.usolve(U, b)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = usolve(a, b)  // [[8], [9]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    usolveAll, lup, slu, usolve, lusolve\r\n   *\r\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\r\n   * @param {Matrix, Array} b       A column vector with the b values\r\n   *\r\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\r\n   */\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      var m = matrix(a);\n      var r = _denseBackwardSubstitution(m, b);\n      return r.valueOf();\n    }\n  });\n  function _denseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n\n    // result\n    var x = [];\n    var mdata = m._data;\n    // loop columns backwards\n    for (var j = columns - 1; j >= 0; j--) {\n      // b[j]\n      var bj = bdata[j][0] || 0;\n      // x[j]\n      var xj = void 0;\n      if (!equalScalar(bj, 0)) {\n        // value at [j, j]\n        var vjj = mdata[j][j];\n        if (equalScalar(vjj, 0)) {\n          // system cannot be solved\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        xj = divideScalar(bj, vjj);\n\n        // loop rows\n        for (var i = j - 1; i >= 0; i--) {\n          // update copy of b\n          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // zero value at j\n        xj = 0;\n      }\n      // update x\n      x[j] = [xj];\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n  function _sparseBackwardSubstitution(m, b) {\n    // make b into a column vector\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n\n    // result\n    var x = [];\n\n    // loop columns backwards\n    for (var j = columns - 1; j >= 0; j--) {\n      var bj = bdata[j][0] || 0;\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n\n        var vjj = 0;\n\n        // upper triangular matrix values & index (column j)\n        var jValues = [];\n        var jIndices = [];\n\n        // first & last indeces in column\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1];\n\n        // values in column, find value at [j, j], loop backwards\n        for (var k = lastIndex - 1; k >= firstIndex; k--) {\n          var i = index[k];\n\n          // check row (rows are not sorted!)\n          if (i === j) {\n            vjj = values[k];\n          } else if (i < j) {\n            // store upper triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        }\n\n        // at this point we must have a value in vjj\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n        var xj = divideScalar(bj, vjj);\n        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];\n        }\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});","map":{"version":3,"names":["factory","createSolveValidation","name","dependencies","createUsolve","_ref","typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix","solveValidation","SparseMatrix_Array__Matrix","m","b","_sparseBackwardSubstitution","DenseMatrix_Array__Matrix","_denseBackwardSubstitution","Array_Array__Matrix","a","r","valueOf","bdata","_data","rows","_size","columns","x","mdata","j","bj","xj","vjj","Error","i","data","size","values","_values","index","_index","ptr","_ptr","jValues","jIndices","firstIndex","lastIndex","k","push","_k","_lastIndex","length","_i"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js"],"sourcesContent":["import { factory } from '../../../utils/factory.js';\r\nimport { createSolveValidation } from './utils/solveValidation.js';\r\nvar name = 'usolve';\r\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'equalScalar', 'DenseMatrix'];\r\nexport var createUsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtractScalar,\r\n    equalScalar,\r\n    DenseMatrix\r\n  } = _ref;\r\n  var solveValidation = createSolveValidation({\r\n    DenseMatrix\r\n  });\r\n\r\n  /**\r\n   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.\r\n   *\r\n   * `U * x = b`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.usolve(U, b)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = usolve(a, b)  // [[8], [9]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    usolveAll, lup, slu, usolve, lusolve\r\n   *\r\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\r\n   * @param {Matrix, Array} b       A column vector with the b values\r\n   *\r\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\r\n   */\r\n  return typed(name, {\r\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(m, b) {\r\n      return _sparseBackwardSubstitution(m, b);\r\n    },\r\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(m, b) {\r\n      return _denseBackwardSubstitution(m, b);\r\n    },\r\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\r\n      var m = matrix(a);\r\n      var r = _denseBackwardSubstitution(m, b);\r\n      return r.valueOf();\r\n    }\r\n  });\r\n  function _denseBackwardSubstitution(m, b) {\r\n    // make b into a column vector\r\n    b = solveValidation(m, b, true);\r\n    var bdata = b._data;\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n\r\n    // result\r\n    var x = [];\r\n    var mdata = m._data;\r\n    // loop columns backwards\r\n    for (var j = columns - 1; j >= 0; j--) {\r\n      // b[j]\r\n      var bj = bdata[j][0] || 0;\r\n      // x[j]\r\n      var xj = void 0;\r\n      if (!equalScalar(bj, 0)) {\r\n        // value at [j, j]\r\n        var vjj = mdata[j][j];\r\n        if (equalScalar(vjj, 0)) {\r\n          // system cannot be solved\r\n          throw new Error('Linear system cannot be solved since matrix is singular');\r\n        }\r\n        xj = divideScalar(bj, vjj);\r\n\r\n        // loop rows\r\n        for (var i = j - 1; i >= 0; i--) {\r\n          // update copy of b\r\n          bdata[i] = [subtractScalar(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\r\n        }\r\n      } else {\r\n        // zero value at j\r\n        xj = 0;\r\n      }\r\n      // update x\r\n      x[j] = [xj];\r\n    }\r\n    return new DenseMatrix({\r\n      data: x,\r\n      size: [rows, 1]\r\n    });\r\n  }\r\n  function _sparseBackwardSubstitution(m, b) {\r\n    // make b into a column vector\r\n    b = solveValidation(m, b, true);\r\n    var bdata = b._data;\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    var values = m._values;\r\n    var index = m._index;\r\n    var ptr = m._ptr;\r\n\r\n    // result\r\n    var x = [];\r\n\r\n    // loop columns backwards\r\n    for (var j = columns - 1; j >= 0; j--) {\r\n      var bj = bdata[j][0] || 0;\r\n      if (!equalScalar(bj, 0)) {\r\n        // non-degenerate row, find solution\r\n\r\n        var vjj = 0;\r\n\r\n        // upper triangular matrix values & index (column j)\r\n        var jValues = [];\r\n        var jIndices = [];\r\n\r\n        // first & last indeces in column\r\n        var firstIndex = ptr[j];\r\n        var lastIndex = ptr[j + 1];\r\n\r\n        // values in column, find value at [j, j], loop backwards\r\n        for (var k = lastIndex - 1; k >= firstIndex; k--) {\r\n          var i = index[k];\r\n\r\n          // check row (rows are not sorted!)\r\n          if (i === j) {\r\n            vjj = values[k];\r\n          } else if (i < j) {\r\n            // store upper triangular\r\n            jValues.push(values[k]);\r\n            jIndices.push(i);\r\n          }\r\n        }\r\n\r\n        // at this point we must have a value in vjj\r\n        if (equalScalar(vjj, 0)) {\r\n          throw new Error('Linear system cannot be solved since matrix is singular');\r\n        }\r\n        var xj = divideScalar(bj, vjj);\r\n        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {\r\n          var _i = jIndices[_k];\r\n          bdata[_i] = [subtractScalar(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];\r\n        }\r\n        x[j] = [xj];\r\n      } else {\r\n        // degenerate row, we can choose any value\r\n        x[j] = [0];\r\n      }\r\n    }\r\n    return new DenseMatrix({\r\n      data: x,\r\n      size: [rows, 1]\r\n    });\r\n  }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}