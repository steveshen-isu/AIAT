{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'Spa';\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\nexport var createSpaClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    addScalar,\n    equalScalar,\n    FibonacciHeap\n  } = _ref;\n  /**\r\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\r\n   * of the vector elements and an ordered list of non-zero elements.\r\n   */\n  function Spa() {\n    if (!(this instanceof Spa)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    // allocate vector, TODO use typed arrays\n    this._values = [];\n    this._heap = new FibonacciHeap();\n  }\n\n  /**\r\n   * Attach type information\r\n   */\n  Spa.prototype.type = 'Spa';\n  Spa.prototype.isSpa = true;\n\n  /**\r\n   * Set the value for index i.\r\n   *\r\n   * @param {number} i                       The index\r\n   * @param {number | BigNumber | Complex}   The value at index i\r\n   */\n  Spa.prototype.set = function (i, v) {\n    // check we have a value @ i\n    if (!this._values[i]) {\n      // insert in heap\n      var node = this._heap.insert(i, v);\n      // set the value @ i\n      this._values[i] = node;\n    } else {\n      // update the value @ i\n      this._values[i].value = v;\n    }\n  };\n  Spa.prototype.get = function (i) {\n    var node = this._values[i];\n    if (node) {\n      return node.value;\n    }\n    return 0;\n  };\n  Spa.prototype.accumulate = function (i, v) {\n    // node @ i\n    var node = this._values[i];\n    if (!node) {\n      // insert in heap\n      node = this._heap.insert(i, v);\n      // initialize value\n      this._values[i] = node;\n    } else {\n      // accumulate value\n      node.value = addScalar(node.value, v);\n    }\n  };\n  Spa.prototype.forEach = function (from, to, callback) {\n    // references\n    var heap = this._heap;\n    var values = this._values;\n    // nodes\n    var nodes = [];\n    // node with minimum key, save it\n    var node = heap.extractMinimum();\n    if (node) {\n      nodes.push(node);\n    }\n    // extract nodes from heap (ordered)\n    while (node && node.key <= to) {\n      // check it is in range\n      if (node.key >= from) {\n        // check value is not zero\n        if (!equalScalar(node.value, 0)) {\n          // invoke callback\n          callback(node.key, node.value, this);\n        }\n      }\n      // extract next node, save it\n      node = heap.extractMinimum();\n      if (node) {\n        nodes.push(node);\n      }\n    }\n    // reinsert all nodes in heap\n    for (var i = 0; i < nodes.length; i++) {\n      // current node\n      var n = nodes[i];\n      // insert node in heap\n      node = heap.insert(n.key, n.value);\n      // update values\n      values[node.key] = node;\n    }\n  };\n  Spa.prototype.swap = function (i, j) {\n    // node @ i and j\n    var nodei = this._values[i];\n    var nodej = this._values[j];\n    // check we need to insert indeces\n    if (!nodei && nodej) {\n      // insert in heap\n      nodei = this._heap.insert(i, nodej.value);\n      // remove from heap\n      this._heap.remove(nodej);\n      // set values\n      this._values[i] = nodei;\n      this._values[j] = undefined;\n    } else if (nodei && !nodej) {\n      // insert in heap\n      nodej = this._heap.insert(j, nodei.value);\n      // remove from heap\n      this._heap.remove(nodei);\n      // set values\n      this._values[j] = nodej;\n      this._values[i] = undefined;\n    } else if (nodei && nodej) {\n      // swap values\n      var v = nodei.value;\n      nodei.value = nodej.value;\n      nodej.value = v;\n    }\n  };\n  return Spa;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["factory","name","dependencies","createSpaClass","_ref","addScalar","equalScalar","FibonacciHeap","Spa","SyntaxError","_values","_heap","prototype","type","isSpa","set","i","v","node","insert","value","get","accumulate","forEach","from","to","callback","heap","values","nodes","extractMinimum","push","key","length","n","swap","j","nodei","nodej","remove","undefined","isClass"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/type/matrix/Spa.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'Spa';\r\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\r\nexport var createSpaClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    addScalar,\r\n    equalScalar,\r\n    FibonacciHeap\r\n  } = _ref;\r\n  /**\r\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\r\n   * of the vector elements and an ordered list of non-zero elements.\r\n   */\r\n  function Spa() {\r\n    if (!(this instanceof Spa)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    // allocate vector, TODO use typed arrays\r\n    this._values = [];\r\n    this._heap = new FibonacciHeap();\r\n  }\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Spa.prototype.type = 'Spa';\r\n  Spa.prototype.isSpa = true;\r\n\r\n  /**\r\n   * Set the value for index i.\r\n   *\r\n   * @param {number} i                       The index\r\n   * @param {number | BigNumber | Complex}   The value at index i\r\n   */\r\n  Spa.prototype.set = function (i, v) {\r\n    // check we have a value @ i\r\n    if (!this._values[i]) {\r\n      // insert in heap\r\n      var node = this._heap.insert(i, v);\r\n      // set the value @ i\r\n      this._values[i] = node;\r\n    } else {\r\n      // update the value @ i\r\n      this._values[i].value = v;\r\n    }\r\n  };\r\n  Spa.prototype.get = function (i) {\r\n    var node = this._values[i];\r\n    if (node) {\r\n      return node.value;\r\n    }\r\n    return 0;\r\n  };\r\n  Spa.prototype.accumulate = function (i, v) {\r\n    // node @ i\r\n    var node = this._values[i];\r\n    if (!node) {\r\n      // insert in heap\r\n      node = this._heap.insert(i, v);\r\n      // initialize value\r\n      this._values[i] = node;\r\n    } else {\r\n      // accumulate value\r\n      node.value = addScalar(node.value, v);\r\n    }\r\n  };\r\n  Spa.prototype.forEach = function (from, to, callback) {\r\n    // references\r\n    var heap = this._heap;\r\n    var values = this._values;\r\n    // nodes\r\n    var nodes = [];\r\n    // node with minimum key, save it\r\n    var node = heap.extractMinimum();\r\n    if (node) {\r\n      nodes.push(node);\r\n    }\r\n    // extract nodes from heap (ordered)\r\n    while (node && node.key <= to) {\r\n      // check it is in range\r\n      if (node.key >= from) {\r\n        // check value is not zero\r\n        if (!equalScalar(node.value, 0)) {\r\n          // invoke callback\r\n          callback(node.key, node.value, this);\r\n        }\r\n      }\r\n      // extract next node, save it\r\n      node = heap.extractMinimum();\r\n      if (node) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    // reinsert all nodes in heap\r\n    for (var i = 0; i < nodes.length; i++) {\r\n      // current node\r\n      var n = nodes[i];\r\n      // insert node in heap\r\n      node = heap.insert(n.key, n.value);\r\n      // update values\r\n      values[node.key] = node;\r\n    }\r\n  };\r\n  Spa.prototype.swap = function (i, j) {\r\n    // node @ i and j\r\n    var nodei = this._values[i];\r\n    var nodej = this._values[j];\r\n    // check we need to insert indeces\r\n    if (!nodei && nodej) {\r\n      // insert in heap\r\n      nodei = this._heap.insert(i, nodej.value);\r\n      // remove from heap\r\n      this._heap.remove(nodej);\r\n      // set values\r\n      this._values[i] = nodei;\r\n      this._values[j] = undefined;\r\n    } else if (nodei && !nodej) {\r\n      // insert in heap\r\n      nodej = this._heap.insert(j, nodei.value);\r\n      // remove from heap\r\n      this._heap.remove(nodei);\r\n      // set values\r\n      this._values[j] = nodej;\r\n      this._values[i] = undefined;\r\n    } else if (nodei && nodej) {\r\n      // swap values\r\n      var v = nodei.value;\r\n      nodei.value = nodej.value;\r\n      nodej.value = v;\r\n    }\r\n  };\r\n  return Spa;\r\n}, {\r\n  isClass: true\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}