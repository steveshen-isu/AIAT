{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { arraySize } from '../../utils/array.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { IndexError } from '../../error/IndexError.js';\nvar name = 'apply';\nvar dependencies = ['typed', 'isInteger'];\nexport var createApply = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    isInteger\n  } = _ref;\n  /**\r\n   * Apply a function that maps an array to a scalar\r\n   * along a given axis of a matrix or array.\r\n   * Returns a new matrix or array with one less dimension than the input.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.apply(A, dim, callback)\r\n   *\r\n   * Where:\r\n   *\r\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const A = [[1, 2], [3, 4]]\r\n   *    const sum = math.sum\r\n   *\r\n   *    math.apply(A, 0, sum)             // returns [4, 6]\r\n   *    math.apply(A, 1, sum)             // returns [3, 7]\r\n   *\r\n   * See also:\r\n   *\r\n   *    map, filter, forEach\r\n   *\r\n   * @param {Array | Matrix} array   The input Matrix\r\n   * @param {number} dim             The dimension along which the callback is applied\r\n   * @param {Function} callback      The callback function that is applied. This Function\r\n   *                                 should take an array or 1-d matrix as an input and\r\n   *                                 return a number.\r\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\r\n   */\n  return typed(name, {\n    'Array | Matrix, number | BigNumber, function': function Array__Matrix_number__BigNumber_function(mat, dim, callback) {\n      if (!isInteger(dim)) {\n        throw new TypeError('Integer number expected for dimension');\n      }\n      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\n      if (dim < 0 || dim >= size.length) {\n        throw new IndexError(dim, size.length);\n      }\n      if (isMatrix(mat)) {\n        return mat.create(_apply(mat.valueOf(), dim, callback), mat.datatype());\n      } else {\n        return _apply(mat, dim, callback);\n      }\n    }\n  });\n});\n\n/**\r\n * Recursively reduce a matrix\r\n * @param {Array} mat\r\n * @param {number} dim\r\n * @param {Function} callback\r\n * @returns {Array} ret\r\n * @private\r\n */\nfunction _apply(mat, dim, callback) {\n  var i, ret, tran;\n  if (dim <= 0) {\n    if (!Array.isArray(mat[0])) {\n      return callback(mat);\n    } else {\n      tran = _switch(mat);\n      ret = [];\n      for (i = 0; i < tran.length; i++) {\n        ret[i] = _apply(tran[i], dim - 1, callback);\n      }\n      return ret;\n    }\n  } else {\n    ret = [];\n    for (i = 0; i < mat.length; i++) {\n      ret[i] = _apply(mat[i], dim - 1, callback);\n    }\n    return ret;\n  }\n}\n\n/**\r\n * Transpose a matrix\r\n * @param {Array} mat\r\n * @returns {Array} ret\r\n * @private\r\n */\nfunction _switch(mat) {\n  var I = mat.length;\n  var J = mat[0].length;\n  var i, j;\n  var ret = [];\n  for (j = 0; j < J; j++) {\n    var tmp = [];\n    for (i = 0; i < I; i++) {\n      tmp.push(mat[i][j]);\n    }\n    ret.push(tmp);\n  }\n  return ret;\n}","map":{"version":3,"names":["factory","arraySize","isMatrix","IndexError","name","dependencies","createApply","_ref","typed","isInteger","Array__Matrix_number__BigNumber_function","mat","dim","callback","TypeError","size","Array","isArray","length","create","_apply","valueOf","datatype","i","ret","tran","_switch","I","J","j","tmp","push"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/matrix/apply.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { arraySize } from '../../utils/array.js';\r\nimport { isMatrix } from '../../utils/is.js';\r\nimport { IndexError } from '../../error/IndexError.js';\r\nvar name = 'apply';\r\nvar dependencies = ['typed', 'isInteger'];\r\nexport var createApply = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    isInteger\r\n  } = _ref;\r\n  /**\r\n   * Apply a function that maps an array to a scalar\r\n   * along a given axis of a matrix or array.\r\n   * Returns a new matrix or array with one less dimension than the input.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.apply(A, dim, callback)\r\n   *\r\n   * Where:\r\n   *\r\n   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const A = [[1, 2], [3, 4]]\r\n   *    const sum = math.sum\r\n   *\r\n   *    math.apply(A, 0, sum)             // returns [4, 6]\r\n   *    math.apply(A, 1, sum)             // returns [3, 7]\r\n   *\r\n   * See also:\r\n   *\r\n   *    map, filter, forEach\r\n   *\r\n   * @param {Array | Matrix} array   The input Matrix\r\n   * @param {number} dim             The dimension along which the callback is applied\r\n   * @param {Function} callback      The callback function that is applied. This Function\r\n   *                                 should take an array or 1-d matrix as an input and\r\n   *                                 return a number.\r\n   * @return {Array | Matrix} res    The residual matrix with the function applied over some dimension.\r\n   */\r\n  return typed(name, {\r\n    'Array | Matrix, number | BigNumber, function': function Array__Matrix_number__BigNumber_function(mat, dim, callback) {\r\n      if (!isInteger(dim)) {\r\n        throw new TypeError('Integer number expected for dimension');\r\n      }\r\n      var size = Array.isArray(mat) ? arraySize(mat) : mat.size();\r\n      if (dim < 0 || dim >= size.length) {\r\n        throw new IndexError(dim, size.length);\r\n      }\r\n      if (isMatrix(mat)) {\r\n        return mat.create(_apply(mat.valueOf(), dim, callback), mat.datatype());\r\n      } else {\r\n        return _apply(mat, dim, callback);\r\n      }\r\n    }\r\n  });\r\n});\r\n\r\n/**\r\n * Recursively reduce a matrix\r\n * @param {Array} mat\r\n * @param {number} dim\r\n * @param {Function} callback\r\n * @returns {Array} ret\r\n * @private\r\n */\r\nfunction _apply(mat, dim, callback) {\r\n  var i, ret, tran;\r\n  if (dim <= 0) {\r\n    if (!Array.isArray(mat[0])) {\r\n      return callback(mat);\r\n    } else {\r\n      tran = _switch(mat);\r\n      ret = [];\r\n      for (i = 0; i < tran.length; i++) {\r\n        ret[i] = _apply(tran[i], dim - 1, callback);\r\n      }\r\n      return ret;\r\n    }\r\n  } else {\r\n    ret = [];\r\n    for (i = 0; i < mat.length; i++) {\r\n      ret[i] = _apply(mat[i], dim - 1, callback);\r\n    }\r\n    return ret;\r\n  }\r\n}\r\n\r\n/**\r\n * Transpose a matrix\r\n * @param {Array} mat\r\n * @returns {Array} ret\r\n * @private\r\n */\r\nfunction _switch(mat) {\r\n  var I = mat.length;\r\n  var J = mat[0].length;\r\n  var i, j;\r\n  var ret = [];\r\n  for (j = 0; j < J; j++) {\r\n    var tmp = [];\r\n    for (i = 0; i < I; i++) {\r\n      tmp.push(mat[i][j]);\r\n    }\r\n    ret.push(tmp);\r\n  }\r\n  return ret;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}