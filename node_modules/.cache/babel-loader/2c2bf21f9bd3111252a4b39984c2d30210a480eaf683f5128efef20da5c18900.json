{"ast":null,"code":"/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module, Function */\n\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n  require('./Calculus.js');\n}\n(function () {\n  \"use strict\";\n\n  /*shortcuts*/\n  var core = nerdamer.getCore(),\n    _ = core.PARSER,\n    N = core.groups.N,\n    P = core.groups.P,\n    S = core.groups.S,\n    EX = core.groups.EX,\n    FN = core.groups.FN,\n    PL = core.groups.PL,\n    CP = core.groups.CP,\n    CB = core.groups.CB,\n    keys = core.Utils.keys,\n    even = core.Utils.even,\n    variables = core.Utils.variables,\n    format = core.Utils.format,\n    round = core.Utils.round,\n    Frac = core.Frac,\n    isInt = core.Utils.isInt,\n    Symbol = core.Symbol,\n    CONST_HASH = core.Settings.CONST_HASH,\n    math = core.Utils.importFunctions(),\n    evaluate = core.Utils.evaluate;\n  //*************** CLASSES ***************//\n  /**\r\n   * Converts a symbol into an equivalent polynomial arrays of \r\n   * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n   * Univariate polymials only. \r\n   * @param {Symbol|Number} symbol\r\n   * @param {String} variable The variable name of the polynomial\r\n   * @param {int} order\r\n   */\n  function Polynomial(symbol, variable, order) {\n    if (core.Utils.isSymbol(symbol)) {\n      this.parse(symbol);\n      this.variable = this.variable || variable;\n    } else if (!isNaN(symbol)) {\n      order = order || 0;\n      if (variable === undefined) throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\n      this.coeffs = [];\n      this.coeffs[order] = symbol;\n      this.fill(symbol);\n    } else if (typeof symbol === 'string') {\n      this.parse(_.parse(symbol));\n    }\n  }\n  /**\r\n   * Creates a Polynomial given an array of coefficients\r\n   * @param {int[]} arr\r\n   * @param {String} variable\r\n   * @returns {Polynomial}\r\n   */\n  Polynomial.fromArray = function (arr, variable) {\n    if (typeof variable === 'undefined') throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\n    var p = new Polynomial();\n    p.coeffs = arr;\n    p.variable = variable;\n    return p;\n  };\n  Polynomial.fit = function (c1, c2, n, base, p, variable) {\n    //after having looped through and mod 10 the number to get the matching factor\n    var terms = new Array(p + 1),\n      t = n - c2;\n    terms[0] = c2; //the constants is assumed to be correct\n    //constant for x^p is also assumed know so add\n    terms[p] = c1;\n    t -= c1 * Math.pow(base, p);\n    //start fitting\n    for (var i = p - 1; i > 0; i--) {\n      var b = Math.pow(base, i),\n        //we want as many wholes as possible\n        q = t / b,\n        sign = Math.sign(q);\n      var c = sign * Math.floor(Math.abs(q));\n      t -= c * b;\n      terms[i] = c;\n    }\n    if (t !== 0) return null;\n    for (var i = 0; i < terms.length; i++) terms[i] = new Frac(terms[i]);\n    return Polynomial.fromArray(terms, variable);\n  };\n  Polynomial.prototype = {\n    /**\r\n     * Converts Symbol to Polynomial\r\n     * @param {Symbol} symbol\r\n     * @param {Array} c - a collector array\r\n     * @returns {Polynomial}\r\n     */\n    parse: function (symbol, c) {\n      this.variable = variables(symbol)[0];\n      if (!symbol.isPoly()) throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\n      c = c || [];\n      if (!symbol.power.absEquals(1)) symbol = _.expand(symbol);\n      if (symbol.group === core.groups.N) {\n        c[0] = symbol.multiplier;\n      } else if (symbol.group === core.groups.S) {\n        c[symbol.power.toDecimal()] = symbol.multiplier;\n      } else {\n        for (var x in symbol.symbols) {\n          var sub = symbol.symbols[x],\n            p = sub.power;\n          if (core.Utils.isSymbol(p)) throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\n          p = sub.group === N ? 0 : p.toDecimal();\n          if (sub.symbols) {\n            this.parse(sub, c);\n          } else {\n            c[p] = sub.multiplier;\n          }\n        }\n      }\n      this.coeffs = c;\n      this.fill();\n    },\n    /**\r\n     * Fills in the holes in a polynomial with zeroes\r\n     * @param {Number} x - The number to fill the holes with\r\n     */\n    fill: function (x) {\n      x = Number(x) || 0;\n      var l = this.coeffs.length;\n      for (var i = 0; i < l; i++) {\n        if (this.coeffs[i] === undefined) {\n          this.coeffs[i] = new Frac(x);\n        }\n      }\n      return this;\n    },\n    /**\r\n     * Removes higher order zeros or a specific coefficient\r\n     * @returns {Array}\r\n     */\n    trim: function () {\n      var l = this.coeffs.length;\n      while (l--) {\n        var c = this.coeffs[l];\n        var equalsZero = c.equals(0);\n        if (c && equalsZero) {\n          if (l === 0) break;\n          this.coeffs.pop();\n        } else break;\n      }\n      return this;\n    },\n    /*\r\n     * Returns polynomial mod p **currently fails**\r\n     * @param {Number} p\r\n     * @returns {Polynomial}\r\n     */\n    modP: function (p) {\n      var l = this.coeffs.length;\n      for (var i = 0; i < l; i++) {\n        var c = this.coeffs[i];\n        if (c < 0) {\n          //go borrow\n          var b; //a coefficient > 0\n          for (var j = i; j < l; j++) {\n            //starting from where we left off\n            if (this.coeffs[j] > 0) {\n              b = this.coeffs[j];\n              break;\n            }\n          }\n          if (b) {\n            //if such a coefficient exists\n            for (j; j > i; j--) {\n              //go down the line and adjust using p\n              this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\n              this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\n            }\n            c = this.coeffs[i]; //reset c\n          }\n        }\n        var d = c.mod(p);\n        var w = c.subtract(d).divide(p);\n        if (!w.equals(0)) {\n          var up_one = i + 1;\n          var next = this.coeffs[up_one] || new Frac(0);\n          next = next.add(w);\n          this.coeffs[up_one] = new Frac(next);\n          this.coeffs[i] = new Frac(d);\n        }\n      }\n      return this;\n    },\n    /**\r\n     * Adds together 2 polynomials\r\n     * @param {Polynomial} poly\r\n     */\n    add: function (poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n          b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.add(b);\n      }\n      return this;\n    },\n    /**\r\n     * Adds together 2 polynomials\r\n     * @param {Polynomial} poly\r\n     */\n    subtract: function (poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n          b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.subtract(b);\n      }\n      return this;\n    },\n    divide: function (poly) {\n      var variable = this.variable,\n        dividend = core.Utils.arrayClone(this.coeffs),\n        divisor = core.Utils.arrayClone(poly.coeffs),\n        n = dividend.length,\n        mp = divisor.length - 1,\n        quotient = [];\n\n      //loop through the dividend\n      for (var i = 0; i < n; i++) {\n        var p = n - (i + 1);\n        //get the difference of the powers\n        var d = p - mp;\n        //get the quotient of the coefficients\n        var q = dividend[p].divide(divisor[mp]);\n        if (d < 0) break; //the divisor is not greater than the dividend\n        //place it in the quotient\n        quotient[d] = q;\n        for (var j = 0; j <= mp; j++) {\n          //reduce the dividend\n          dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));\n        }\n      }\n\n      //clean up\n      var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(),\n        //pass in x for safety\n        p2 = Polynomial.fromArray(quotient, variable || 'x');\n      return [p2, p1];\n    },\n    multiply: function (poly) {\n      var l1 = this.coeffs.length,\n        l2 = poly.coeffs.length,\n        c = []; //array to be returned\n      for (var i = 0; i < l1; i++) {\n        var x1 = this.coeffs[i];\n        for (var j = 0; j < l2; j++) {\n          var k = i + j,\n            //add the powers together\n            x2 = poly.coeffs[j],\n            e = c[k] || new Frac(0); //get the existing term from the new array\n          c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\n        }\n      }\n      this.coeffs = c;\n      return this;\n    },\n    /**\r\n     * Checks if a polynomial is zero\r\n     * @returns {Boolean}\r\n     */\n    isZero: function () {\n      var l = this.coeffs.length;\n      for (var i = 0; i < l; i++) {\n        var e = this.coeffs[i];\n        if (!e.equals(0)) return false;\n      }\n      return true;\n    },\n    /** \r\n     * Substitutes in a number n into the polynomial p(n)\r\n     * @param {Number} n\r\n     * @returns {Frac}\r\n     */\n    sub: function (n) {\n      var sum = new Frac(0),\n        l = this.coeffs.length;\n      for (var i = 0; i < l; i++) {\n        var t = this.coeffs[i];\n        if (!t.equals(0)) sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\n      }\n      return sum;\n    },\n    /**\r\n     * Returns a clone of the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    clone: function () {\n      var p = new Polynomial();\n      p.coeffs = this.coeffs;\n      p.variable = this.variable;\n      return p;\n    },\n    /**\r\n     * Gets the degree of the polynomial\r\n     * @returns {Number}\r\n     */\n    deg: function () {\n      this.trim();\n      return this.coeffs.length - 1;\n    },\n    /**\r\n     * Returns a lead coefficient\r\n     * @returns {Frac}\r\n     */\n    lc: function () {\n      return this.coeffs[this.deg()].clone();\n    },\n    /**\r\n     * Converts polynomial into a monic polynomial\r\n     * @returns {Polynomial}\r\n     */\n    monic: function () {\n      var lc = this.lc(),\n        l = this.coeffs.length;\n      for (var i = 0; i < l; i++) this.coeffs[i] = this.coeffs[i].divide(lc);\n      return this;\n    },\n    /**\r\n     * Returns the GCD of two polynomials\r\n     * @param {Polynomial} poly\r\n     * @returns {Polynomial}\r\n     */\n    gcd: function (poly) {\n      //get the maximum power of each\n      var mp1 = this.coeffs.length - 1,\n        mp2 = poly.coeffs.length - 1,\n        T;\n      //swap so we always have the greater power first\n      if (mp1 < mp2) {\n        return poly.gcd(this);\n      }\n      var a = this;\n      while (!poly.isZero()) {\n        var t = poly.clone();\n        a = a.clone();\n        T = a.divide(t);\n        poly = T[1];\n        a = t;\n      }\n      var gcd = core.Math2.QGCD.apply(null, a.coeffs);\n      if (!gcd.equals(1)) {\n        var l = a.coeffs.length;\n        for (var i = 0; i < l; i++) {\n          a.coeffs[i] = a.coeffs[i].divide(gcd);\n        }\n      }\n      return a;\n    },\n    /**\r\n     * Differentiates the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    diff: function () {\n      var new_array = [],\n        l = this.coeffs.length;\n      for (var i = 1; i < l; i++) new_array.push(this.coeffs[i].multiply(new Frac(i)));\n      this.coeffs = new_array;\n      return this;\n    },\n    /**\r\n     * Integrates the polynomial\r\n     * @returns {Polynomial} \r\n     */\n    integrate: function () {\n      var new_array = [0],\n        l = this.coeffs.length;\n      for (var i = 0; i < l; i++) {\n        var c = new Frac(i + 1);\n        new_array[c] = this.coeffs[i].divide(c);\n      }\n      this.coeffs = new_array;\n      return this;\n    },\n    /**\r\n     * Returns the Greatest common factor of the polynomial\r\n     * @param {bool} toPolynomial - true if a polynomial is wanted\r\n     * @returns {Frac|Polynomial}\r\n     */\n    gcf: function (toPolynomial) {\n      //get the first nozero coefficient and returns its power\n      var fnz = function (a) {\n          for (var i = 0; i < a.length; i++) if (!a[i].equals(0)) return i;\n        },\n        ca = [];\n      for (var i = 0; i < this.coeffs.length; i++) {\n        var c = this.coeffs[i];\n        if (!c.equals(0) && ca.indexOf(c) === -1) ca.push(c);\n      }\n      var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\n      if (toPolynomial) {\n        var parr = [];\n        parr[p[1] - 1] = p[0];\n        p = Polynomial.fromArray(parr, this.variable).fill();\n      }\n      return p;\n    },\n    /**\r\n     * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n     * @param {bool} incl_img - Include imaginary numbers \r\n     */\n    quad: function (incl_img) {\n      var roots = [];\n      if (this.coeffs.length > 3) throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\n      if (this.coeffs.length === 0) throw new Error('Polynomial array has no terms');\n      var a = this.coeffs[2] || 0,\n        b = this.coeffs[1] || 0,\n        c = this.coeffs[0];\n      var dsc = b * b - 4 * a * c;\n      if (dsc < 0 && !incl_img) return roots;else {\n        roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\n        roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\n      }\n      return roots;\n    },\n    /**\r\n     * Makes polynomial square free\r\n     * @returns {Array}\r\n     */\n    squareFree: function () {\n      var a = this.clone(),\n        i = 1,\n        b = a.clone().diff(),\n        c = a.clone().gcd(b),\n        w = a.divide(c)[0];\n      var output = Polynomial.fromArray([new Frac(1)], a.variable);\n      while (!c.equalsNumber(1)) {\n        var y = w.gcd(c);\n        var z = w.divide(y)[0];\n        //one of the factors may have shown up since it's square but smaller than the \n        //one where finding\n        if (!z.equalsNumber(1) && i > 1) {\n          var t = z.clone();\n          for (var j = 1; j < i; j++) t.multiply(z.clone());\n          z = t;\n        }\n        output = output.multiply(z);\n        i++;\n        w = y;\n        c = c.divide(y)[0];\n      }\n      return [output, w, i];\n    },\n    /**\r\n     * Converts polynomial to Symbol\r\n     * @returns {Symbol}\r\n     */\n    toSymbol: function () {\n      var l = this.coeffs.length,\n        variable = this.variable;\n      if (l === 0) return new core.Symbol(0);\n      var end = l - 1,\n        str = '';\n      for (var i = 0; i < l; i++) {\n        //place the plus sign for all but the last one\n        var plus = i === end ? '' : '+',\n          e = this.coeffs[i];\n        if (!e.equals(0)) str += e + '*' + variable + '^' + i + plus;\n      }\n      return _.parse(str);\n    },\n    /**\r\n     * Checks if polynomial is equal to a number\r\n     * @param {Number} x\r\n     * @returns {Boolean}\r\n     */\n    equalsNumber: function (x) {\n      this.trim();\n      return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\n    },\n    toString: function () {\n      return this.toSymbol().toString();\n    }\n  };\n\n  /**\r\n   * TODO\r\n   * ===================================================================================\r\n   * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n   * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n   * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n   * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n   * ===================================================================================\r\n   * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n   * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n   * so the symbol multiplier carries the coefficients for all contained symbols.\r\n   * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n   * @param {Array} c The coefficient array\r\n   * @param {boolean} with_order \r\n   * @return {Array}\r\n   */\n  Symbol.prototype.coeffs = function (c, with_order) {\n    if (with_order && !this.isPoly(true)) _.error('Polynomial expected when requesting coefficients with order');\n    c = c || [];\n    var s = this.clone().distributeMultiplier();\n    if (s.isComposite()) {\n      for (var x in s.symbols) {\n        var sub = s.symbols[x];\n        if (sub.isComposite()) {\n          sub.clone().distributeMultiplier().coeffs(c, with_order);\n        } else {\n          if (with_order) c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;else {\n            c.push(sub.multiplier);\n          }\n        }\n      }\n    } else {\n      if (with_order) c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;else {\n        if (s.group === CB && s.isImaginary()) {\n          var m = new Symbol(s.multiplier);\n          s.each(function (x) {\n            //add the imaginary part\n            if (x.isConstant(true) || x.imaginary) m = _.multiply(m, x);\n          });\n          c.push(m);\n        } else c.push(s.multiplier);\n      }\n    }\n    //fill the holes\n    if (with_order) {\n      for (var i = 0; i < c.length; i++) if (c[i] === undefined) c[i] = new Symbol(0);\n    }\n    return c;\n  };\n  Symbol.prototype.tBase = function (map) {\n    if (typeof map === 'undefined') throw new Error('Symbol.tBase requires a map object!');\n    var terms = [];\n    var symbols = this.collectSymbols(null, null, null, true),\n      l = symbols.length;\n    for (var i = 0; i < l; i++) {\n      var symbol = symbols[i],\n        g = symbol.group,\n        nterm = new MVTerm(symbol.multiplier, [], map);\n      if (g === CB) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x];\n          nterm.terms[map[x]] = sym.power;\n        }\n      } else {\n        nterm.terms[map[symbol.value]] = symbol.power;\n      }\n      terms.push(nterm.fill());\n      nterm.updateCount();\n    }\n    return terms;\n  };\n  Symbol.prototype.altVar = function (x) {\n    var m = this.multiplier.toString(),\n      p = this.power.toString();\n    return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\n  };\n  /**\r\n   * Checks to see if the symbols contain the same variables\r\n   * @param {Symbol} symbol\r\n   * @returns {Boolean}\r\n   */\n  Symbol.prototype.sameVars = function (symbol) {\n    if (!(this.symbols || this.group === symbol.group)) return false;\n    for (var x in this.symbols) {\n      var a = this.symbols[x],\n        b = symbol.symbols[x];\n      if (!b) return false;\n      if (a.value !== b.value) return false;\n    }\n    return true;\n  };\n  /**\r\n   * Groups the terms in a symbol with respect to a variable\r\n   * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n   * @returns {Factors}\r\n   */\n  Symbol.prototype.groupTerms = function (x) {\n    x = String(x);\n    var f, p, egrouped;\n    var grouped = [];\n    this.each(function (e) {\n      if (e.group === PL) {\n        egrouped = e.groupTerms(x);\n        for (var i = 0; i < egrouped.length; i++) {\n          var el = egrouped[i];\n          if (el) grouped[i] = el;\n        }\n      } else {\n        f = core.Utils.decompose_fn(e, x, true);\n        p = f.x.value === x ? Number(f.x.power) : 0;\n        //check if there's an existing value\n        grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\n      }\n    });\n    return grouped;\n  };\n  /**\r\n   * Use this to collect Factors\r\n   * @returns {Symbol[]}\r\n   */\n  Symbol.prototype.collectFactors = function () {\n    var factors = [];\n    if (this.group === CB) this.each(function (x) {\n      factors.push(x.clone());\n    });else factors.push(this.clone());\n    return factors;\n  };\n  /**\r\n   * A container class for factors\r\n   * @returns {Factors}\r\n   */\n  function Factors() {\n    this.factors = {};\n    this.length = 0;\n  }\n  ;\n  Factors.prototype.getNumberSymbolics = function () {\n    var n = 0;\n    this.each(function (x) {\n      if (!x.isConstant(true)) n++;\n    });\n    return n;\n  };\n  /**\r\n   * Adds the factors to the factor object\r\n   * @param {Symbo} s\r\n   * @returns {Factors}\r\n   */\n  Factors.prototype.add = function (s) {\n    if (s.equals(0)) return this; //nothing to add\n\n    //we don't want to carry -1 as a factor. If a factor already exists,\n    //then add the minus one to that factor and return.\n    if (s.equals(-1) && this.length > 0) {\n      var fo = core.Utils.firstObject(this.factors, null, true);\n      this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\n      delete this.factors[fo.key];\n      this.length--;\n      return this;\n    }\n    if (s.group === CB) {\n      var factors = this;\n      if (!s.multiplier.equals(1)) factors.add(new Symbol(s.multiplier));\n      s.each(function (x) {\n        factors.add(x);\n      });\n    } else {\n      if (this.preAdd)\n        //if a preAdd function was defined call it to do prep\n        s = this.preAdd(s);\n      if (this.pFactor)\n        //if the symbol isn't linear add back the power\n        s = _.pow(s, new Symbol(this.pFactor));\n      var is_constant = s.isConstant();\n      if (is_constant && s.equals(1)) return this; //don't add 1\n      var v = is_constant ? s.value : s.text();\n      if (v in this.factors) {\n        this.factors[v] = _.multiply(this.factors[v], s);\n        //did the addition cancel out the existing factor? If so remove it and decrement the length\n        if (this.factors[v].equals(1)) {\n          delete this.factors[v];\n          this.length--;\n        }\n      } else {\n        this.factors[v] = s;\n        this.length++;\n      }\n    }\n    return this;\n  };\n  /**\r\n   * Converts the factor object to a Symbol\r\n   * @returns {Symbol}\r\n   */\n  Factors.prototype.toSymbol = function () {\n    var factored = new Symbol(1);\n    var factors = Object.values(this.factors).sort(function (a, b) {\n      return a.group > b.group;\n    });\n    for (var i = 0, l = factors.length; i < l; i++) {\n      var f = factors[i];\n\n      //don't wrap group S or FN\n      var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ? _.symfunction(core.PARENTHESIS, [f]) : f;\n      factored = _.multiply(factored, factor);\n    }\n    if (factored.fname === '') factored = Symbol.unwrapPARENS(factored);\n    return factored;\n  };\n  /**\r\n   * Merges 2 factor objects into one\r\n   * @param {Factor} o\r\n   * @returns {Factors}\r\n   */\n  Factors.prototype.merge = function (o) {\n    for (var x in o) {\n      if (x in this.factors) this.factors[x] = _.multiply(this.factors[x], o[x]);else this.factors[x] = o[x];\n    }\n    return this;\n  };\n  /**\r\n   * The iterator for the factor object\r\n   * @param {Function} f - callback\r\n   * @returns {Factor}\r\n   */\n  Factors.prototype.each = function (f) {\n    for (var x in this.factors) {\n      var factor = this.factors[x];\n      if (factor.fname === core.PARENTHESIS && factor.isLinear()) factor = factor.args[0];\n      f.call(this, factor, x);\n    }\n    return this;\n  };\n  /**\r\n   * Return the number of factors contained in the factor object\r\n   * @returns {int}\r\n   */\n  Factors.prototype.count = function () {\n    return keys(this.factors).length;\n  };\n  /**\r\n   * Cleans up factors from -1\r\n   * @returns {undefined}\r\n   */\n  Factors.prototype.clean = function () {\n    try {\n      var h = core.Settings.CONST_HASH;\n      if (this.factors[h].lessThan(0)) {\n        if (this.factors[h].equals(-1)) delete this.factors[h];else this.factors[h].negate();\n        this.each(function (x) {\n          x.negate();\n        });\n      }\n    } catch (e) {}\n    ;\n  };\n  Factors.prototype.toString = function () {\n    return this.toSymbol().toString();\n  };\n\n  //a wrapper for performing multivariate division\n  function MVTerm(coeff, terms, map) {\n    this.terms = terms || [];\n    this.coeff = coeff;\n    this.map = map; //careful! all maps are the same object\n    this.sum = new core.Frac(0);\n    this.image = undefined;\n  }\n  ;\n  MVTerm.prototype.updateCount = function () {\n    this.count = this.count || 0;\n    for (var i = 0; i < this.terms.length; i++) {\n      if (!this.terms[i].equals(0)) this.count++;\n    }\n    return this;\n  };\n  MVTerm.prototype.getVars = function () {\n    var vars = [];\n    for (var i = 0; i < this.terms.length; i++) {\n      var term = this.terms[i],\n        rev_map = this.getRevMap();\n      if (!term.equals(0)) vars.push(this.rev_map[i]);\n    }\n    return vars.join(' ');\n  };\n  MVTerm.prototype.len = function () {\n    if (typeof this.count === 'undefined') {\n      this.updateCount();\n    }\n    return this.count;\n  };\n  MVTerm.prototype.toSymbol = function (rev_map) {\n    rev_map = rev_map || this.getRevMap();\n    var symbol = new Symbol(this.coeff);\n    for (var i = 0; i < this.terms.length; i++) {\n      var v = rev_map[i],\n        t = this.terms[i];\n      if (t.equals(0) || v === CONST_HASH) continue;\n      var mapped = new Symbol(v);\n      mapped.power = t;\n      symbol = _.multiply(symbol, mapped);\n    }\n    return symbol;\n  };\n  MVTerm.prototype.getRevMap = function () {\n    if (this.rev_map) return this.rev_map;\n    var o = {};\n    for (var x in this.map) o[this.map[x]] = x;\n    this.rev_map = o;\n    return o;\n  };\n  MVTerm.prototype.generateImage = function () {\n    this.image = this.terms.join(' ');\n    return this;\n  }, MVTerm.prototype.getImg = function () {\n    if (!this.image) this.generateImage();\n    return this.image;\n  }, MVTerm.prototype.fill = function () {\n    var l = this.map.length;\n    for (var i = 0; i < l; i++) {\n      if (typeof this.terms[i] === 'undefined') this.terms[i] = new core.Frac(0);else {\n        this.sum = this.sum.add(this.terms[i]);\n      }\n    }\n    return this;\n  };\n  MVTerm.prototype.divide = function (mvterm) {\n    var c = this.coeff.divide(mvterm.coeff),\n      l = this.terms.length,\n      new_mvterm = new MVTerm(c, [], this.map);\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n    return new_mvterm;\n  };\n  MVTerm.prototype.multiply = function (mvterm) {\n    var c = this.coeff.multiply(mvterm.coeff),\n      l = this.terms.length,\n      new_mvterm = new MVTerm(c, [], this.map);\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n    return new_mvterm;\n  };\n  MVTerm.prototype.isZero = function () {\n    return this.coeff.equals(0);\n  };\n  MVTerm.prototype.toString = function () {\n    return '{ coeff: ' + this.coeff.toString() + ', terms: [' + this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\n  };\n  core.Utils.toMapObj = function (arr) {\n    var c = 0,\n      o = {};\n    for (var i = 0; i < arr.length; i++) {\n      var v = arr[i];\n      if (typeof o[v] === 'undefined') {\n        o[v] = c;\n        c++;\n      }\n    }\n    o.length = c;\n    return o;\n  };\n  core.Utils.filledArray = function (v, n, clss) {\n    var a = [];\n    while (n--) {\n      a[n] = clss ? new clss(v) : v;\n    }\n    return a;\n  };\n  core.Utils.arrSum = function (arr) {\n    var sum = 0,\n      l = arr.length;\n    for (var i = 0; i < l; i++) sum += arr[i];\n    return sum;\n  };\n  /**\r\n   * Determines if 2 arrays have intersecting elements.\r\n   * @param {Array} a\r\n   * @param {Array} b\r\n   * @returns {Boolean} True if a and b have intersecting elements.\r\n   */\n  core.Utils.haveIntersection = function (a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n    return a.some(function (e) {\n      return b.indexOf(e) > -1;\n    });\n  };\n  /**\r\n   * Substitutes out functions as variables so they can be used in regular algorithms\r\n   * @param {Symbol} symbol\r\n   * @param {Object} map\r\n   * @returns {String} The expression string\r\n   */\n  core.Utils.subFunctions = function (symbol, map) {\n    map = map || {};\n    var subbed = [];\n    symbol.each(function (x) {\n      if (x.group === FN || x.previousGroup === FN) {\n        //we need a new variable name so why not use one of the existing\n        var val = core.Utils.text(x, 'hash'),\n          tvar = map[val];\n        if (!tvar) {\n          //generate a unique enough name\n          var t = x.fname + keys(map).length;\n          map[val] = t;\n          subbed.push(x.altVar(t));\n        } else subbed.push(x.altVar(tvar));\n      } else if (x.group === CB || x.group === PL || x.group === CP) {\n        subbed.push(core.Utils.subFunctions(x, map));\n      } else subbed.push(x.text());\n    });\n    if (symbol.group === CP || symbol.group === PL) return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\n    ;\n    if (symbol.group === CB) return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\n    return symbol.text();\n  };\n  core.Utils.getFunctionsSubs = function (map) {\n    var subs = {};\n    //prepare substitutions\n    for (var x in map) subs[map[x]] = _.parse(x);\n    return subs;\n  };\n  var __ = core.Algebra = {\n    version: '1.4.6',\n    proots: function (symbol, decp) {\n      //the roots will be rounded up to 7 decimal places.\n      //if this causes trouble you can explicitly pass in a different number of places\n      //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\n      decp = decp || 7;\n      var zeros = 0;\n      var known_roots = [];\n      var get_roots = function (rarr, powers, max) {\n        var roots = calcroots(rarr, powers, max).concat(known_roots);\n        for (var i = 0; i < zeros; i++) roots.unshift(0);\n        return roots;\n      };\n      if (symbol instanceof Symbol && symbol.isPoly()) {\n        symbol.distributeMultiplier();\n        //make it so the symbol has a constants as the lowest term\n        if (symbol.group === PL) {\n          var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\n          var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\n          symbol = _.expand(_.divide(symbol, lowest_symbol));\n          known_roots.push(0); //add zero since this is a known root\n        }\n        if (symbol.group === core.groups.S) {\n          return [0];\n        } else if (symbol.group === core.groups.PL) {\n          var powers = keys(symbol.symbols),\n            minpower = core.Utils.arrayMin(powers),\n            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\n        }\n        var variable = keys(symbol.symbols).sort().pop(),\n          sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\n          g = sym.group,\n          powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\n          rarr = [],\n          max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\n\n        // Prepare the data\n        for (var i = 1; i <= max; i++) {\n          var c = 0; //if there is no power then the hole must be filled with a zero\n          if (powers.indexOf(i + '') !== -1) {\n            if (g === S) {\n              c = sym.multiplier;\n            } else {\n              c = sym.symbols[i].multiplier;\n            }\n          }\n          // Insert the coeffient but from the front\n          rarr.unshift(c);\n        }\n        rarr.push(symbol.symbols[CONST_HASH].multiplier);\n        if (sym.group === S) rarr[0] = sym.multiplier; //the symbol maybe of group CP with one variable\n\n        return get_roots(rarr, powers, max);\n      } else if (core.Utils.isArray(symbol)) {\n        var parr = symbol;\n        var rarr = [],\n          powers = [],\n          last_power = 0;\n        for (var i = 0; i < parr.length; i++) {\n          var coeff = parr[i][0],\n            pow = parr[i][1],\n            d = pow - last_power - 1;\n          //insert the zeros\n          for (var j = 0; j < d; j++) rarr.unshift(0);\n          rarr.unshift(coeff);\n          if (pow !== 0) powers.push(pow);\n          last_power = pow;\n        }\n        var max = Math.max.apply(undefined, powers);\n        return get_roots(rarr, powers, max);\n      } else {\n        throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\n      }\n      function calcroots(rarr, powers, max) {\n        var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\n\n        // Make a clone of the coefficients before appending the max power\n        var p = rarr.slice(0);\n\n        // Divide the string up into its individual entries, which--presumably--are separated by whitespace\n        rarr.unshift(max);\n        if (max > MAXDEGREE) {\n          throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\n        }\n        var zeroi = [],\n          // Vector of imaginary components of roots\n          degreePar = {}; // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\n        degreePar.Degree = max;\n        for (i = 0; i < max; i++) {\n          zeroi.push(0);\n        }\n        var zeror = zeroi.slice(0); // Vector of real components of roots\n\n        // Find the roots\n        //--> Begin Jenkins-Traub\n\n        /*\r\n         * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n         */\n        function QuadSD_ak1(NN, u, v, p, q, iPar) {\n          // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\n          // iPar is a dummy variable for passing in the two parameters--a and b--by reference\n          q[0] = iPar.b = p[0];\n          q[1] = iPar.a = -(u * iPar.b) + p[1];\n          for (var i = 2; i < NN; i++) {\n            q[i] = -(u * iPar.a + v * iPar.b) + p[i];\n            iPar.b = iPar.a;\n            iPar.a = q[i];\n          }\n          return;\n        }\n        function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\n          // This routine calculates scalar quantities used to compute the next K polynomial and\n          // new estimates of the quadratic coefficients.\n          // calcSC -\tinteger variable set here indicating how the calculations are normalized\n          // to avoid overflow.\n          // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\n\n          // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\n          var sdPar = new Object(),\n            // TYPE = 3 indicates the quadratic is almost a factor of K\n            dumFlag = 3;\n\n          // Synthetic division of K by the quadratic 1, u, v\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(N, u, v, K, qk, sdPar);\n          iPar.c = sdPar.a;\n          iPar.d = sdPar.b;\n          if (Math.abs(iPar.c) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 1])) {\n            if (Math.abs(iPar.d) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 2])) return dumFlag;\n          }\n          iPar.h = v * b;\n          if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {\n            // TYPE = 2 indicates that all formulas are divided by d\n            dumFlag = 2;\n            iPar.e = a / iPar.d;\n            iPar.f = iPar.c / iPar.d;\n            iPar.g = u * b;\n            iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);\n            iPar.a1 = -a + iPar.f * b;\n            iPar.a7 = iPar.h + (iPar.f + u) * a;\n          } else {\n            // TYPE = 1 indicates that all formulas are divided by c;\n            dumFlag = 1;\n            iPar.e = a / iPar.c;\n            iPar.f = iPar.d / iPar.c;\n            iPar.g = iPar.e * u;\n            iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;\n            iPar.a1 = -(a * (iPar.d / iPar.c)) + b;\n            iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;\n          }\n          return dumFlag;\n        }\n        function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\n          // Computes the next K polynomials using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\n          var temp;\n          if (tFlag == 3) {\n            // Use unscaled form of the recurrence\n            K[1] = K[0] = 0.0;\n            for (var i = 2; i < N; i++) {\n              K[i] = qk[i - 2];\n            }\n            return;\n          }\n          temp = tFlag == 1 ? b : a;\n          if (Math.abs(iPar.a1) > 10.0 * DBL_EPSILON * Math.abs(temp)) {\n            // Use scaled form of the recurrence\n            iPar.a7 /= iPar.a1;\n            iPar.a3 /= iPar.a1;\n            K[0] = qp[0];\n            K[1] = -(qp[0] * iPar.a7) + qp[1];\n            for (var i = 2; i < N; i++) K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\n          } else {\n            // If a1 is nearly zero, then use a special form of the recurrence\n            K[0] = 0.0;\n            K[1] = -(qp[0] * iPar.a7);\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\n            }\n          }\n          return;\n        }\n        function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\n          // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\n          // iPar.a = uu, iPar.b = vv\n\n          var a4, a5, b1, b2, c1, c2, c3, c4, temp;\n          iPar.b = iPar.a = 0.0; // The quadratic is zeroed\n\n          if (tFlag != 3) {\n            if (tFlag != 2) {\n              a4 = a + u * b + h * f;\n              a5 = c + (u + v * f) * d;\n            } else {\n              a4 = (a + g) * f + h;\n              a5 = (f + u) * c + v * d;\n            }\n\n            // Evaluate new quadratic coefficients\n            b1 = -(K[N - 1] / p[N]);\n            b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\n            c1 = v * b2 * a1;\n            c2 = b1 * a7;\n            c3 = b1 * b1 * a3;\n            c4 = -(c2 + c3) + c1;\n            temp = -c4 + a5 + b1 * a4;\n            if (temp != 0.0) {\n              iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\n              iPar.b = v * (1.0 + c4 / temp);\n            }\n          }\n          return;\n        }\n        function Quad_ak1(a, b1, c, iPar) {\n          // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\n          // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\n          // zeros are real and both zeros are complex. The smaller real zero is found directly from\n          // the product of the zeros c/a.\n\n          // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\n\n          var b, d, e;\n          iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\n          if (a == 0) {\n            iPar.sr = b1 != 0 ? -(c / b1) : iPar.sr;\n            return;\n          }\n          if (c == 0) {\n            iPar.lr = -(b1 / a);\n            return;\n          }\n\n          // Compute discriminant avoiding overflow\n          b = b1 / 2.0;\n          if (Math.abs(b) < Math.abs(c)) {\n            e = c >= 0 ? a : -a;\n            e = -e + b * (b / Math.abs(c));\n            d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\n          } else {\n            e = -(a / b * (c / b)) + 1.0;\n            d = Math.sqrt(Math.abs(e)) * Math.abs(b);\n          }\n          if (e >= 0) {\n            // Real zeros\n            d = b >= 0 ? -d : d;\n            iPar.lr = (-b + d) / a;\n            iPar.sr = iPar.lr != 0 ? c / iPar.lr / a : iPar.sr;\n          } else {\n            // Complex conjugate zeros\n            iPar.lr = iPar.sr = -(b / a);\n            iPar.si = Math.abs(d / a);\n            iPar.li = -iPar.si;\n          }\n          return;\n        }\n        function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\n          // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\n          // zeros are equimodular or nearly so.\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\n          // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\n\n          // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\n          var qPar = new Object(),\n            ee,\n            mp,\n            omp,\n            relstp,\n            t,\n            u,\n            ui,\n            v,\n            vi,\n            zm,\n            i,\n            j = 0,\n            tFlag,\n            triedFlag = 0; // Integer variables\n\n          iPar.NZ = 0; // Number of zeros found\n          u = uu; // uu and vv are coefficients of the starting quadratic\n          v = vv;\n          do {\n            qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n            Quad_ak1(1.0, u, v, qPar);\n            iPar.szr = qPar.sr;\n            iPar.szi = qPar.si;\n            iPar.lzr = qPar.lr;\n            iPar.lzi = qPar.li;\n\n            // Return if roots of the quadratic are real and not close to multiple or nearly\n            // equal and of opposite sign.\n            if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr)) break;\n\n            // Evaluate polynomial by quadratic synthetic division\n\n            QuadSD_ak1(NN, u, v, p, qp, sdPar);\n            mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b);\n\n            // Compute a rigorous bound on the rounding error in evaluating p\n\n            zm = Math.sqrt(Math.abs(v));\n            ee = 2.0 * Math.abs(qp[0]);\n            t = -(iPar.szr * sdPar.b);\n            for (i = 1; i < N; i++) {\n              ee = ee * zm + Math.abs(qp[i]);\n            }\n            ee = ee * zm + Math.abs(t + sdPar.a);\n            ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON;\n\n            // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\n            if (mp <= 20.0 * ee) {\n              iPar.NZ = 2;\n              break;\n            }\n            j++;\n            // Stop iteration after 20 steps\n            if (j > 20) break;\n            if (j >= 2) {\n              if (relstp <= 0.01 && mp >= omp && !triedFlag) {\n                // A cluster appears to be stalling the convergence. Five fixed shift\n                // steps are taken with a u, v close to the cluster.\n                relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);\n                u -= u * relstp;\n                v += v * relstp;\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                for (i = 0; i < 5; i++) {\n                  tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                  nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                }\n                triedFlag = 1;\n                j = 0;\n              }\n            }\n            omp = mp;\n\n            // Calculate next K polynomial and new u and v\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vi = sdPar.b;\n\n            // If vi is zero, the iteration is not converging\n            if (vi != 0) {\n              relstp = Math.abs((-v + vi) / vi);\n              u = ui;\n              v = vi;\n            }\n          } while (vi != 0);\n          return;\n        }\n        function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\n          // Variable-shift H-polynomial iteration for a real zero\n          // sss\t- starting iterate = sdPar.a\n          // NZ\t\t- number of zeros found = iPar.NZ\n          // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\n\n          var ee,\n            kv,\n            mp,\n            ms,\n            omp,\n            pv,\n            s,\n            t,\n            dumFlag,\n            i,\n            j,\n            nm1 = N - 1; // Integer variables\n\n          iPar.NZ = j = dumFlag = 0;\n          s = sdPar.a;\n          for (;;) {\n            pv = p[0];\n\n            // Evaluate p at s\n            qp[0] = pv;\n            for (i = 1; i < NN; i++) {\n              qp[i] = pv = pv * s + p[i];\n            }\n            mp = Math.abs(pv);\n\n            // Compute a rigorous bound on the error in evaluating p\n            ms = Math.abs(s);\n            ee = 0.5 * Math.abs(qp[0]);\n            for (i = 1; i < NN; i++) {\n              ee = ee * ms + Math.abs(qp[i]);\n            }\n\n            // Iteration has converged sufficiently if the polynomial value is less than\n            // 20 times this bound\n            if (mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\n              iPar.NZ = 1;\n              iPar.szr = s;\n              iPar.szi = 0.0;\n              break;\n            }\n            j++;\n            // Stop iteration after 10 steps\n            if (j > 10) break;\n            if (j >= 2) {\n              if (Math.abs(t) <= 0.001 * Math.abs(-t + s) && mp > omp) {\n                // A cluster of zeros near the real axis has been encountered.\n                // Return with iFlag set to initiate a quadratic iteration.\n                dumFlag = 1;\n                iPar.a = s;\n                break;\n              } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\n            } //End if (j >= 2)\n\n            // Return if the polynomial value has increased significantly\n            omp = mp;\n\n            // Compute t, the next polynomial and the new iterate\n            qk[0] = kv = K[0];\n            for (i = 1; i < N; i++) {\n              qk[i] = kv = kv * s + K[i];\n            }\n            if (Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\n              // Use the scaled form of the recurrence if the value of K at s is non-zero\n              t = -(pv / kv);\n              K[0] = qp[0];\n              for (i = 1; i < N; i++) {\n                K[i] = t * qk[i - 1] + qp[i];\n              }\n            } else {\n              // Use unscaled form\n              K[0] = 0.0;\n              for (i = 1; i < N; i++) K[i] = qk[i - 1];\n            }\n            kv = K[0];\n            for (i = 1; i < N; i++) {\n              kv = kv * s + K[i];\n            }\n            t = Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON ? -(pv / kv) : 0.0;\n            s += t;\n          }\n          return dumFlag;\n        }\n        function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\n          // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\n          // quadratic case. Initiates one of the variable shift iterations and returns with the\n          // number of zeros found.\n          // L2\tlimit of fixed shift steps\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // NZ\tnumber of zeros found\n          var sdPar = new Object(),\n            // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\n            calcPar = new Object(),\n            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\n\n            qk = new Array(MDP1),\n            svk = new Array(MDP1),\n            a,\n            b,\n            betas,\n            betav,\n            oss,\n            ots,\n            otv,\n            ovv,\n            s,\n            ss,\n            ts,\n            tss,\n            tv,\n            tvv,\n            ui,\n            vi,\n            vv,\n            fflag,\n            i,\n            iFlag = 1,\n            j,\n            spass,\n            stry,\n            tFlag,\n            vpass,\n            vtry; // Integer variables\n\n          iPar.NZ = 0;\n          betav = betas = 0.25;\n          oss = sr;\n          ovv = v;\n\n          //Evaluate polynomial by synthetic division\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(NN, u, v, p, qp, sdPar);\n          a = sdPar.a;\n          b = sdPar.b;\n          calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\n          tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n          for (j = 0; j < L2; j++) {\n            fflag = 1;\n\n            // Calculate next K polynomial and estimate v\n            nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n            // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\n            // sdPar.a = ui, sdPar.b = vi\n            newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vv = vi = sdPar.b;\n\n            // Estimate s\n            ss = K[N - 1] != 0.0 ? -(p[N] / K[N - 1]) : 0.0;\n            ts = tv = 1.0;\n            if (j != 0 && tFlag != 3) {\n              // Compute relative measures of convergence of s and v sequences\n              tv = vv != 0.0 ? Math.abs((vv - ovv) / vv) : tv;\n              ts = ss != 0.0 ? Math.abs((ss - oss) / ss) : ts;\n\n              // If decreasing, multiply the two most recent convergence measures\n              tvv = tv < otv ? tv * otv : 1.0;\n              tss = ts < ots ? ts * ots : 1.0;\n\n              // Compare with convergence criteria\n              vpass = tvv < betav ? 1 : 0;\n              spass = tss < betas ? 1 : 0;\n              if (spass || vpass) {\n                // At least one sequence has passed the convergence test.\n                // Store variables before iterating\n\n                for (i = 0; i < N; i++) {\n                  svk[i] = K[i];\n                }\n                s = ss;\n\n                // Choose iteration according to the fastest converging sequence\n\n                stry = vtry = 0;\n                for (;;) {\n                  if (fflag && (fflag = 0) == 0 && spass && (!vpass || tss < tvv)) {\n                    ; // Do nothing. Provides a quick \"short circuit\".\n                  } else {\n                    QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\n                    a = sdPar.a;\n                    b = sdPar.b;\n                    if (iPar.NZ > 0) return;\n\n                    // Quadratic iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n                    iFlag = vtry = 1;\n                    betav *= 0.25;\n\n                    // Try linear iteration if it has not been tried and the s sequence is converging\n                    if (stry || !spass) {\n                      iFlag = 0;\n                    } else {\n                      for (i = 0; i < N; i++) K[i] = svk[i];\n                    }\n                  }\n                  //fflag = 0;\n                  if (iFlag != 0) {\n                    // Use sdPar for passing in s instead of defining a brand-new variable.\n                    // sdPar.a = s\n                    sdPar.a = s;\n                    iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\n                    s = sdPar.a;\n                    if (iPar.NZ > 0) return;\n\n                    // Linear iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n                    stry = 1;\n                    betas *= 0.25;\n                    if (iFlag != 0) {\n                      // If linear iteration signals an almost double real zero, attempt quadratic iteration\n                      ui = -(s + s);\n                      vi = s * s;\n                      continue;\n                    }\n                  }\n\n                  // Restore variables\n                  for (i = 0; i < N; i++) K[i] = svk[i];\n\n                  // Try quadratic iteration if it has not been tried and the v sequence is converging\n                  if (!vpass || vtry) break; // Break out of infinite for loop\n                }\n\n                // Re-compute qp and scalar values to continue the second stage\n\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                a = sdPar.a;\n                b = sdPar.b;\n                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n              }\n            }\n            ovv = vv;\n            oss = ss;\n            otv = tv;\n            ots = ts;\n          }\n          return;\n        }\n        function rpSolve(degPar, p, zeror, zeroi) {\n          var N = degPar.Degree,\n            RADFAC = 3.14159265358979323846 / 180,\n            // Degrees-to-radians conversion factor = PI/180\n            LB2 = Math.LN2,\n            // Dummy variable to avoid re-calculating this value in loop below\n            MDP1 = degPar.Degree + 1,\n            K = new Array(MDP1),\n            pt = new Array(MDP1),\n            qp = new Array(MDP1),\n            temp = new Array(MDP1),\n            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\n            qPar = new Object(),\n            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\n            Fxshfr_Par = new Object(),\n            bnd,\n            DBL_EPSILON,\n            df,\n            dx,\n            factor,\n            ff,\n            moduli_max,\n            moduli_min,\n            sc,\n            x,\n            xm,\n            aa,\n            bb,\n            cc,\n            sr,\n            t,\n            u,\n            xxx,\n            j,\n            jj,\n            l,\n            NM1,\n            NN,\n            zerok; // Integer variables\n\n          // Calculate the machine epsilon and store in the variable DBL_EPSILON.\n          // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\n          aa = 1.0;\n          do {\n            DBL_EPSILON = aa;\n            aa /= 2;\n            bb = 1.0 + aa;\n          } while (bb > 1.0);\n          var LO = Number.MIN_VALUE / DBL_EPSILON,\n            cosr = Math.cos(94.0 * RADFAC),\n            // = -0.069756474\n            sinr = Math.sin(94.0 * RADFAC),\n            // = 0.99756405\n            xx = Math.sqrt(0.5),\n            // = 0.70710678\n            yy = -xx;\n          Fxshfr_Par.NZ = j = 0;\n          Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\n\n          // Remove zeros at the origin, if any\n          while (p[N] == 0) {\n            zeror[j] = zeroi[j] = 0;\n            N--;\n            j++;\n          }\n          NN = N + 1;\n\n          // >>>>> Begin Main Loop <<<<<\n          while (N >= 1) {\n            // Main loop\n            // Start the algorithm for one zero\n            if (N <= 2) {\n              // Calculate the final zero or pair of zeros\n              if (N < 2) {\n                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\n                zeroi[degPar.Degree - 1] = 0;\n              } else {\n                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n                Quad_ak1(p[0], p[1], p[2], qPar);\n                zeror[degPar.Degree - 2] = qPar.sr;\n                zeroi[degPar.Degree - 2] = qPar.si;\n                zeror[degPar.Degree - 1] = qPar.lr;\n                zeroi[degPar.Degree - 1] = qPar.li;\n              }\n              break;\n            }\n\n            // Find the largest and smallest moduli of the coefficients\n            moduli_max = 0.0;\n            moduli_min = Number.MAX_VALUE;\n            for (i = 0; i < NN; i++) {\n              x = Math.abs(p[i]);\n              if (x > moduli_max) moduli_max = x;\n              if (x != 0 && x < moduli_min) moduli_min = x;\n            }\n\n            // Scale if there are large or very small coefficients\n            // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\n            // is done to avoid overflow and to avoid undetected underflow interfering with the\n            // convergence criterion.\n            // The factor is a power of the base.\n            sc = LO / moduli_min;\n            if (sc <= 1.0 && moduli_max >= 10 || sc > 1.0 && Number.MAX_VALUE / sc >= moduli_max) {\n              sc = sc == 0 ? Number.MIN_VALUE : sc;\n              l = Math.floor(Math.log(sc) / LB2 + 0.5);\n              factor = Math.pow(2.0, l);\n              if (factor != 1.0) {\n                for (i = 0; i < NN; i++) p[i] *= factor;\n              }\n            }\n\n            // Compute lower bound on moduli of zeros\n            for (var i = 0; i < NN; i++) pt[i] = Math.abs(p[i]);\n            pt[N] = -pt[N];\n            NM1 = N - 1;\n\n            // Compute upper estimate of bound\n            x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\n            if (pt[NM1] != 0) {\n              // If Newton step at the origin is better, use it\n              xm = -pt[N] / pt[NM1];\n              x = xm < x ? xm : x;\n            }\n\n            // Chop the interval (0, x) until ff <= 0\n            xm = x;\n            do {\n              x = xm;\n              xm = 0.1 * x;\n              ff = pt[0];\n              for (var i = 1; i < NN; i++) {\n                ff = ff * xm + pt[i];\n              }\n            } while (ff > 0); // End do-while loop\n\n            dx = x;\n            // Do Newton iteration until x converges to two decimal places\n\n            do {\n              df = ff = pt[0];\n              for (var i = 1; i < N; i++) {\n                ff = x * ff + pt[i];\n                df = x * df + ff;\n              } // End for i\n              ff = x * ff + pt[N];\n              dx = ff / df;\n              x -= dx;\n            } while (Math.abs(dx / x) > 0.005); // End do-while loop\n\n            bnd = x;\n\n            // Compute the derivative as the initial K polynomial and do 5 steps with no shift\n            for (var i = 1; i < N; i++) K[i] = (N - i) * p[i] / N;\n            K[0] = p[0];\n            aa = p[N];\n            bb = p[NM1];\n            zerok = K[NM1] == 0 ? 1 : 0;\n            for (jj = 0; jj < 5; jj++) {\n              cc = K[NM1];\n              if (zerok) {\n                // Use unscaled form of recurrence\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = K[j - 1];\n                } // End for i\n                K[0] = 0;\n                zerok = K[NM1] == 0 ? 1 : 0;\n              } else {\n                // Used scaled form of recurrence if value of K at 0 is nonzero\n                t = -aa / cc;\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = t * K[j - 1] + p[j];\n                } // End for i\n                K[0] = p[0];\n                zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0 ? 1 : 0;\n              }\n            }\n\n            // Save K for restarts with new shifts\n            for (var i = 0; i < N; i++) temp[i] = K[i];\n\n            // Loop to select the quadratic corresponding to each new shift\n            for (jj = 1; jj <= 20; jj++) {\n              // Quadratic corresponds to a double shift to a non-real point and its\n              // complex conjugate. The point has modulus BND and amplitude rotated\n              // by 94 degrees from the previous shift.\n\n              xxx = -(sinr * yy) + cosr * xx;\n              yy = sinr * xx + cosr * yy;\n              xx = xxx;\n              sr = bnd * xx;\n              u = -(2.0 * sr);\n\n              // Second stage calculation, fixed quadratic\n              Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\n              if (Fxshfr_Par.NZ != 0) {\n                // The second stage jumps directly to one of the third stage iterations and\n                // returns here if successful. Deflate the polynomial, store the zero or\n                // zeros, and return to the main algorithm.\n                j = degPar.Degree - N;\n                zeror[j] = Fxshfr_Par.szr;\n                zeroi[j] = Fxshfr_Par.szi;\n                NN = NN - Fxshfr_Par.NZ;\n                N = NN - 1;\n                for (var i = 0; i < NN; i++) p[i] = qp[i];\n                if (Fxshfr_Par.NZ != 1) {\n                  zeror[j + 1] = Fxshfr_Par.lzr;\n                  zeroi[j + 1] = Fxshfr_Par.lzi;\n                }\n                break;\n              } else {\n                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\n                for (var i = 0; i < N; i++) {\n                  K[i] = temp[i];\n                }\n              }\n            }\n            // Return with failure if no convergence with 20 shifts\n            if (jj > 20) {\n              degPar.Degree -= N;\n              break;\n            }\n          }\n          // >>>>> End Main Loop <<<<<\n          return;\n        }\n        //--> End Jenkins-Traub\n        rpSolve(degreePar, p, zeror, zeroi);\n        var l = zeroi.length;\n        //format the output\n        for (i = 0; i < l; i++) {\n          // We round the imaginary part to avoid having something crazy like 5.67e-16.\n          var img = round(zeroi[i], decp + 8),\n            real = round(zeror[i], decp + 8);\n          // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\n          // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \n          // the original otherwise the rounding was worth it.\n          real = decp - String(real).length > 2 ? real : zeror[i];\n          var sign = img < 0 ? '-' : '';\n\n          // Remove the zeroes\n          if (real === 0) {\n            real = '';\n          }\n          if (img === 0) {\n            img = '';\n          }\n\n          // Remove 1 as the multiplier and discard imaginary part if there isn't one.\n          img = Math.abs(img) === 1 ? sign + 'i' : img ? img + '*i' : '';\n          var num = real && img ? real + '+' + img : real + img;\n          zeror[i] = num.replace(/\\+\\-/g, '-');\n        }\n        return zeror;\n      }\n    },\n    roots: function (symbol) {\n      if (symbol.isConstant(true, true)) {\n        return core.Utils.nroots(symbol);\n      }\n      var roots = __.proots(symbol).map(function (x) {\n        return _.parse(x);\n      });\n      return core.Vector.fromArray(roots);\n    },\n    froot: function (f, guess, dx) {\n      var newtonraph = function (xn) {\n        var mesh = 1e-12,\n          // If the derivative was already provided then don't recalculate.\n          df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\n          // If the function was passed in as a function then don't recalculate.\n          fn = f instanceof Function ? f : core.Utils.build(f),\n          max = 10000,\n          done = false,\n          safety = 0;\n        while (!done) {\n          var x = xn - fn(xn) / df(xn);\n          //absolute values for both x & xn ensures that we indeed have the radius    \n          var r = Math.abs(x) - Math.abs(xn),\n            delta = Math.abs(r);\n          xn = x;\n          if (delta < mesh) done = true;else if (safety > max) {\n            xn = null;\n            done = true;\n          }\n          safety++;\n        }\n        return xn;\n      };\n      return newtonraph(Number(guess));\n    },\n    quad: function (a, b, c) {\n      var q = function (a, b, c, sign) {\n        return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\n      };\n      return [q(a, b, c, 1), q(a, b, c, -1)];\n    },\n    sumProd: function (a, b) {\n      return __.quad(-b, a, -1).map(function (x) {\n        return x.invert();\n      });\n    },\n    coeffs: function (symbol, wrt, coeffs) {\n      wrt = String(wrt);\n      symbol = _.expand(symbol);\n      coeffs = coeffs || [new Symbol(0)];\n      //we cannot get coeffs for group EX\n      if (symbol.group === EX && symbol.contains(wrt, true)) _.error('Unable to get coefficients using expression ' + symbol.toString());\n      var vars = variables(symbol);\n      if (vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\n        var a = new Polynomial(symbol).coeffs.map(function (x) {\n          return new Symbol(x);\n        });\n        for (var i = 0, l = a.length; i < l; i++) {\n          var coeff = a[i],\n            e = coeffs[i];\n          if (e) coeff = _.add(e, coeff);\n          coeffs[i] = coeff; //transfer it all over\n        }\n      } else {\n        if (!wrt) _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\n        //if the variable isn't part of this polynomial then we're looking at x^0\n\n        if (vars.indexOf(wrt) === -1) {\n          coeffs[0] = _.add(symbol, coeffs[0]);\n        } else {\n          coeffs = coeffs || [new Symbol(0)];\n          if (symbol.group === CB) {\n            var s = symbol.symbols[wrt];\n            if (!s) _.error('Expression is not a polynomial!');\n            var p = Number(s.power);\n            coeff = _.divide(symbol.clone(), s.clone());\n            if (coeff.contains(wrt, true) || p < 0 || !isInt(p)) _.error('Expression is not a polynomial!');\n            var e = coeffs[p];\n            if (e) coeff = _.add(e, coeff);\n            coeffs[p] = coeff;\n          } else if (symbol.group === CP) {\n            symbol.each(function (x) {\n              __.coeffs(x.clone(), wrt, coeffs);\n            }, true);\n          }\n        }\n      }\n      //fill holes\n      for (var i = 0, l = coeffs.length; i < l; i++) if (typeof coeffs[i] === 'undefined') coeffs[i] = new Symbol(0);\n      return coeffs;\n    },\n    /**\r\n     * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n     * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n     * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n     * @param {Symbol} e\r\n     * @param {String} for_variable\r\n     * @param {Array} powers\r\n     * @returns {Array} An array of the powers\r\n     */\n    //assumes you've already verified that it's a polynomial\n    polyPowers: function (e, for_variable, powers) {\n      powers = powers || [];\n      var g = g = e.group;\n      if (g === PL && for_variable === e.value) {\n        powers = powers.concat(keys(e.symbols));\n      } else if (g === CP) {\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s];\n          var g = symbol.group,\n            v = symbol.value;\n          if (g === S && for_variable === v) powers.push(symbol.power);else if (g === PL || g === CP) powers = __.polyPowers(symbol, for_variable, powers);else if (g === CB && symbol.contains(for_variable)) {\n            var t = symbol.symbols[for_variable];\n            if (t) powers.push(t.power);\n          } else if (g === N || for_variable !== v) powers.push(0);\n        }\n      } else if (g === CB && e.contains(for_variable)) {\n        powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\n      }\n      return core.Utils.arrayUnique(powers).sort();\n    },\n    //The factor object\n    Factor: {\n      //splits the symbol in symbol and constant\n      split: function (symbol) {\n        var c = new Symbol(1); //the constants part\n        var s = new Symbol(1); //the symbolic part\n        __.Factor.factor(symbol, new Factors()).each(function (x) {\n          var t = _.parse(x);\n          if (x.isConstant(true)) {\n            c = _.multiply(c, t);\n          } else {\n            s = _.multiply(s, t);\n          }\n        });\n        return [c, s];\n      },\n      mix: function (o, include_negatives) {\n        var factors = keys(o);\n        var l = factors.length;\n        var m = []; //create a row which we'r going to be mixing\n        for (var i = 0; i < l; i++) {\n          var factor = factors[i],\n            p = o[factor];\n          var ll = m.length;\n          for (var j = 0; j < ll; j++) {\n            var t = m[j] * factor;\n            m.push(t);\n            if (include_negatives) m.push(-t);\n          }\n          for (var j = 1; j <= p; j++) m.push(Math.pow(factor, j));\n        }\n        return m;\n      },\n      //TODO: this method is to replace common factoring\n      common: function (symbol, factors) {\n        try {\n          if (symbol.group === CP) {\n            //this may have the unfortunate side effect of expanding and factoring again\n            //to only end up with the same result. \n            //TODO: try to avoid this\n            //collect the symbols and sort to have the longest first. Thinking is that the longest terms \n            //has to contain the variable in order for it to be factorable\n            var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\n              return (b.length || 1) - (a.length || 1);\n            });\n            var map = {}; //create a map of common factors\n            var coeffs = [];\n            for (var i = 0; i < symbols.length; i++) {\n              var sym = symbols[i];\n              coeffs.push(sym.multiplier.clone());\n              sym.each(function (x) {\n                var p = Number(x.power);\n                //This check exits since we have a symbolic power.\n                //For the future... think about removing this check and modify for symbolic powers\n                if (isNaN(p)) throw new Error('exiting');\n                //loop through the symbols and lump together common terms\n                if (x.value in map) {\n                  if (p < map[x.value][0]) map[x.value][0] = p;\n                  map[x.value][1].push(x);\n                } else map[x.value] = [p, [x]];\n              });\n            }\n            //the factor\n            var factor = new Symbol(1);\n            for (var x in map) {\n              //if this factor is found in all terms since the length of \n              //matching variable terms matches the number of original terms\n              if (map[x][1].length === symbols.length) {\n                //generate a symbol and multiply into the factor\n                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\n              }\n            }\n            //get coefficient factor\n            var c = core.Math2.QGCD.apply(null, coeffs);\n            if (!c.equals(1)) {\n              factors.add(new Symbol(c));\n              for (var i = 0; i < symbols.length; i++) {\n                symbols[i].multiplier = symbols[i].multiplier.divide(c);\n              }\n            }\n\n            //if we actuall found any factors\n            if (!factor.equals(1)) {\n              factors.add(factor);\n              symbol = new Symbol(0);\n              for (var i = 0; i < symbols.length; i++) {\n                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n        return symbol;\n      },\n      zeroes: function (symbol, factors) {\n        var exit = function () {\n          throw new core.exceptions.ValueLimitExceededError('Exiting');\n        };\n        try {\n          var vars, term, sum, p, e;\n          symbol = _.expand(symbol.clone());\n          e = symbol.toString();\n          vars = variables(symbol);\n          sum = new Symbol(0);\n          var terms = [];\n          var powers = [];\n\n          //start setting each variable to zero\n          for (var i = 0, l = vars.length; i < vars.length; i++) {\n            var subs = {};\n            //we want to create a subs object with all but the current variable set to zero\n            for (var j = 0; j < l; j++) if (i !== j)\n              //make sure we're not looking at the same variable\n              subs[vars[j]] = 0;\n            term = _.parse(e, subs);\n            var tp = term.power;\n            //the temporary power has to be an integer as well\n            if (!isInt(tp)) exit();\n            terms.push(term);\n            powers.push(term.power);\n          }\n\n          //get the gcd. This will be the p in (a^n+b^m)^p\n          //if the gcd equals 1 meaning n = m then we need a tie breakder\n          if (core.Utils.allSame(powers)) {\n            //get p given x number of terms\n            var n_terms = symbol.length;\n            //the number of zeroes determines\n            var n_zeroes = terms.length;\n            if (n_zeroes === 2) {\n              p = new Frac(powers[0] / (n_terms - 1));\n            }\n            if (n_zeroes === 3) {\n              p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\n            }\n            /*\r\n             //get the lowest possible power\r\n             //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n             symbol.each(function(x) {\r\n             if(x.group === CB)\r\n             x.each(function(y) {\r\n             if(!p || y.power.lessThan(p))\r\n             //p = Number(y.power);\r\n             p = y.power;\r\n             });\r\n             else if(!p || x.power.lessThan(p))\r\n             //p = Number(x.power);\r\n             p = x.power;\r\n             });\r\n             */\n          } else\n            //p is just the gcd of the powers\n            p = core.Math2.QGCD.apply(null, powers);\n\n          //if we don't have an integer then exit\n          if (!isInt(p)) exit();\n\n          //build the factor\n          for (var i = 0; i < terms.length; i++) {\n            var t = terms[i];\n            var n = t.power.clone().divide(p);\n            t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\n            t.power = p.clone();\n            sum = _.add(sum, t);\n          }\n\n          //by now we have the factor of zeroes. We'll know if we got it right because \n          //we'll get a remainder of zero each time we divide by it\n          if (sum.group !== CP) return symbol; //nothing to do\n\n          while (true) {\n            var d = __.div(symbol.clone(), sum.clone());\n            if (d[1].equals(0)) {\n              symbol = d[0];\n              factors.add(sum.clone());\n              if (symbol.equals(1))\n                //we've reached 1 so done.\n                break;\n            } else break;\n          }\n        } catch (e) {}\n        ;\n        return symbol;\n      },\n      factor: function (symbol, factors) {\n        // Don't try to factor constants\n        if (symbol.isConstant()) {\n          return core.Math2.factor(symbol);\n        }\n        var _symbol = _.parse(symbol);\n        var retval = __.Factor._factor(_symbol, factors);\n        if (retval.equals(symbol)) {\n          return retval;\n        }\n        if (retval.group === CB) {\n          var t = new Symbol(1);\n          var p = _.parse(retval.power);\n          //store the multiplier and strip it\n          var m = _.parse(retval.multiplier);\n          retval.toUnitMultiplier();\n\n          /* \r\n           * NOTE: for sign issues with factor START DEBUGGING HERE\r\n           */\n          //move the sign to t\n          if (retval.multiplier.lessThan(0)) {\n            t.negate();\n            retval.negate();\n          }\n          retval.each(function (x) {\n            // Related to #566. Since the symbol's group may not have been properly\n            // updated, it's easier to just parse the symbol and have the parser \n            // do the update for us.\n            var factored = _.parse(__.Factor._factor(x));\n            if (factored.group === CB) {\n              // Include the multiplier\n              m = _.multiply(m, Symbol.create(factored.multiplier));\n              factored.each(function (y) {\n                var _factored = _.parse(__.Factor._factor(y));\n                t = _.multiply(t, _factored);\n                if (_factored.group === CB) {\n                  m = _.multiply(m, Symbol.create(_factored.multiplier));\n                }\n              });\n            } else {\n              t = _.multiply(t, factored);\n            }\n          });\n\n          //put back the multiplier and power\n          retval = _.pow(_.multiply(m, t), p);\n        }\n        return retval;\n      },\n      quadFactor: function (symbol, factors) {\n        if (symbol.isPoly() && __.degree(symbol.equals(2))) {\n          //We've  already checked that we're dealing with a polynomial\n          var v = core.Utils.variables(symbol)[0]; //get the variable\n          var coeffs = __.coeffs(symbol, v);\n          //factor the lead coefficient\n          var cf = __.Factor._factor(coeffs[2].clone());\n          //check if we have factors\n          if (cf.group === CB) {\n            var symbols = cf.collectSymbols();\n            //if the factors are greater than 2 we're done so exit\n            if (symbols.length > 2) return symbol;\n            //if we have two factors then attempt to factor the polynomial\n            //let the factors be f1 and f1\n            //let the factors be (ax+b)(cx+d)\n            //let the coefficients be c1x^2+c2x+c3\n            //then a(x1)+c(x2)=c2 and x1*x2=c3\n            //we can solve for x1 and x2\n            var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\n            var b = _.parse(coeffs[1]).negate();\n            var a = _.parse(symbols[1]);\n            //solve the system\n            var root = __.quad(a, b, c).filter(function (x) {\n              if (core.Utils.isInt(x)) return x;\n            });\n            //if we have one root then find the other one by dividing the constant\n            if (root.length === 1) {\n              var root1 = root[0];\n              var root2 = _.divide(coeffs[0], _.parse(root1));\n              if (core.Utils.isInt(root2)) {\n                //we found them both\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        }\n        return symbol;\n      },\n      cubeFactor: function (symbol, factors) {\n        if (symbol.isComposite()) {\n          var symbols = symbol.collectSymbols();\n          // The symbol should be in the form of a^3+-b^3. The length\n          // should therefore only be two. If it's any different from this\n          // then we're done\n          if (symbols.length === 2) {\n            // Store the signs and then strip them from the symbols\n            var sign_a = symbols[0].sign();\n            var a = symbols[0].clone().abs();\n            var sign_b = symbols[1].sign();\n            var b = symbols[1].clone().abs();\n            // Check if they're cube\n            if (a.isCube() && b.isCube()) {\n              // Keep the negative sign on the right, meaning b is always negative.\n              if (sign_a < sign_b) {\n                // Swap the signs and then the values\n                [sign_a, sign_b] = [sign_b, sign_a];\n                [a, b] = [b, a];\n              }\n\n              // Get teh roots\n              var m_root_a = _.parse(a.getNth(3));\n              var m_root_b = _.parse(b.getNth(3));\n\n              // Remove the cube for both\n              var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\n              var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\n              if (sign_a === 1 && sign_b === -1) {\n                // Apply difference of cubes rule\n                factors.add(_.parse(format('(({0})-({1}))', x, y)));\n                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\n                symbol = Symbol(1);\n              } else if (sign_a === 1 && sign_b === 1) {\n                // Apply sum of cubes rule\n                factors.add(_.parse(format('(({0})+({1}))', x, y)));\n                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\n                symbol = Symbol(1);\n              }\n            }\n          }\n        }\n        return symbol;\n      },\n      _factor: function (symbol, factors) {\n        var g = symbol.group;\n        //some items cannot be factored any further so return those right away\n        if (symbol.group === FN) {\n          var arg = symbol.args[0];\n          if (arg.group === S && arg.isSimple()) {\n            return symbol;\n          }\n        } else if (symbol.group === S && symbol.isSimple()) {\n          return symbol;\n        }\n\n        // Expand the symbol to get it in a predictable form. If this step\n        // is skipped some factors are missed.\n        //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\n        if (symbol.group === CP) {\n          symbol.distributeMultiplier(true);\n          var t = new Symbol(0);\n          symbol.each(function (x) {\n            if (x.group === CP && x.power.greaterThan(1) || x.group === CB) x = _.expand(x);\n            t = _.add(t, x);\n          });\n          t.power = symbol.power;\n          symbol = t;\n        }\n        if (symbol.group === FN && symbol.fname !== 'sqrt') {\n          symbol = core.Utils.evaluate(symbol);\n        }\n\n        //make a copy of the symbol to return if something goes wrong\n        var untouched = symbol.clone();\n        try {\n          if (symbol.group === CB) {\n            var p = _.parse(symbol.power);\n            var den_array, num_array, den, num, dfact, nfact;\n            //grab the denominator and strip the multiplier and power. Store them in an array\n            den_array = __.Simplify.strip(symbol.getDenom());\n            num_array = __.Simplify.strip(symbol.getNum());\n            den = den_array.pop();\n            num = num_array.pop();\n\n            //if the numerator equals the symbol then we've hit the simplest form and then we're done\n            if (num.equals(symbol)) {\n              return symbol;\n            }\n            nfact = __.Factor.factor(num);\n            dfact = __.Factor.factor(den);\n            var n = __.Simplify.unstrip(num_array, nfact);\n            var d = __.Simplify.unstrip(den_array, dfact);\n            var retval = _.divide(n, d);\n            return retval;\n          }\n          if (symbol.group === S) {\n            return symbol; //absolutely nothing to do\n          }\n          if (symbol.isConstant()) {\n            if (symbol.equals(1)) return symbol.clone();\n            var ret = core.Math2.factor(symbol);\n            return ret;\n          }\n          var p = symbol.power.clone();\n          if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\n            var sign = p.sign();\n            symbol.toLinear();\n            factors = factors || new Factors();\n            var map = {};\n            symbol = _.parse(core.Utils.subFunctions(symbol, map));\n            if (keys(map).length > 0) {\n              //it might have functions\n              factors.preAdd = function (factor) {\n                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\n                return ret;\n              };\n            }\n\n            //strip the power\n            if (!symbol.isLinear()) {\n              factors.pFactor = symbol.power.toString();\n              symbol.toLinear();\n            }\n            var vars = variables(symbol);\n            //bypass for imaginary. TODO: find a better solution\n            if (symbol.isImaginary()) {\n              vars.push(core.Settings.IMAGINARY);\n            }\n            var multiVar = vars.length > 1;\n\n            //minor optimization. Seems to cut factor time by half in some cases.\n            if (multiVar) {\n              var all_S = true,\n                all_unit = true;\n              symbol.each(function (x) {\n                if (x.group !== S) all_S = false;\n                if (!x.multiplier.equals(1)) all_unit = false;\n              });\n              if (all_S && all_unit) {\n                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\n              }\n            }\n\n            //factor the coefficients\n            var coeff_factors = new Factors();\n            symbol = __.Factor.coeffFactor(symbol, coeff_factors);\n            coeff_factors.each(function (x) {\n              // If the factor was negative but was within a square then it becomes positive\n              if (even(p) && x.lessThan(0)) {\n                x.negate();\n              }\n              if (sign < 0) x.invert();\n              factors.add(x);\n            });\n\n            //factor the power\n            var power_factors = new Factors();\n            symbol = __.Factor.powerFactor(symbol, power_factors);\n            power_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            });\n            if (!multiVar) {\n              //pass in vars[0] for safety\n              var v = vars[0];\n              symbol = __.Factor.squareFree(symbol, factors, v);\n              var t_factors = new Factors();\n              symbol = __.Factor.trialAndError(symbol, t_factors, v);\n\n              //generate a symbol based off the last factors\n              var tf_symbol = t_factors.toSymbol();\n              //if nothing was factored then return the factors\n              if (tf_symbol.equals(untouched)) {\n                return tf_symbol;\n              }\n              for (var x in t_factors.factors) {\n                //store the current factor in t_factor\n                var t_factor = t_factors.factors[x];\n                factors.add(_.pow(t_factor, _.parse(p)));\n              }\n              //if we still don't have a factor and it's quadratic then let's just do a quad factor\n              if (symbol.equals(untouched)) {\n                symbol = __.Factor.quadFactor(symbol, factors);\n              }\n            } else {\n              // Try sum and difference of cubes\n              symbol = __.Factor.cubeFactor(symbol, factors);\n              symbol = __.Factor.mfactor(symbol, factors);\n\n              //put back the sign of power\n              factors.each(function (x) {\n                if (sign < 0) x.power.negate();\n              });\n            }\n\n            //last minute clean up\n            symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\n            var addPower = factors.length === 1;\n            factors.add(_.pow(symbol, _.parse(p)));\n            var retval = factors.toSymbol();\n\n            // We may have only factored out the symbol itself so we end up with a factor of one \n            // where the power needs to be placed back\n            // e.g. factor((2*y+p)^2). Here we end up having a factor of 1 remaining and a p of 2.\n            if (addPower && symbol.equals(1) && retval.isLinear()) {\n              retval = _.pow(retval, _.parse(p));\n            }\n            return retval;\n          }\n          return symbol;\n        } catch (e) {\n          //no need to stop the show because something went wrong :). Just return the unfactored.\n          return untouched;\n        }\n      },\n      reduce: function (symbol, factors) {\n        if (symbol.group === CP && symbol.length === 2) {\n          var symbols = symbol.collectSymbols().sort(function (a, b) {\n            return b.multiplier - a.multiplier;\n          });\n          if (symbols[0].power.equals(symbols[1].power)) {\n            //x^n-a^n\n            var n = _.parse(symbols[0].power),\n              a = symbols[0].clone().toLinear(),\n              b = symbols[1].clone().toLinear();\n\n            //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\n            factors.add(_.add(a.clone(), b.clone()));\n            //flip the sign\n            b.negate();\n            //turn n into a number\n            var nn = Number(n);\n            //the remainder\n            var result = new Symbol(0);\n            for (var i = 1; i <= nn; i++) {\n              var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\n                bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\n              result = _.add(result, _.multiply(aa, bb));\n            }\n            return result;\n          }\n        }\n        return symbol;\n      },\n      /**\r\n       * Makes Symbol square free\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @@param {String} variable The variable which is being factored \r\n       * @returns {[Symbol, Factor]}\r\n       */\n      squareFree: function (symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n        var poly = new Polynomial(symbol, variable);\n        var sqfr = poly.squareFree();\n        var p = sqfr[2];\n        //if we found a square then the p entry in the array will be non-unit\n        if (p !== 1) {\n          //make sure the remainder doesn't have factors\n          var t = sqfr[1].toSymbol();\n          t.power = t.power.multiply(new Frac(p));\n          //send the factor to be fatored to be sure it's completely factored\n          factors.add(__.Factor.factor(t));\n          var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\n          return retval;\n        }\n        return symbol;\n      },\n      /**\r\n       * Factors the powers such that the lowest power is a constant\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @returns {[Symbol, Factor]}\r\n       */\n      powerFactor: function (symbol, factors) {\n        //only PL need apply\n        if (symbol.group !== PL || symbol.previousGroup === EX) return symbol;\n        var k = keys(symbol.symbols);\n        //we expect only numeric powers so return all else\n        if (!core.Utils.allNumeric(k)) return symbol;\n        var d = core.Utils.arrayMin(k);\n        var retval = new Symbol(0);\n        var q = _.parse(symbol.value + '^' + d);\n        symbol.each(function (x) {\n          x = _.divide(x, q.clone());\n          retval = _.add(retval, x);\n        });\n        factors.add(q);\n        return retval;\n      },\n      /**\r\n       * Removes GCD from coefficients\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @returns {Symbol}\r\n       */\n      coeffFactor: function (symbol, factors) {\n        if (symbol.isComposite()) {\n          var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\n          if (!gcd.equals(1)) {\n            symbol.each(function (x) {\n              if (x.isComposite()) {\n                x.each(function (y) {\n                  y.multiplier = y.multiplier.divide(gcd);\n                });\n              } else x.multiplier = x.multiplier.divide(gcd);\n            });\n            symbol.updateHash();\n          } else {\n            // TODO: This should probably go to the prototype\n            var power = function (symbol) {\n              var p;\n              if (symbol.group === CB) {\n                p = 0;\n                symbol.each(function (x) {\n                  p += x.power;\n                });\n              } else {\n                p = Number(symbol.power);\n              }\n              return p;\n            };\n            // Factor out negatives from the lead term\n            var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\n              // Push constants to the back\n              if (a.isConstant(true)) return 1;\n              return b.power - a.power;\n            });\n            var LT = terms[0];\n\n            // Check if the LT is indeed the greatest\n            if (power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\n              if (LT.multiplier.lessThan(0)) {\n                // Although the symbol should always be linear at this point, remove the negative for squares\n                // to be safe.\n                factors.add(new Symbol(-1));\n                symbol.each(function (x) {\n                  x.negate();\n                }, true);\n              }\n            }\n          }\n          if (factors) {\n            factors.add(new Symbol(gcd));\n          }\n        }\n        return symbol;\n      },\n      /**\r\n       * The name says it all :)\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @@param {String} variable \r\n       * @returns {Symbol}\r\n       */\n      trialAndError: function (symbol, factors, variable) {\n        var untouched = symbol.clone();\n        try {\n          // At temp holder for the factors. If all goes well then\n          // they'll be moved to the actual factors.\n          var factor_array = [];\n          if (symbol.isConstant() || symbol.group === S) return symbol;\n          var poly = new Polynomial(symbol, variable),\n            cnst = poly.coeffs[0],\n            cfactors = core.Math2.ifactor(cnst),\n            roots = __.proots(symbol);\n          for (var i = 0; i < roots.length; i++) {\n            var r = roots[i],\n              p = 1;\n            if (!isNaN(r)) {\n              //if it's a number\n              for (var x in cfactors) {\n                //check it's raised to a power\n                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\n                if (isInt(n)) {\n                  r = x; //x must be the root since n gave us a whole\n                  p = n;\n                  break;\n                }\n              }\n              var root = new Frac(r),\n                terms = [new Frac(root.num).negate()];\n              terms[p] = new Frac(root.den);\n              //convert to Frac. The den is coeff of LT and the num is coeff of constant\n              var div = Polynomial.fromArray(terms, poly.variable).fill(),\n                t = poly.divide(div);\n              if (t[1].equalsNumber(0)) {\n                //if it's zero we have a root and divide it out\n                poly = t[0];\n                // factors.add(div.toSymbol());\n                factor_array.push(div.toSymbol());\n              }\n            }\n          }\n          if (!poly.equalsNumber(1)) {\n            poly = __.Factor.search(poly, factors);\n          }\n\n          // Move the factors over since all went well.\n          factor_array.forEach(function (x) {\n            factors.add(x);\n          });\n          return poly.toSymbol();\n        } catch (e) {\n          return untouched;\n        }\n      },\n      search: function (poly, factors, base) {\n        base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\n        var v = poly.variable; //the polynmial variable name\n        /**\r\n         * Attempt to remove a root by division given a number by first creating\r\n         * a polynomial fromt he given information\r\n         * @param {int} c1 - coeffient for the constant\r\n         * @param {int} c2 - coefficient for the LT\r\n         * @param {int} n - the number to be used to construct the polynomial\r\n         * @param {int} p - the power at which to create the polynomial\r\n         * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n         */\n        var check = function (c1, c2, n, p) {\n          var candidate = Polynomial.fit(c1, c2, n, base, p, v);\n          if (candidate && candidate.coeffs.length > 1) {\n            var t = poly.divide(candidate);\n            if (t[1].equalsNumber(0)) {\n              factors.add(candidate.toSymbol());\n              return [t[0], candidate];\n            }\n          }\n          return null;\n        };\n        var cnst = poly.coeffs[0];\n        var cfactors = core.Math2.ifactor(cnst);\n        var lc = poly.lc();\n        var ltfactors = core.Math2.ifactor(lc);\n        var subbed = poly.sub(base);\n        var isubbed = core.Math2.ifactor(subbed);\n        var nfactors = __.Factor.mix(isubbed, subbed < 0);\n        var cp = Math.ceil(poly.coeffs.length / 2);\n        var lc_is_neg = lc.lessThan(0);\n        var cnst_is_neg = cnst.lessThan(0);\n        ltfactors['1'] = 1;\n        cfactors['1'] = 1;\n        while (cp--) {\n          for (var x in ltfactors) {\n            for (var y in cfactors) {\n              for (var i = 0; i < nfactors.length; i++) {\n                var factor_found = check(x, y, nfactors[i], cp);\n                if (factor_found) {\n                  poly = factor_found[0];\n                  if (!core.Utils.isPrime(poly.sub(base))) poly = __.Factor.search(poly, factors);\n                  return poly;\n                } else if (!factor_found) {\n                  if (lc_is_neg && cnst_is_neg) factor_found = check(-x, -y, nfactors[i], cp);else if (lc_is_neg) factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\n                  else if (cnst_is_neg) factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\n                }\n              }\n            }\n          }\n        }\n        return poly;\n      },\n      /**\r\n       * Equivalent of square free factor for multivariate polynomials\r\n       * @param {type} symbol\r\n       * @param {type} factors\r\n       * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n       */\n      mSqfrFactor: function (symbol, factors) {\n        if (symbol.group !== FN) {\n          var vars = variables(symbol).reverse();\n\n          // Loop through all the variable and remove the partial derivatives\n          for (var i = 0; i < vars.length; i++) {\n            do {\n              if (vars[i] === symbol.value) {\n                //the derivative tells us nothing since this symbol is already the factor\n                factors.add(symbol);\n                symbol = new Symbol(1);\n                continue;\n              }\n              var diff = core.Calculus.diff(symbol, vars[i]);\n              var d = __.Factor.coeffFactor(diff);\n              if (d.equals(0)) break;\n\n              //trial division to see if factors have whole numbers. \n              //This can be optimized by stopping as soon as can_divide is false\n              //this will also need utilize big number at some point\n              var can_divide = true;\n              if (d.isConstant() && symbol.isComposite()) {\n                //check the coefficients\n\n                symbol.each(function (x) {\n                  if (x.multiplier % d !== 0) can_divide = false;\n                }, true);\n              }\n\n              //if we can divide then do so\n              if (can_divide) {\n                var div = __.div(symbol, d.clone()),\n                  is_factor = div[1].equals(0);\n\n                // Break infinite loop for factoring e^t*x-1\n                if (symbol.equals(div[0]) && div[1].equals(0)) {\n                  break;\n                }\n                if (div[0].isConstant()) {\n                  factors.add(div[0]);\n                  break;\n                }\n              } else is_factor = false;\n              if (is_factor) {\n                factors.add(div[0]);\n                symbol = d;\n              }\n            } while (is_factor);\n          }\n        }\n        return symbol;\n      },\n      //difference of squares factorization\n      sqdiff: function (symbol, factors) {\n        if (symbol.isConstant('all')) {\n          // Nothing to do\n          return symbol;\n        }\n        try {\n          var remove_square = function (x) {\n            return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n              return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\n            }, true);\n          };\n          var separated = core.Utils.separate(symbol.clone());\n          var obj_array = [];\n\n          //get the unique variables\n          for (var x in separated) {\n            if (x !== 'constants') {\n              obj_array.push(separated[x]);\n            }\n          }\n          obj_array.sort(function (a, b) {\n            return b.power - a.power;\n          });\n\n          //if we have the same number of variables as unique variables then we can apply the difference of squares\n          if (obj_array.length === 2) {\n            var a, b;\n            a = obj_array.pop();\n            b = obj_array.pop();\n            if (even(a.power) && even(b.power) && a.sign() === b.sign() && a.group === S && b.group === S) {\n              throw new Error('Unable to factor');\n            }\n            ;\n            if (a.isComposite() && b.power.equals(2)) {\n              //remove the square from b\n              b = remove_square(b);\n              var f = __.Factor.factor(_.add(a, separated.constants));\n              if (f.power.equals(2)) {\n                f.toLinear();\n                factors.add(_.subtract(f.clone(), b.clone()));\n                factors.add(_.add(f, b));\n                symbol = new Symbol(1);\n              }\n            } else {\n              a = a.powSimp();\n              b = b.powSimp();\n              if ((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\n                if (a.multiplier.lessThan(0)) {\n                  var t = b;\n                  b = a;\n                  a = t;\n                }\n                if (a.multiplier.greaterThan(0)) {\n                  a = remove_square(a);\n                  b = remove_square(b);\n                }\n                factors.add(_.subtract(a.clone(), b.clone()));\n                factors.add(_.add(a, b));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n        return symbol;\n      },\n      //factoring for multivariate\n      mfactor: function (symbol, factors) {\n        if (symbol.group === FN) {\n          if (symbol.fname === 'sqrt') {\n            var factors2 = new Factors(),\n              arg = __.Factor.common(symbol.args[0].clone(), factors2);\n            arg = __.Factor.coeffFactor(arg, factors2);\n            symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\n            factors2.each(function (x) {\n              symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\n            });\n          } else factors.add(symbol);\n        } else {\n          //square free factorization\n          symbol = __.Factor.mSqfrFactor(symbol, factors);\n\n          //try factor out common factors\n          //symbol = __.Factor.common(symbol, factors);\n\n          var vars = variables(symbol),\n            symbols = symbol.collectSymbols().map(function (x) {\n              return Symbol.unwrapSQRT(x);\n            }),\n            sorted = {},\n            maxes = {},\n            l = vars.length,\n            n = symbols.length;\n          //take all the variables in the symbol and organize by variable name\n          //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\n\n          for (var i = 0; i < l; i++) {\n            var v = vars[i];\n            sorted[v] = new Symbol(0);\n            for (var j = 0; j < n; j++) {\n              var s = symbols[j];\n              if (s.contains(v)) {\n                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\n                if (!maxes[v] || p < maxes[v]) maxes[v] = p;\n                sorted[v] = _.add(sorted[v], s.clone());\n              }\n            }\n          }\n          for (var x in sorted) {\n            var r = _.parse(x + '^' + maxes[x]);\n            var div = _.divide(sorted[x], r);\n            var new_factor = _.expand(div);\n            if (new_factor.equals(1)) break; //why divide by one. Just move \n            var divided = __.div(symbol.clone(), new_factor);\n            if (divided[0].equals(0)) {\n              //cant factor anymore\n              break;\n            }\n\n            // We potentially ended up with fractional coefficients when the\n            // trial division was performed. We need to remove \n            // This check will more then likely become superfluous with improvements\n            // to polynomial division\n            if (divided[1].equals(0)) {\n              var has_fractions = false;\n              divided[0].each(function (x) {\n                if (!isInt(x.multiplier)) {\n                  has_fractions = true;\n                }\n              });\n\n              // The factor isn't really a factor and needs to be put back\n              if (has_fractions) {\n                divided[1] = _.expand(_.multiply(divided[1], new_factor));\n                // Since the new factor is not just one, we exit.\n                break;\n              }\n            }\n            var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\n            if (divided[1].equals(0) && !neg_numeric_factor) {\n              //we found at least one factor\n\n              //factors.add(new_factor);\n              var d = __.div(symbol.clone(), divided[0].clone());\n              var r = d[0];\n\n              // Nothing left to do since we didn't get a reduction\n              if (r.equals(0)) {\n                return symbol;\n              }\n              symbol = d[1];\n              //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\n              //and we just return the symbol;\n              //If r equals zero then there's nothing left to do so we're done\n\n              if (r.equals(-1) && !symbol.equals(0)) return symbol;\n              var factor = divided[0];\n              if (symbol.equals(factor)) {\n                var rem = __.Factor.reduce(factor, factors);\n                if (!symbol.equals(rem)) return __.Factor.mfactor(rem, factors);\n                return rem;\n              } else {\n                factors.add(factor);\n                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\n                if (symbol.equals(0)) return r;\n              }\n              if (r.isConstant('all')) {\n                factors.add(r);\n                return r;\n              }\n              return __.Factor.mfactor(r, factors);\n            }\n          }\n        }\n\n        //difference of squares factorization\n        symbol = __.Factor.sqdiff(symbol, factors);\n\n        //factors by fishing for zeroes\n        symbol = __.Factor.zeroes(symbol, factors);\n        return symbol;\n      }\n    },\n    /**\r\n     * Checks to see if a set of \"equations\" is linear. \r\n     * @param {type} set\r\n     * @returns {Boolean}\r\n     */\n    allLinear: function (set) {\n      var l = set.length;\n      for (var i = 0; i < l; i++) {\n        if (!__.isLinear(set[i])) return false;\n      }\n      return true;\n    },\n    /*\r\n     * Checks to see if the \"equation\" is linear\r\n     * @param {Symbol} e\r\n     * @returns {boolean}\r\n     */\n    isLinear: function (e) {\n      var status = false,\n        g = e.group;\n      if (g === PL || g === CP) {\n        status = true;\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s],\n            sg = symbol.group;\n          if (sg === FN || sg === EX) {\n            status = false;\n          }\n          if (sg === CB) {\n            //needs further checking since it might be imaginary\n            status = variables(symbol).length === 1;\n          } else {\n            if (sg === PL || sg === CP) status = __.isLinear(symbol);else {\n              if (symbol.group !== N && symbol.power.toString() !== '1') {\n                status = false;\n                break;\n              }\n            }\n          }\n        }\n      } else if (g === S && e.power === 1) status = true;\n      return status;\n    },\n    gcd: function () {\n      var args;\n      if (arguments.length === 1 && arguments[0] instanceof core.Vector) args = arguments[0].elements;else args = core.Utils.arguments2Array(arguments);\n\n      //short-circuit early\n      if (args.length === 0) return new Symbol(1);else if (args.length === 1) return args[0];\n      var appeared = [],\n        evaluate = false;\n      for (var i = 0; i < args.length; i++) {\n        if (args[i].group === FN && args[i].fname === 'gcd') {\n          //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\n          args = args.concat(arguments[i].args);\n          //do not keep gcd in args\n          args.splice(i, 1);\n        } else {\n          //Look if there are any common variables such that\n          //gcd(a,b) => gcd(a,b); gcd(a,a) => a\n          var vars = variables(args[i]);\n          if (core.Utils.haveIntersection(vars, appeared)) {\n            //Ok, there are common variables\n            evaluate = true;\n            break;\n          } else appeared = appeared.concat(vars);\n        }\n      }\n\n      //appeared.length is 0 when all arguments are group N\n      if (evaluate || appeared.length === 0) {\n        //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\n        if (args.every(function (symbol) {\n          return symbol.getDenom().equals(1);\n        })) {\n          var aggregate = args[0];\n          for (var i = 1; i < args.length; i++) {\n            aggregate = __.gcd_(args[i], aggregate);\n          }\n          return aggregate;\n        } else {\n          //gcd_ cannot handle denominators correctly\n          return _.divide(__.gcd.apply(null, args.map(function (symbol) {\n            return symbol.getNum();\n          })), __.lcm.apply(null, args.map(function (symbol) {\n            return symbol.getDenom();\n          })));\n        }\n      } else return _.symfunction('gcd', args);\n    },\n    gcd_: function (a, b) {\n      if (a.group === FN || a.group === P) a = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(a);\n      });\n      if (b.group === FN) b = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(b);\n      });\n      if (a.isConstant() && b.isConstant()) {\n        // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\n        return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\n      }\n      var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\n      a = _.multiply(a.clone(), den.clone());\n      b = _.multiply(b.clone(), den.clone());\n\n      //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\n      a = _.expand(a);\n      b = _.expand(b);\n      if (a.group === CB || b.group === CB) {\n        var q = _.divide(a.clone(), b.clone()); //get the quotient\n        var t = _.multiply(b.clone(), q.getDenom().invert()); //multiply by the denominator\n        //if they have a common factor then the result will not equal one \n        if (!t.equals(1)) return t;\n      }\n\n      //just take the gcd of each component when either of them is in group EX\n      if (a.group === EX || b.group === EX) {\n        var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\n        var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\n        var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\n        return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\n      }\n      if (a.length < b.length) {\n        //swap'm\n        var t = a;\n        a = b;\n        b = t;\n      }\n      var vars_a = variables(a),\n        vars_b = variables(b);\n      if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {\n        a = new Polynomial(a);\n        b = new Polynomial(b);\n        return _.divide(a.gcd(b).toSymbol(), den);\n      } else {\n        //get the gcd of the multipiers\n        //get rid of gcd in coeffs\n        var multipliers = [];\n        a.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        b.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        var T;\n        while (!b.equals(0)) {\n          var t = b.clone();\n          a = a.clone();\n          T = __.div(a, t);\n          b = T[1];\n          if (T[0].equals(0)) {\n            //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\n            return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\n          }\n          a = t;\n        }\n        var gcd = core.Math2.QGCD.apply(undefined, multipliers);\n        if (!gcd.equals(1)) {\n          a.each(function (x) {\n            x.multiplier = x.multiplier.divide(gcd);\n          });\n        }\n\n        //return symbolic function for gcd in indeterminate form\n        if (a.equals(1) && !a.isConstant() && !b.isConstant()) return _.divide(_.symfunction('gcd', arguments), den);\n        return _.divide(a, den);\n      }\n    },\n    lcm: function () {\n      //https://math.stackexchange.com/a/319310\n      //generalization of the 2-variable formula of lcm\n\n      var args;\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof core.Vector) args = arguments[0].elements;else _.error('lcm expects either 1 vector or 2 or more arguments');\n      } else args = core.Utils.arguments2Array(arguments);\n\n      //product of all arguments\n      //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n      var numer = args.reduce(function (prev, curr) {\n        return _.multiply(prev, curr.clone());\n      }, new Symbol(1));\n\n      //gcd of complementary terms\n      var denom_args =\n      //https://stackoverflow.com/a/18223072\n      //take all complementary terms, e.g.\n      //[a,b,c] => [a*b, b*c, a*c]\n      //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\n      function (input, size) {\n        size = Number(size);\n        var results = [],\n          result,\n          mask,\n          i,\n          total = Math.pow(2, input.length);\n        for (mask = size; mask < total; mask++) {\n          result = [];\n          i = input.length - 1;\n          do {\n            if ((mask & 1 << i) !== 0) {\n              result.push(input[i]);\n            }\n          } while (i--);\n          if (result.length === size) {\n            results.push(result);\n          }\n        }\n        return results;\n        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n      }(arguments, arguments.length - 1).map(function (x) {\n        return x.reduce(function (prev, curr) {\n          return _.multiply(prev, curr.clone());\n        }, new Symbol(1));\n      });\n      var denom;\n      //don't eat the gcd term if all arguments are symbols\n      if (args.every(function (x) {\n        return core.Utils.isVariableSymbol(x);\n      })) denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));else denom = __.gcd.apply(null, denom_args);\n      //divide product of all arguments by gcd of complementary terms\n      var div = _.divide(numer, denom);\n      return div;\n    },\n    /**\r\n     * Divides one expression by another\r\n     * @param {Symbol} symbol1\r\n     * @param {Symbol} symbol2\r\n     * @returns {Array}\r\n     */\n    divide: function (symbol1, symbol2) {\n      var result, remainder, factored, den;\n      factored = core.Algebra.Factor.factor(symbol1.clone());\n      den = factored.getDenom();\n      if (!den.isConstant('all')) {\n        symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\n      } else\n        //reset the denominator since we're not dividing by it anymore\n        den = new Symbol(1);\n      result = __.div(symbol1, symbol2);\n      remainder = _.divide(result[1], symbol2);\n      return _.divide(_.add(result[0], remainder), den);\n    },\n    div: function (symbol1, symbol2) {\n      // If all else fails then assume that division failed with\n      // a remainder of zero and the original quotient\n      var fail = [new Symbol(0), symbol1.clone()];\n      try {\n        // Division by constants\n        if (symbol2.isConstant('all')) {\n          symbol1.each(function (x) {\n            x.multiplier = x.multiplier.divide(symbol2.multiplier);\n          });\n          return [symbol1, new Symbol(0)];\n        }\n        // So that factorized symbols don't affect the result\n        symbol1 = _.expand(symbol1);\n        symbol2 = _.expand(symbol2);\n        // Special case. May need revisiting\n        if (symbol1.group === S && symbol2.group === CP) {\n          var x = symbol1.value;\n          var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\n          if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\n            var k = Symbol.create(symbol1.multiplier);\n            return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\n          }\n        }\n        if (symbol1.group === S && symbol2.group === S) {\n          var r = _.divide(symbol1.clone(), symbol2.clone());\n          if (r.isConstant())\n            //we have a whole\n            return [r, new Symbol(0)];\n          return [new Symbol(0), symbol1.clone()];\n        }\n        var symbol1_has_func = symbol1.hasFunc(),\n          symbol2_has_func = symbol2.hasFunc(),\n          parse_funcs = false;\n\n        //substitute out functions so we can treat them as regular variables\n        if (symbol1_has_func || symbol2_has_func) {\n          parse_funcs = true;\n          var map = {},\n            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\n            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\n            subs = core.Utils.getFunctionsSubs(map);\n        }\n        //get a list of the variables\n        var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\n          quot,\n          rem;\n\n        //treat imaginary numbers as variables\n        if (symbol1.isImaginary() || symbol2.isImaginary()) {\n          vars.push(core.Settings.IMAGINARY);\n        }\n        if (vars.length === 1) {\n          var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\n          quot = q[0].toSymbol();\n          rem = q[1].toSymbol();\n        } else {\n          vars.push(CONST_HASH); //this is for the numbers\n          var reconvert = function (arr) {\n            var symbol = new Symbol(0);\n            for (var i = 0; i < arr.length; i++) {\n              var x = arr[i].toSymbol();\n              symbol = _.add(symbol, x);\n            }\n            return symbol;\n          };\n\n          // Silly Martin. This is why you document. I don't remember now\n          var get_unique_max = function (term, any) {\n            var max = Math.max.apply(null, term.terms),\n              count = 0,\n              idx;\n            if (!any) {\n              for (var i = 0; i < term.terms.length; i++) {\n                if (term.terms[i].equals(max)) {\n                  idx = i;\n                  count++;\n                }\n                if (count > 1) return;\n              }\n            }\n            if (any) {\n              for (i = 0; i < term.terms.length; i++) if (term.terms[i].equals(max)) {\n                idx = i;\n                break;\n              }\n            }\n            return [max, idx, term];\n          };\n\n          // Tries to find an LT in the dividend that will satisfy division\n          var get_det = function (s, lookat) {\n            lookat = lookat || 0;\n            var det = s[lookat],\n              l = s.length;\n            if (!det) return;\n            //eliminate the first term if it doesn't apply\n            var umax = get_unique_max(det);\n            for (var i = lookat + 1; i < l; i++) {\n              var term = s[i],\n                is_equal = det.sum.equals(term.sum);\n              if (!is_equal && umax) {\n                break;\n              }\n              if (is_equal) {\n                // Check the differences of their maxes. The one with the biggest difference governs\n                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\n                var max1,\n                  max2,\n                  idx1,\n                  idx2,\n                  l2 = det.terms.length;\n                for (var j = 0; j < l2; j++) {\n                  var item1 = det.terms[j],\n                    item2 = term.terms[j];\n                  if (typeof max1 === 'undefined' || item1.greaterThan(max1)) {\n                    max1 = item1;\n                    idx1 = j;\n                  }\n                  if (typeof max2 === 'undefined' || item2.greaterThan(max2)) {\n                    max2 = item2;\n                    idx2 = j;\n                  }\n                }\n                //check their differences\n                var d1 = max1.subtract(term.terms[idx1]),\n                  d2 = max2.subtract(det.terms[idx2]);\n                if (d2 > d1) {\n                  umax = [max2, idx2, term];\n                  break;\n                }\n                if (d1 > d2) {\n                  umax = [max1, idx1, det];\n                  break;\n                }\n              } else {\n                //check if it's a suitable pick to determine the order\n                umax = get_unique_max(term);\n                //if(umax) return umax;\n                if (umax) break;\n              }\n              umax = get_unique_max(term); //calculate a new unique max\n            }\n\n            //if still no umax then any will do since we have a tie\n            if (!umax) return get_unique_max(s[0], true);\n            var e, idx;\n            for (var i = 0; i < s2.length; i++) {\n              var cterm = s2[i].terms;\n              //confirm that this is a good match for the denominator\n              idx = umax[1];\n              if (idx === cterm.length - 1) return;\n              e = cterm[idx];\n              if (!e.equals(0)) break;\n            }\n            if (e.equals(0)) return get_det(s, ++lookat); //look at the next term\n\n            return umax;\n          };\n          var t_map = core.Utils.toMapObj(vars);\n          var init_sort = function (a, b) {\n            return b.sum.subtract(a.sum);\n          };\n          var is_larger = function (a, b) {\n            if (!a || !b) return false; //it's empty so...\n            for (var i = 0; i < a.terms.length; i++) {\n              if (a.terms[i].lessThan(b.terms[i])) return false;\n            }\n            return true;\n          };\n          var s1 = symbol1.tBase(t_map).sort(init_sort),\n            s2 = symbol2.tBase(t_map).sort(init_sort);\n          var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\n          var det = get_det(target); //we'll begin by assuming that this will let us know which term \n          var quotient = [];\n          if (det) {\n            var lead_var = det[1];\n            var can_divide = function (a, b) {\n              if (a[0].sum.equals(b[0].sum)) return a.length >= b.length;\n              return true;\n            };\n            var try_better_lead_var = function (s1, s2, lead_var) {\n              var checked = [];\n              for (var i = 0; i < s1.length; i++) {\n                var t = s1[i];\n                for (var j = 0; j < t.terms.length; j++) {\n                  var cf = checked[j],\n                    tt = t.terms[j];\n                  if (i === 0) checked[j] = tt; //add the terms for the first one\n                  else if (cf && !cf.equals(tt)) checked[j] = undefined;\n                }\n              }\n              for (var i = 0; i < checked.length; i++) {\n                var t = checked[i];\n                if (t && !t.equals(0)) return i;\n              }\n              return lead_var;\n            };\n            var sf = function (a, b) {\n              var l1 = a.len(),\n                l2 = b.len();\n              var blv = b.terms[lead_var],\n                alv = a.terms[lead_var];\n              if (l2 > l1 && blv.greaterThan(alv)) return l2 - l1;\n              return blv.subtract(alv);\n            };\n\n            //check to see if there's a better lead_var\n            lead_var = try_better_lead_var(s1, s2, lead_var);\n            //reorder both according to the max power\n            s1.sort(sf); //sort them both according to the leading variable power\n            s2.sort(sf);\n\n            //try to adjust if den is larger\n            var fdt = s2[0],\n              fnt = s1[0];\n            var den = new MVTerm(new Frac(1), [], fnt.map);\n            if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\n              for (var i = 0; i < fnt.terms.length; i++) {\n                var d = fdt.terms[i].subtract(fnt.terms[i]);\n                if (!d.equals(0)) {\n                  var nd = d.add(new Frac(1));\n                  den.terms[i] = d;\n                  for (var j = 0; j < s1.length; j++) {\n                    s1[j].terms[i] = s1[j].terms[i].add(nd);\n                  }\n                } else den.terms[i] = new Frac(0);\n              }\n            }\n            var dividend_larger = is_larger(s1[0], s2[0]);\n            var safety = 0;\n            var max = 200;\n            while (dividend_larger && can_divide(s1, s2)) {\n              if (safety++ > max) {\n                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\n              }\n              var q = s1[0].divide(s2[0]);\n              quotient.push(q); //add what's divided to the quotient\n              s1.shift(); //the first one is guaranteed to be gone so remove from dividend\n              for (var i = 1; i < s2.length; i++) {\n                //loop through the denominator\n                var t = s2[i].multiply(q).generateImage(),\n                  l2 = s1.length;\n                //if we're subtracting from 0\n                if (l2 === 0) {\n                  t.coeff = t.coeff.neg();\n                  s1.push(t);\n                  s1.sort(sf);\n                }\n                for (var j = 0; j < l2; j++) {\n                  var cur = s1[j];\n                  if (cur.getImg() === t.getImg()) {\n                    cur.coeff = cur.coeff.subtract(t.coeff);\n                    if (cur.coeff.equals(0)) {\n                      core.Utils.remove(s1, j);\n                      j--; //adjust the iterator\n                    }\n                    break;\n                  }\n                  if (j === l2 - 1) {\n                    t.coeff = t.coeff.neg();\n                    s1.push(t);\n                    s1.sort(sf);\n                  }\n                }\n              }\n              dividend_larger = is_larger(s1[0], s2[0]);\n              if (!dividend_larger && s1.length >= s2.length) {\n                //One more try since there might be a terms that is larger than the LT of the divisor\n                for (var i = 1; i < s1.length; i++) {\n                  dividend_larger = is_larger(s1[i], s2[0]);\n                  if (dividend_larger) {\n                    //take it from its current position and move it to the front\n                    s1.unshift(core.Utils.remove(s1, i));\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          quot = reconvert(quotient);\n          rem = reconvert(s1);\n          if (typeof den !== 'undefined') {\n            den = den.toSymbol();\n            quot = _.divide(quot, den.clone());\n            rem = _.divide(rem, den);\n          }\n        }\n\n        //put back the functions\n        if (parse_funcs) {\n          quot = _.parse(quot.text(), subs);\n          rem = _.parse(rem.text(), subs);\n        }\n        return [quot, rem];\n      } catch (e) {\n        return fail;\n      }\n    },\n    line: function (v1, v2, x) {\n      if (core.Utils.isArray(v1)) v1 = core.Utils.convertToVector(v1);\n      if (core.Utils.isArray(v2)) v2 = core.Utils.convertToVector(v2);\n      x = _.parse(x || 'x');\n      if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2)) _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\n      var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\n        dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\n        m = _.divide(dy, dx),\n        a = _.multiply(x, m.clone()),\n        b = _.multiply(v1.e(1).clone(), m);\n      return _.add(_.subtract(a, b), v1.e(2).clone());\n    },\n    PartFrac: {\n      createTemplate: function (den, denom_factors, f_array, v) {\n        //clean up the denominator function by factors so it reduces nicely\n        den = __.Factor.factor(den);\n\n        //clean up factors. This is so inefficient but factors are wrapped in parens for safety\n        den.each(function (x, key) {\n          if (x.group === FN && x.fname === '' && x.args[0].group === S) {\n            var y = x.args[0];\n            if (this.symbols) {\n              delete this.symbols[key];\n              this.symbols[y.value] = y;\n            } else {\n              den = x.args[0];\n            }\n          }\n        });\n        var factors, factors_vec, f, p, deg, degrees, m;\n        factors = denom_factors.collectFactors();\n        factors_vec = []; //a vector for the template\n        degrees = [];\n        m = new Symbol(1);\n        for (var i = 0; i < factors.length; i++) {\n          //loop through the factors\n          var factor = Symbol.unwrapPARENS(factors[i]);\n          //if in he for P^n where P is polynomial and n = integer\n          if (factor.power.greaterThan(1)) {\n            p = Number(factor.power);\n            f = factor.clone().toLinear(); //remove the power so we have only the function\n            deg = Number(__.degree(f, v)); //get the degree of f\n            //expand the factor\n            for (var j = 0; j < p; j++) {\n              var efactor = _.pow(f.clone(), new Symbol(j + 1));\n              f_array.push(efactor.clone());\n              var d = _.divide(den.clone(), efactor.clone());\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n          }\n          /*\r\n           Possible bug.\r\n           Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n           else if(factor.isConstant('all')) {\r\n           m = _.multiply(m, factor);\r\n           }\r\n           */else {\n            //get the degree of the factor so we tack it on tot he factor. This should probably be an array\n            //but for now we note it on the symbol\n            deg = Number(__.degree(factor, v));\n            f_array.push(factor);\n            var d = _.divide(den.clone(), factor.clone());\n            d = _.expand(Symbol.unwrapPARENS(d));\n            degrees.push(deg);\n            factors_vec.push(d);\n          }\n        }\n        //put back the constant\n        f_array = f_array.map(function (x) {\n          return _.multiply(x, m.clone());\n        });\n        return [f_array, factors_vec, degrees];\n      },\n      partfrac: function (symbol, v, as_array) {\n        var vars = variables(symbol);\n        v = v || _.parse(vars[0]); //make wrt optional and assume first variable\n        try {\n          var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;\n          num = _.expand(symbol.getNum());\n          den = _.expand(symbol.getDenom().toUnitMultiplier());\n          //move the entire multipier to the numerator\n          num.multiplier = symbol.multiplier;\n          //we only have a meaningful change if n factors > 1. This means that\n          //the returned group will be a CB\n          //collect the terms wrt the x\n          nterms = num.groupTerms(v);\n          //divide out wholes if top is larger\n          if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\n            div = __.div(num.clone(), _.expand(den.clone()));\n            r = div[0]; //remove the wholes\n            num = div[1]; //work with the remainder\n            nterms = num.groupTerms(v); //recalculate the nterms\n          } else r = new Symbol(0);\n          if (Number(__.degree(den, v)) === 1) {\n            var q = _.divide(num, den);\n            if (as_array) return [r, q];\n            return _.add(r, q);\n          }\n          //first factor the denominator. This means that the strength of this\n          //algorithm depends on how well we can factor the denominator. \n          ofactors = __.Factor.factor(den);\n          //create the template. This method will create the template for solving \n          //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\n          template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\n          tfactors = template[0]; //grab the factors\n          factors_vec = template[1]; //grab the factor vectors\n          degrees = template[2]; //grab the degrees\n          //make note of the powers of each term\n          powers = [nterms.length];\n          //create the dterms vector\n          dterms = [];\n          factors = [];\n          ks = [];\n          var factor, deg;\n          factors_vec.map(function (x, idx) {\n            factor = tfactors[idx];\n            deg = degrees[idx];\n            for (var i = 0; i < deg; i++) {\n              factors.push(factor.clone());\n              var k = Symbol.create(v, i);\n              var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\n              //make a note of the power which corresponds to the length of the array\n              var p = t.length;\n              powers.push(p);\n              dterms.push(t);\n              ks.push(k.clone());\n            }\n          });\n          //get the max power\n          max = core.Utils.arrayMax(powers);\n\n          //fill the holes and create a matrix\n          c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\n          //for each of the factors we do the same\n          M = new core.Matrix();\n          for (var i = 0; i < dterms.length; i++) {\n            M.elements.push(core.Utils.fillHoles(dterms[i], max));\n          }\n\n          //solve the system of equations\n          var partials = _.multiply(M.transpose().invert(), c);\n          //the results are backwards to reverse it\n          //partials.elements.reverse();\n          //convert it all back\n          var retval = as_array ? [r] : r;\n          partials.each(function (e, i) {\n            var term = _.multiply(ks[i], _.divide(e, factors[i]));\n            if (as_array) retval.push(term);else retval = _.add(retval, term);\n          });\n\n          //done\n          return retval;\n        } catch (e) {\n          //try to group symbols\n          try {\n            if (symbol.isComposite()) {\n              //group denominators\n              var denominators = {};\n              symbol.each(function (x) {\n                var d = x.getDenom();\n                var n = x.getNum();\n                var e = denominators[d];\n                denominators[d] = e ? _.add(e, n) : n;\n              });\n              var t = new Symbol(0);\n              for (var x in denominators) {\n                t = _.add(t, _.divide(denominators[x], _.parse(x)));\n              }\n              symbol = t;\n            }\n          } catch (e2) {}\n          ;\n        }\n        ;\n        return symbol;\n      }\n    },\n    degree: function (symbol, v, o) {\n      o = o || {\n        nd: [],\n        //numeric\n        sd: [],\n        //symbolic\n        depth: 0 //call depth\n      };\n      if (!v) {\n        var vars = variables(symbol);\n        //The user must specify the variable for multivariate\n        if (vars.length > 1) throw new Error('You must specify the variable for multivariate polynomials!');\n        //if it's empty then we're dealing with a constant\n        if (vars.length === 0) return new Symbol(0);\n        //assume the variable for univariate\n        v = _.parse(vars[0]);\n      }\n\n      //store the group\n      var g = symbol.group;\n      //we're going to trust the user and assume no EX. Calling isPoly \n      //would eliminate this but no sense in checking twice. \n      if (symbol.isComposite()) {\n        symbol = symbol.clone();\n        symbol.distributeExponent();\n        symbol.each(function (x) {\n          o.depth++; //mark a depth increase\n          __.degree(x, v, o);\n          o.depth--; //we're back\n        });\n      } else if (symbol.group === CB) {\n        symbol.each(function (x) {\n          o.depth++;\n          __.degree(x, v, o);\n          o.depth++;\n        });\n      } else if (g === EX && symbol.value === v.value) {\n        o.sd.push(symbol.power.clone());\n      } else if (g === S && symbol.value === v.value) {\n        o.nd.push(_.parse(symbol.power));\n      } else o.nd.push(new Symbol(0));\n\n      //get the max out of the array\n      var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\n      if (o.depth === 0 && o.sd.length > 0) {\n        if (deg !== undefined) o.sd.unshift(deg);\n        return _.symfunction('max', o.sd);\n      }\n      if (!core.Utils.isSymbol(deg)) deg = _.parse(deg);\n      //return the degree\n      return deg;\n    },\n    /**\r\n     * Attempts to complete the square of a polynomial\r\n     * @param {type} symbol\r\n     * @param {type} v\r\n     * @param {type} raw\r\n     * @throws {Error} \r\n     * @returns {Object|Symbol[]}\r\n     */\n    sqComplete: function (symbol, v, raw) {\n      if (!core.Utils.isSymbol(v)) v = _.parse(v);\n      var stop = function (msg) {\n        msg = msg || 'Stopping';\n        throw new core.exceptions.ValueLimitExceededError(msg);\n      };\n      //if not CP then nothing to do\n      if (!symbol.isPoly(true)) stop('Must be a polynomial!');\n\n      //declare vars\n      var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\n      br = core.Utils.inBrackets;\n      //make a copy\n      symbol = symbol.clone();\n      deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\n      //must be in form ax^2 +/- bx +/- c\n      if (!deg.equals(2)) stop('Cannot complete square for degree ' + deg);\n      //get the coeffs\n      coeffs = core.Algebra.coeffs(symbol, v);\n      a = coeffs[2];\n      //store the sign\n      sign = coeffs[1].sign();\n      //divide the linear term by two and square it\n      b = _.divide(coeffs[1], new Symbol(2));\n      //add the difference to the constant\n      c = _.pow(b.clone(), new Symbol(2));\n      if (raw) return [a, b, d];\n      sqrt_a = math.sqrt(a);\n      e = _.divide(math.sqrt(c), sqrt_a.clone());\n      //calculate d which is the constant\n      d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\n      //compute the square part\n      sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\n      return {\n        a: sym,\n        c: d,\n        f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\n      };\n    },\n    Simplify: {\n      strip: function (symbol) {\n        var c = _.parse(symbol.multiplier);\n        symbol.toUnitMultiplier();\n        var p = _.parse(symbol.power);\n        symbol.toLinear();\n        return [c, p, symbol];\n      },\n      unstrip: function (cp, symbol) {\n        var c = cp[0];\n        var p = cp[1];\n        return _.multiply(c, _.pow(symbol, p));\n      },\n      complexSimp: function (num, den) {\n        var ac, bd, bc, ad, cd, r1, r2, i1, i2;\n        r1 = num.realpart();\n        i1 = num.imagpart();\n        r2 = den.realpart();\n        i2 = den.imagpart();\n        //apply complex arithmatic rule\n        ac = _.multiply(r1.clone(), r2.clone());\n        bd = _.multiply(i1.clone(), i2.clone());\n        bc = _.multiply(r2.clone(), i1);\n        ad = _.multiply(r1, i2.clone());\n        cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\n        return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\n      },\n      trigSimp: function (symbol) {\n        if (symbol.containsFunction(['cos', 'sin', 'tan'])) {\n          symbol = symbol.clone();\n          //remove power and multiplier\n          var sym_array = __.Simplify.strip(symbol);\n          symbol = sym_array.pop();\n          //the default return value is the symbol\n          var retval = symbol.clone();\n\n          //rewrite the symbol\n          if (symbol.group === CP) {\n            var sym = new Symbol(0);\n            symbol.each(function (x) {\n              //rewrite the function\n              var tr = __.Simplify.trigSimp(x.fnTransform());\n              sym = _.add(sym, tr);\n            }, true);\n\n            //put back the power and multiplier and return\n            retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\n          } else if (symbol.group === CB) {\n            var n = symbol.getNum();\n            var d = symbol.getDenom();\n\n            //try for tangent\n            if (n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\n              retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\n            }\n            if (retval.group === CB) {\n              var t = new Symbol(1);\n              retval.each(function (x) {\n                if (x.fname === 'tan') {\n                  x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\n                }\n                t = _.multiply(t, x);\n              });\n              retval = t;\n            }\n          }\n          retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\n          symbol = retval;\n        }\n        return symbol;\n      },\n      fracSimp: function (symbol) {\n        //try a quick simplify of imaginary numbers\n        var den = symbol.getDenom();\n        var num = symbol.getNum();\n        if (num.isImaginary() && den.isImaginary()) symbol = __.Simplify.complexSimp(num, den);\n        if (symbol.isComposite()) {\n          if (symbol.power > 1) {\n            symbol = _.expand(symbol);\n          }\n          var symbols = symbol.collectSymbols();\n          //assumption 1.\n          //since it's a composite, it has a length of at least 1\n          var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;\n          a = symbols.pop(); //grab the first symbol\n          //loop through each term and make denominator common\n          while (symbols.length) {\n            b = symbols.pop(); //grab the second symbol\n            d1 = _.parse(a.getDenom());\n            d2 = _.parse(b.getDenom());\n            n1 = a.getNum();\n            n2 = b.getNum();\n            c = _.multiply(d1.clone(), d2.clone());\n            x = _.multiply(n1, d2);\n            y = _.multiply(n2, d1);\n            s = _.add(x, y);\n            a = _.divide(s, c);\n          }\n          den = _.expand(a.getDenom());\n          num = _.expand(a.getNum());\n          //simplify imaginary\n          if (num.isImaginary() && den.isImaginary()) {\n            retval = __.Simplify.complexSimp(num, den);\n          } else {\n            retval = _.divide(num, den);\n          }\n\n          //we've already hit the simplest form so return that\n          if (retval.equals(symbol)) {\n            return symbol;\n          }\n\n          //otherwise simplify it some more\n          return __.Simplify.simplify(retval);\n        }\n        return symbol;\n      },\n      ratSimp: function (symbol) {\n        if (symbol.group === CB) {\n          var den = symbol.getDenom();\n          var num = symbol.getNum().distributeMultiplier();\n          var d = __.Simplify.fracSimp(den);\n          var n = __.Simplify.fracSimp(num);\n          symbol = _.divide(n, d);\n        }\n        return symbol;\n      },\n      sqrtSimp: function (symbol, sym_array) {\n        var retval;\n        if (symbol.isSQRT()) {\n          var factored = __.Factor.factor(symbol.args[0].clone());\n          var m = _.parse(factored.multiplier);\n          var sign = m.sign();\n          var retval = _.sqrt(m.abs());\n          var arg;\n          if (isInt(retval)) {\n            if (factored.group === CB) {\n              var rem = new Symbol(1);\n              factored.each(function (x) {\n                if (x.group === N) {\n                  var trial = _.sqrt(x.clone());\n\n                  // Multiply back sqrt if it's an integer otherwise just put back the number\n                  if (isInt(trial)) {\n                    retval = _.multiply(retval, trial);\n                  } else {\n                    rem = _.multiply(rem, x);\n                  }\n                } else {\n                  rem = _.multiply(rem, x);\n                }\n              });\n              var t = _.multiply(rem, _.parse(sign));\n              arg = _.sqrt(t.clone());\n\n              // Expand if it's imaginary\n              if (arg.isImaginary) {\n                arg = _.sqrt(_.expand(t.clone()));\n              }\n            } else {\n              // Strip the multiplier\n              arg = _.sqrt(factored.clone().toUnitMultiplier());\n            }\n            return _.multiply(retval, arg);\n          }\n        } else if (symbol.isComposite() && symbol.isLinear()) {\n          retval = new Symbol(0);\n          symbol.each(function (x) {\n            retval = _.add(retval, __.Simplify.sqrtSimp(x));\n          }, true);\n          // Put back the multiplier\n          retval = _.multiply(retval, _.parse(symbol.multiplier));\n        } else if (symbol.group === CB) {\n          retval = _.parse(symbol.multiplier);\n          symbol.each(function (x) {\n            var simp = __.Simplify.sqrtSimp(x);\n            retval = _.multiply(retval, simp);\n          }, true);\n          // Put back the power\n          retval = _.pow(retval, _.parse(symbol.power));\n        }\n        return retval ? retval : _.parse(symbol);\n      },\n      /**\r\n       * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n       * @param {Symbol} symbol\r\n       * @return {Array} The symbol and the matched patterns\r\n       */\n      patternSub: function (symbol) {\n        var patterns = {};\n        var has_CP = function (symbol) {\n          var found = false;\n          symbol.each(function (x) {\n            if (x.group === CP) {\n              found = true;\n            } else if (x.symbols) {\n              found = has_CP(x);\n            }\n          });\n          return found;\n        };\n        var collect = function (sym) {\n          // We loop through each symbol looking for anything in the simplest\n          // form of ax+byz+...\n          sym.each(function (x) {\n            // Items of group N,P,S, need to apply\n            if (!x.symbols && x.group !== FN) {\n              return;\n            }\n\n            // Check to see if it has any symbols of group CP\n            // Get the patterns in that symbol instead if it has anything of group CP\n            if (has_CP(x)) {\n              collect(x);\n            } else {\n              if (!patterns[x.value]) {\n                var u = core.Utils.getU(symbol);\n                // Get a u value and mark it for subsitution\n                patterns[x.value] = u;\n                symbol = symbol.sub(x.value, u);\n              }\n            }\n          }, true);\n        };\n\n        // Collect a list of patterns\n        collect(symbol);\n        return [symbol, patterns];\n      },\n      simplify: function (symbol) {\n        //remove the multiplier to make calculation easier;\n        var sym_array = __.Simplify.strip(symbol);\n        symbol = sym_array.pop();\n        //remove gcd from denominator\n        symbol = __.Simplify.fracSimp(symbol);\n        //nothing more to do\n        if (symbol.isConstant() || symbol.group === core.groups.S) {\n          sym_array.push(symbol);\n          var ret = __.Simplify.unstrip(sym_array, symbol);\n          return ret;\n        }\n\n        //var patterns;\n\n        var simplified = symbol.clone(); //make a copy\n\n        //[simplified, patterns] = __.Simplify.patternSub(symbol);\n\n        // Simplify sqrt within the symbol\n        //                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\n\n        // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\n        simplified = __.Simplify.trigSimp(simplified);\n\n        // Simplify common denominators\n        simplified = __.Simplify.ratSimp(simplified);\n\n        // First go for the \"cheapest\" simplification which may eliminate \n        // your problems right away. factor -> evaluate. Remember\n        // that there's no need to expand since factor already does that\n\n        simplified = __.Factor.factor(simplified);\n\n        //If the simplfied is a sum then we can make a few more simplifications\n        //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\n        if (simplified.group === core.groups.CP && simplified.isLinear()) {\n          var m = simplified.multiplier.clone();\n          simplified.toUnitMultiplier(); //strip the multiplier\n          var r = new Symbol(0);\n          //return the sum of simplifications\n          simplified.each(function (x) {\n            var s = __.Simplify.simplify(x);\n            r = _.add(r, s);\n          });\n          simplified = r;\n          //put back the multiplier\n          r.multiplier = r.multiplier.multiply(m);\n        }\n\n        //place back multiplier and return\n        var retval = __.Simplify.unstrip(sym_array, simplified);\n\n        // Back substitute\n        /*\r\n         for(var x in patterns) {\r\n         retval = retval.sub(patterns[x], x);\r\n         }\r\n         */\n\n        return retval;\n      }\n    },\n    Classes: {\n      Polynomial: Polynomial,\n      Factors: Factors,\n      MVTerm: MVTerm\n    }\n  };\n\n  // Add a link to simplify\n  core.Expression.prototype.simplify = function () {\n    return __.Simplify.simplify(this.symbol);\n  };\n  nerdamer.useAlgebraDiv = function () {\n    var divide = __.divideFn = _.divide;\n    var calls = 0; //keep track of how many calls were made\n    _.divide = function (a, b) {\n      calls++;\n      var ans;\n      if (calls === 1)\n        //check if this is the first call. If it is use algebra divide\n        ans = core.Algebra.divide(a, b);else\n        //otherwise use parser divide\n        ans = divide(a, b);\n      calls = 0; //reset the number of calls back to none\n      return ans;\n    };\n  };\n  nerdamer.useParserDiv = function () {\n    if (__.divideFn) _.divide = __.divideFn;\n    delete __.divideFn;\n  };\n  nerdamer.register([{\n    name: 'factor',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Factor.factor;\n    }\n  }, {\n    name: 'simplify',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Simplify.simplify;\n    }\n  }, {\n    name: 'gcd',\n    visible: true,\n    numargs: [1],\n    build: function () {\n      return __.gcd;\n    }\n  }, {\n    name: 'lcm',\n    visible: true,\n    numargs: [1],\n    build: function () {\n      return __.lcm;\n    }\n  }, {\n    name: 'roots',\n    visible: true,\n    numargs: -1,\n    build: function () {\n      return __.roots;\n    }\n  }, {\n    name: 'divide',\n    visible: true,\n    numargs: 2,\n    build: function () {\n      return __.divide;\n    }\n  }, {\n    name: 'div',\n    visible: true,\n    numargs: 2,\n    build: function () {\n      return __.div;\n    }\n  }, {\n    name: 'partfrac',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.PartFrac.partfrac;\n    }\n  }, {\n    name: 'deg',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.degree;\n    }\n  }, {\n    name: 'coeffs',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      var f = function () {\n        var coeffs = __.coeffs.apply(__, arguments);\n        return new core.Vector(coeffs);\n      };\n      return f;\n    }\n  }, {\n    name: 'line',\n    visible: true,\n    numargs: [2, 3],\n    build: function () {\n      return __.line;\n    }\n  }, {\n    name: 'sqcomp',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      var f = function (x, v) {\n        try {\n          v = v || variables(x)[0];\n          var sq = __.sqComplete(x.clone(), v);\n          return sq.f;\n        } catch (e) {\n          return x;\n        }\n      };\n      return f;\n    }\n  }]);\n  nerdamer.updateAPI();\n})();","map":{"version":3,"names":["module","nerdamer","require","core","getCore","_","PARSER","N","groups","P","S","EX","FN","PL","CP","CB","keys","Utils","even","variables","format","round","Frac","isInt","Symbol","CONST_HASH","Settings","math","importFunctions","evaluate","Polynomial","symbol","variable","order","isSymbol","parse","isNaN","undefined","exceptions","InvalidVariableNameError","coeffs","fill","fromArray","arr","p","fit","c1","c2","n","base","terms","Array","t","Math","pow","i","b","q","sign","c","floor","abs","length","prototype","isPoly","NerdamerTypeError","text","power","absEquals","expand","group","multiplier","toDecimal","x","symbols","sub","Number","l","trim","equalsZero","equals","pop","modP","j","subtract","add","d","mod","w","divide","up_one","next","poly","max","a","dividend","arrayClone","divisor","mp","quotient","multiply","p1","p2","l1","l2","x1","k","x2","e","isZero","sum","clone","deg","lc","monic","gcd","mp1","mp2","T","Math2","QGCD","apply","diff","new_array","push","integrate","gcf","toPolynomial","fnz","ca","indexOf","parr","quad","incl_img","roots","Error","dsc","sqrt","squareFree","output","equalsNumber","y","z","toSymbol","end","str","plus","String","toString","with_order","error","s","distributeMultiplier","isComposite","isConstant","isImaginary","m","each","imaginary","tBase","map","collectSymbols","g","nterm","MVTerm","sym","value","updateCount","altVar","sameVars","groupTerms","f","egrouped","grouped","el","decompose_fn","collectFactors","factors","Factors","getNumberSymbolics","fo","firstObject","symfunction","PARENTHESIS","obj","negate","key","preAdd","pFactor","is_constant","v","factored","Object","values","sort","factor","fname","unwrapPARENS","merge","o","isLinear","args","call","count","clean","h","lessThan","coeff","image","getVars","vars","term","rev_map","getRevMap","join","len","mapped","generateImage","getImg","mvterm","new_mvterm","toMapObj","filledArray","clss","arrSum","haveIntersection","some","subFunctions","subbed","previousGroup","val","tvar","inBrackets","getFunctionsSubs","subs","__","Algebra","version","proots","decp","zeros","known_roots","get_roots","rarr","powers","calcroots","concat","unshift","lowest_pow","arrayMin","lowest_symbol","toUnitMultiplier","minpower","arrayMax","isArray","last_power","MAXDEGREE","slice","ValueLimitExceededError","zeroi","degreePar","Degree","zeror","QuadSD_ak1","NN","u","iPar","calcSC_ak1","DBL_EPSILON","K","qk","sdPar","dumFlag","a3","a1","a7","nextK_ak1","tFlag","qp","temp","newest_ak1","a4","a5","b1","b2","c3","c4","Quad_ak1","sr","si","lr","li","QuadIT_ak1","uu","vv","calcPar","qPar","ee","omp","relstp","ui","vi","zm","triedFlag","NZ","szr","szi","lzr","lzi","RealIT_ak1","kv","ms","pv","nm1","Fxshfr_ak1","MDP1","L2","svk","betas","betav","oss","ots","otv","ovv","ss","ts","tss","tv","tvv","fflag","iFlag","spass","stry","vpass","vtry","rpSolve","degPar","RADFAC","LB2","LN2","pt","Fxshfr_Par","bnd","df","dx","ff","moduli_max","moduli_min","sc","xm","aa","bb","cc","xxx","jj","NM1","zerok","LO","MIN_VALUE","cosr","cos","sinr","sin","xx","yy","MAX_VALUE","log","exp","img","real","num","replace","nroots","Vector","froot","guess","newtonraph","xn","mesh","build","Calculus","fn","Function","done","safety","r","delta","sumProd","invert","wrt","contains","polyPowers","for_variable","arrayUnique","Factor","split","mix","include_negatives","ll","common","zeroes","exit","tp","allSame","n_terms","n_zeroes","div","_symbol","retval","_factor","create","_factored","quadFactor","degree","cf","root","filter","root1","root2","cubeFactor","sign_a","sign_b","isCube","m_root_a","getNth","m_root_b","arg","isSimple","greaterThan","untouched","den_array","num_array","den","dfact","nfact","Simplify","strip","getDenom","getNum","unstrip","ret","toLinear","IMAGINARY","multiVar","all_S","all_unit","coeff_factors","coeffFactor","power_factors","powerFactor","t_factors","trialAndError","tf_symbol","t_factor","mfactor","addPower","reduce","nn","result","sqfr","allNumeric","updateHash","LT","factor_array","cnst","cfactors","ifactor","search","forEach","check","candidate","ltfactors","isubbed","nfactors","cp","ceil","lc_is_neg","cnst_is_neg","factor_found","isPrime","mSqfrFactor","reverse","can_divide","is_factor","sqdiff","remove_square","block","separated","separate","obj_array","constants","powSimp","factors2","unwrapSQRT","sorted","maxes","new_factor","divided","has_fractions","neg_numeric_factor","rem","allLinear","set","status","sg","arguments","elements","arguments2Array","appeared","splice","every","aggregate","gcd_","lcm","gcd_m","GCD","gcd_v","gcd_p","vars_a","vars_b","multipliers","numer","prev","curr","denom_args","input","size","results","mask","total","denom","isVariableSymbol","symbol1","symbol2","remainder","fail","symbol1_has_func","hasFunc","symbol2_has_func","parse_funcs","quot","reconvert","get_unique_max","any","idx","get_det","lookat","det","umax","is_equal","max1","max2","idx1","idx2","item1","item2","d1","d2","s2","cterm","t_map","init_sort","is_larger","s1","target","lead_var","try_better_lead_var","checked","tt","sf","blv","alv","fdt","fnt","nd","dividend_larger","InfiniteLoopError","shift","neg","cur","remove","line","v1","v2","convertToVector","isVector","dy","PartFrac","createTemplate","denom_factors","f_array","factors_vec","degrees","efactor","partfrac","as_array","tfactors","ofactors","nterms","dterms","M","ks","template","Matrix","fillHoles","transpose","partials","denominators","e2","sd","depth","distributeExponent","sqComplete","raw","stop","msg","br","sqrt_a","complexSimp","ac","bd","bc","ad","cd","r1","r2","i1","i2","realpart","imagpart","trigSimp","containsFunction","sym_array","tr","fnTransform","simplify","fracSimp","n1","n2","ratSimp","sqrtSimp","isSQRT","trial","simp","patternSub","patterns","has_CP","found","collect","getU","simplified","Classes","Expression","useAlgebraDiv","divideFn","calls","ans","useParserDiv","register","name","visible","numargs","sq","updateAPI"],"sources":["C:/Users/ROG/ai-solver/node_modules/nerdamer/Algebra.js"],"sourcesContent":["/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--> Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--> End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                var g = symbol.group;\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n                        \r\n                        var addPower = factors.length === 1;\r\n                        \r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n                        \r\n                        // We may have only factored out the symbol itself so we end up with a factor of one \r\n                        // where the power needs to be placed back\r\n                        // e.g. factor((2*y+p)^2). Here we end up having a factor of 1 remaining and a p of 2.\r\n                        if(addPower && symbol.equals(1) && retval.isLinear()) {\r\n                            retval = _.pow(retval, _.parse(p));\r\n                        }\r\n                        \r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n                                \r\n                                // Break infinite loop for factoring e^t*x-1\r\n                                if((symbol.equals(div[0]) && div[1].equals(0))) {\r\n                                    break;\r\n                                }\r\n                                \r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                                \r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        s = _.add(x, y);\r\n                        a = _.divide(s, c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.updateAPI();\r\n})();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}