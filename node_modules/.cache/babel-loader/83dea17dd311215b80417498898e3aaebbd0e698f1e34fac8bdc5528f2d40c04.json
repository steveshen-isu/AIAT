{"ast":null,"code":"import { isSymbolNode } from '../../../utils/is.js';\nimport { PartitionedMap } from '../../../utils/map.js';\n\n/**\r\n * Compile an inline expression like \"x > 0\"\r\n * @param {Node} expression\r\n * @param {Object} math\r\n * @param {Map} scope\r\n * @return {function} Returns a function with one argument which fills in the\r\n *                    undefined variable (like \"x\") and evaluates the expression\r\n */\nexport function compileInlineExpression(expression, math, scope) {\n  // find an undefined symbol\n  var symbol = expression.filter(function (node) {\n    return isSymbolNode(node) && !(node.name in math) && !scope.has(node.name);\n  })[0];\n  if (!symbol) {\n    throw new Error('No undefined variable found in inline expression \"' + expression + '\"');\n  }\n\n  // create a test function for this equation\n  var name = symbol.name; // variable name\n  var argsScope = new Map();\n  var subScope = new PartitionedMap(scope, argsScope, new Set([name]));\n  var eq = expression.compile();\n  return function inlineExpression(x) {\n    argsScope.set(name, x);\n    return eq.evaluate(subScope);\n  };\n}","map":{"version":3,"names":["isSymbolNode","PartitionedMap","compileInlineExpression","expression","math","scope","symbol","filter","node","name","has","Error","argsScope","Map","subScope","Set","eq","compile","inlineExpression","x","set","evaluate"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js"],"sourcesContent":["import { isSymbolNode } from '../../../utils/is.js';\r\nimport { PartitionedMap } from '../../../utils/map.js';\r\n\r\n/**\r\n * Compile an inline expression like \"x > 0\"\r\n * @param {Node} expression\r\n * @param {Object} math\r\n * @param {Map} scope\r\n * @return {function} Returns a function with one argument which fills in the\r\n *                    undefined variable (like \"x\") and evaluates the expression\r\n */\r\nexport function compileInlineExpression(expression, math, scope) {\r\n  // find an undefined symbol\r\n  var symbol = expression.filter(function (node) {\r\n    return isSymbolNode(node) && !(node.name in math) && !scope.has(node.name);\r\n  })[0];\r\n  if (!symbol) {\r\n    throw new Error('No undefined variable found in inline expression \"' + expression + '\"');\r\n  }\r\n\r\n  // create a test function for this equation\r\n  var name = symbol.name; // variable name\r\n  var argsScope = new Map();\r\n  var subScope = new PartitionedMap(scope, argsScope, new Set([name]));\r\n  var eq = expression.compile();\r\n  return function inlineExpression(x) {\r\n    argsScope.set(name, x);\r\n    return eq.evaluate(subScope);\r\n  };\r\n}"],"mappings":"AAAA,SAASA,YAAY,QAAQ,sBAAsB;AACnD,SAASC,cAAc,QAAQ,uBAAuB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuBA,CAACC,UAAU,EAAEC,IAAI,EAAEC,KAAK,EAAE;EAC/D;EACA,IAAIC,MAAM,GAAGH,UAAU,CAACI,MAAM,CAAC,UAAUC,IAAI,EAAE;IAC7C,OAAOR,YAAY,CAACQ,IAAI,CAAC,IAAI,EAAEA,IAAI,CAACC,IAAI,IAAIL,IAAI,CAAC,IAAI,CAACC,KAAK,CAACK,GAAG,CAACF,IAAI,CAACC,IAAI,CAAC;EAC5E,CAAC,CAAC,CAAC,CAAC,CAAC;EACL,IAAI,CAACH,MAAM,EAAE;IACX,MAAM,IAAIK,KAAK,CAAC,oDAAoD,GAAGR,UAAU,GAAG,GAAG,CAAC;EAC1F;;EAEA;EACA,IAAIM,IAAI,GAAGH,MAAM,CAACG,IAAI,CAAC,CAAC;EACxB,IAAIG,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIC,QAAQ,GAAG,IAAIb,cAAc,CAACI,KAAK,EAAEO,SAAS,EAAE,IAAIG,GAAG,CAAC,CAACN,IAAI,CAAC,CAAC,CAAC;EACpE,IAAIO,EAAE,GAAGb,UAAU,CAACc,OAAO,CAAC,CAAC;EAC7B,OAAO,SAASC,gBAAgBA,CAACC,CAAC,EAAE;IAClCP,SAAS,CAACQ,GAAG,CAACX,IAAI,EAAEU,CAAC,CAAC;IACtB,OAAOH,EAAE,CAACK,QAAQ,CAACP,QAAQ,CAAC;EAC9B,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}