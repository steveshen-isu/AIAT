{"ast":null,"code":"import { isConstantNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'symbolicEqual';\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\nexport var createSymbolicEqual = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    parse,\n    simplify,\n    typed,\n    OperatorNode\n  } = _ref;\n  /**\r\n   * Attempts to determine if two expressions are symbolically equal, i.e.\r\n   * one is the result of valid algebraic manipulations on the other.\r\n   * Currently, this simply checks if the difference of the two expressions\r\n   * simplifies down to 0. So there are two important caveats:\r\n   * 1. whether two expressions are symbolically equal depends on the\r\n   *     manipulations allowed. Therefore, this function takes an optional\r\n   *     third argument, which are the options that control the behavior\r\n   *     as documented for the `simplify()` function.\r\n   * 2. it is in general intractable to find the minimal simplification of\r\n   *     an arbitrarily complicated expression. So while a `true` value\r\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\r\n   *     to match each other, a `false` value does not absolutely rule this out.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.symbolicEqual(expr1, expr2)\r\n   *     math.symbolicEqual(expr1, expr2, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.symbolicEqual('x*y', 'y*x') // Returns true\r\n   *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\r\n   *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\r\n   *     math.symbolicEqual('abs(x)','x') // Returns false\r\n   *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, evaluate\r\n   *\r\n   * @param {Node|string} expr1  The first expression to compare\r\n   * @param {Node|string} expr2  The second expression to compare\r\n   * @param {Object} [options] Optional option object, passed to simplify\r\n   * @returns {boolean}\r\n   *     Returns true if a valid manipulation making the expressions equal\r\n   *     is found.\r\n   */\n  function _symbolicEqual(e1, e2) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var diff = new OperatorNode('-', 'subtract', [e1, e2]);\n    var simplified = simplify(diff, {}, options);\n    return isConstantNode(simplified) && !simplified.value;\n  }\n  return typed(name, {\n    'Node, Node': _symbolicEqual,\n    'Node, Node, Object': _symbolicEqual\n  });\n});","map":{"version":3,"names":["isConstantNode","factory","name","dependencies","createSymbolicEqual","_ref","parse","simplify","typed","OperatorNode","_symbolicEqual","e1","e2","options","arguments","length","undefined","diff","simplified","value"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js"],"sourcesContent":["import { isConstantNode } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'symbolicEqual';\r\nvar dependencies = ['parse', 'simplify', 'typed', 'OperatorNode'];\r\nexport var createSymbolicEqual = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    parse,\r\n    simplify,\r\n    typed,\r\n    OperatorNode\r\n  } = _ref;\r\n  /**\r\n   * Attempts to determine if two expressions are symbolically equal, i.e.\r\n   * one is the result of valid algebraic manipulations on the other.\r\n   * Currently, this simply checks if the difference of the two expressions\r\n   * simplifies down to 0. So there are two important caveats:\r\n   * 1. whether two expressions are symbolically equal depends on the\r\n   *     manipulations allowed. Therefore, this function takes an optional\r\n   *     third argument, which are the options that control the behavior\r\n   *     as documented for the `simplify()` function.\r\n   * 2. it is in general intractable to find the minimal simplification of\r\n   *     an arbitrarily complicated expression. So while a `true` value\r\n   *     of `symbolicEqual` ensures that the two expressions can be manipulated\r\n   *     to match each other, a `false` value does not absolutely rule this out.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.symbolicEqual(expr1, expr2)\r\n   *     math.symbolicEqual(expr1, expr2, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.symbolicEqual('x*y', 'y*x') // Returns true\r\n   *     math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false\r\n   *     math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true\r\n   *     math.symbolicEqual('abs(x)','x') // Returns false\r\n   *     math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, evaluate\r\n   *\r\n   * @param {Node|string} expr1  The first expression to compare\r\n   * @param {Node|string} expr2  The second expression to compare\r\n   * @param {Object} [options] Optional option object, passed to simplify\r\n   * @returns {boolean}\r\n   *     Returns true if a valid manipulation making the expressions equal\r\n   *     is found.\r\n   */\r\n  function _symbolicEqual(e1, e2) {\r\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var diff = new OperatorNode('-', 'subtract', [e1, e2]);\r\n    var simplified = simplify(diff, {}, options);\r\n    return isConstantNode(simplified) && !simplified.value;\r\n  }\r\n  return typed(name, {\r\n    'Node, Node': _symbolicEqual,\r\n    'Node, Node, Object': _symbolicEqual\r\n  });\r\n});"],"mappings":"AAAA,SAASA,cAAc,QAAQ,mBAAmB;AAClD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,IAAIC,IAAI,GAAG,eAAe;AAC1B,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,cAAc,CAAC;AACjE,OAAO,IAAIC,mBAAmB,GAAG,eAAeH,OAAO,CAACC,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EAClF,IAAI;IACFC,KAAK;IACLC,QAAQ;IACRC,KAAK;IACLC;EACF,CAAC,GAAGJ,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASK,cAAcA,CAACC,EAAE,EAAEC,EAAE,EAAE;IAC9B,IAAIC,OAAO,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACpF,IAAIG,IAAI,GAAG,IAAIR,YAAY,CAAC,GAAG,EAAE,UAAU,EAAE,CAACE,EAAE,EAAEC,EAAE,CAAC,CAAC;IACtD,IAAIM,UAAU,GAAGX,QAAQ,CAACU,IAAI,EAAE,CAAC,CAAC,EAAEJ,OAAO,CAAC;IAC5C,OAAOb,cAAc,CAACkB,UAAU,CAAC,IAAI,CAACA,UAAU,CAACC,KAAK;EACxD;EACA,OAAOX,KAAK,CAACN,IAAI,EAAE;IACjB,YAAY,EAAEQ,cAAc;IAC5B,oBAAoB,EAAEA;EACxB,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}