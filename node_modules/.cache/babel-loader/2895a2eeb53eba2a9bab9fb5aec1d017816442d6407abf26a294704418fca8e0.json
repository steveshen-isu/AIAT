{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    mathWithTransform\n  } = _ref;\n  /**\r\n   * Validate the symbol names of a scope.\r\n   * Throws an error when the scope contains an illegal symbol.\r\n   * @param {Object} scope\r\n   */\n  function _validateScope(scope) {\n    for (var symbol of [...keywords]) {\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n  class Node {\n    get type() {\n      return 'Node';\n    }\n    get isNode() {\n      return true;\n    }\n\n    /**\r\n     * Evaluate the node\r\n     * @param {Object} [scope]  Scope to read/write variables\r\n     * @return {*}              Returns the result\r\n     */\n    evaluate(scope) {\n      return this.compile().evaluate(scope);\n    }\n\n    /**\r\n     * Compile the node into an optimized, evauatable JavaScript function\r\n     * @return {{evaluate: function([Object])}} object\r\n     *                Returns an object with a function 'evaluate',\r\n     *                which can be invoked as expr.evaluate([scope: Object]),\r\n     *                where scope is an optional object with\r\n     *                variables.\r\n     */\n    compile() {\n      var expr = this._compile(mathWithTransform, {});\n      var args = {};\n      var context = null;\n      function evaluate(scope) {\n        var s = createMap(scope);\n        _validateScope(s);\n        return expr(s, args, context);\n      }\n      return {\n        evaluate\n      };\n    }\n\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n    _compile(math, argNames) {\n      throw new Error('Method _compile must be implemented by type ' + this.type);\n    }\n\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n    forEach(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run forEach on a Node interface');\n    }\n\n    /**\r\n     * Create a new Node whose children are the results of calling the\r\n     * provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {OperatorNode} Returns a transformed copy of the node\r\n     */\n    map(callback) {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot run map on a Node interface');\n    }\n\n    /**\r\n     * Validate whether an object is a Node, for use with map\r\n     * @param {Node} node\r\n     * @returns {Node} Returns the input if it's a node, else throws an Error\r\n     * @protected\r\n     */\n    _ifNode(node) {\n      if (!isNode(node)) {\n        throw new TypeError('Callback function must return a Node');\n      }\n      return node;\n    }\n\n    /**\r\n     * Recursively traverse all nodes in a node tree. Executes given callback for\r\n     * this node and each of its child nodes.\r\n     * @param {function(node: Node, path: string, parent: Node)} callback\r\n     *          A callback called for every node in the node tree.\r\n     */\n    traverse(callback) {\n      // execute callback for itself\n      // eslint-disable-next-line\n      callback(this, null, null);\n\n      // recursively traverse over all children of a node\n      function _traverse(node, callback) {\n        node.forEach(function (child, path, parent) {\n          callback(child, path, parent);\n          _traverse(child, callback);\n        });\n      }\n      _traverse(this, callback);\n    }\n\n    /**\r\n     * Recursively transform a node tree via a transform function.\r\n     *\r\n     * For example, to replace all nodes of type SymbolNode having name 'x' with\r\n     * a ConstantNode with value 2:\r\n     *\r\n     *     const res = Node.transform(function (node, path, parent) {\r\n     *       if (node && node.isSymbolNode) && (node.name === 'x')) {\r\n     *         return new ConstantNode(2)\r\n     *       }\r\n     *       else {\r\n     *         return node\r\n     *       }\r\n     *     })\r\n     *\r\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n     *          A mapping function accepting a node, and returning\r\n     *          a replacement for the node or the original node. The \"signature\"\r\n     *          of the callback must be:\r\n     *          callback(node: Node, index: string, parent: Node) : Node\r\n     * @return {Node} Returns the original node or its replacement\r\n     */\n    transform(callback) {\n      function _transform(child, path, parent) {\n        var replacement = callback(child, path, parent);\n        if (replacement !== child) {\n          // stop iterating when the node is replaced\n          return replacement;\n        }\n        return child.map(_transform);\n      }\n      return _transform(this, null, null);\n    }\n\n    /**\r\n     * Find any node in the node tree matching given filter function. For\r\n     * example, to find all nodes of type SymbolNode having name 'x':\r\n     *\r\n     *     const results = Node.filter(function (node) {\r\n     *       return (node && node.isSymbolNode) && (node.name === 'x')\r\n     *     })\r\n     *\r\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n     *            A test function returning true when a node matches, and false\r\n     *            otherwise. Function signature:\r\n     *            callback(node: Node, index: string, parent: Node) : boolean\r\n     * @return {Node[]} nodes\r\n     *            An array with nodes matching given filter criteria\r\n     */\n    filter(callback) {\n      var nodes = [];\n      this.traverse(function (node, path, parent) {\n        if (callback(node, path, parent)) {\n          nodes.push(node);\n        }\n      });\n      return nodes;\n    }\n\n    /**\r\n     * Create a shallow clone of this node\r\n     * @return {Node}\r\n     */\n    clone() {\n      // must be implemented by each of the Node implementations\n      throw new Error('Cannot clone a Node interface');\n    }\n\n    /**\r\n     * Create a deep clone of this node\r\n     * @return {Node}\r\n     */\n    cloneDeep() {\n      return this.map(function (node) {\n        return node.cloneDeep();\n      });\n    }\n\n    /**\r\n     * Deep compare this node with another node.\r\n     * @param {Node} other\r\n     * @return {boolean} Returns true when both nodes are of the same type and\r\n     *                   contain the same values (as do their childs)\r\n     */\n    equals(other) {\n      return other ? this.type === other.type && deepStrictEqual(this, other) : false;\n    }\n\n    /**\r\n     * Get string representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\"or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\n    toString(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toString(options);\n    }\n\n    /**\r\n     * Internal function to generate the string output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @throws {Error}\r\n     */\n    _toString() {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toString not implemented for ' + this.type);\n    }\n\n    /**\r\n     * Get a JSON representation of the node\r\n     * Both .toJSON() and the static .fromJSON(json) should be implemented by all\r\n     * implementations of Node\r\n     * @returns {Object}\r\n     */\n    toJSON() {\n      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n    }\n\n    /**\r\n     * Get HTML representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\" or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\n    toHTML(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toHTML(options);\n    }\n\n    /**\r\n     * Internal function to generate the HTML output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @throws {Error}\r\n     */\n    _toHTML() {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toHTML not implemented for ' + this.type);\n    }\n\n    /**\r\n     * Get LaTeX representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\"or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\n    toTex(options) {\n      var customString = this._getCustomString(options);\n      if (typeof customString !== 'undefined') {\n        return customString;\n      }\n      return this._toTex(options);\n    }\n\n    /**\r\n     * Internal function to generate the LaTeX output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @param {Object} [options]\r\n     * @throws {Error}\r\n     */\n    _toTex(options) {\n      // must be implemented by each of the Node implementations\n      throw new Error('_toTex not implemented for ' + this.type);\n    }\n\n    /**\r\n     * Helper used by `to...` functions.\r\n     */\n    _getCustomString(options) {\n      if (options && typeof options === 'object') {\n        switch (typeof options.handler) {\n          case 'object':\n          case 'undefined':\n            return;\n          case 'function':\n            return options.handler(this, options);\n          default:\n            throw new TypeError('Object or function expected as callback');\n        }\n      }\n    }\n\n    /**\r\n     * Get identifier.\r\n     * @return {string}\r\n     */\n    getIdentifier() {\n      return this.type;\n    }\n\n    /**\r\n     * Get the content of the current Node.\r\n     * @return {Node} node\r\n     **/\n    getContent() {\n      return this;\n    }\n  }\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","keywords","deepStrictEqual","factory","createMap","name","dependencies","createNode","_ref","mathWithTransform","_validateScope","scope","symbol","has","Error","Node","type","evaluate","compile","expr","_compile","args","context","s","math","argNames","forEach","callback","map","_ifNode","node","TypeError","traverse","_traverse","child","path","parent","transform","_transform","replacement","filter","nodes","push","clone","cloneDeep","equals","other","toString","options","customString","_getCustomString","_toString","toJSON","toHTML","_toHTML","toTex","_toTex","handler","getIdentifier","getContent","isClass"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/expression/node/Node.js"],"sourcesContent":["import { isNode } from '../../utils/is.js';\r\nimport { keywords } from '../keywords.js';\r\nimport { deepStrictEqual } from '../../utils/object.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { createMap } from '../../utils/map.js';\r\nvar name = 'Node';\r\nvar dependencies = ['mathWithTransform'];\r\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    mathWithTransform\r\n  } = _ref;\r\n  /**\r\n   * Validate the symbol names of a scope.\r\n   * Throws an error when the scope contains an illegal symbol.\r\n   * @param {Object} scope\r\n   */\r\n  function _validateScope(scope) {\r\n    for (var symbol of [...keywords]) {\r\n      if (scope.has(symbol)) {\r\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\r\n      }\r\n    }\r\n  }\r\n  class Node {\r\n    get type() {\r\n      return 'Node';\r\n    }\r\n    get isNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the node\r\n     * @param {Object} [scope]  Scope to read/write variables\r\n     * @return {*}              Returns the result\r\n     */\r\n    evaluate(scope) {\r\n      return this.compile().evaluate(scope);\r\n    }\r\n\r\n    /**\r\n     * Compile the node into an optimized, evauatable JavaScript function\r\n     * @return {{evaluate: function([Object])}} object\r\n     *                Returns an object with a function 'evaluate',\r\n     *                which can be invoked as expr.evaluate([scope: Object]),\r\n     *                where scope is an optional object with\r\n     *                variables.\r\n     */\r\n    compile() {\r\n      var expr = this._compile(mathWithTransform, {});\r\n      var args = {};\r\n      var context = null;\r\n      function evaluate(scope) {\r\n        var s = createMap(scope);\r\n        _validateScope(s);\r\n        return expr(s, args, context);\r\n      }\r\n      return {\r\n        evaluate\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      throw new Error('Method _compile must be implemented by type ' + this.type);\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('Cannot run forEach on a Node interface');\r\n    }\r\n\r\n    /**\r\n     * Create a new Node whose children are the results of calling the\r\n     * provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {OperatorNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('Cannot run map on a Node interface');\r\n    }\r\n\r\n    /**\r\n     * Validate whether an object is a Node, for use with map\r\n     * @param {Node} node\r\n     * @returns {Node} Returns the input if it's a node, else throws an Error\r\n     * @protected\r\n     */\r\n    _ifNode(node) {\r\n      if (!isNode(node)) {\r\n        throw new TypeError('Callback function must return a Node');\r\n      }\r\n      return node;\r\n    }\r\n\r\n    /**\r\n     * Recursively traverse all nodes in a node tree. Executes given callback for\r\n     * this node and each of its child nodes.\r\n     * @param {function(node: Node, path: string, parent: Node)} callback\r\n     *          A callback called for every node in the node tree.\r\n     */\r\n    traverse(callback) {\r\n      // execute callback for itself\r\n      // eslint-disable-next-line\r\n      callback(this, null, null);\r\n\r\n      // recursively traverse over all children of a node\r\n      function _traverse(node, callback) {\r\n        node.forEach(function (child, path, parent) {\r\n          callback(child, path, parent);\r\n          _traverse(child, callback);\r\n        });\r\n      }\r\n      _traverse(this, callback);\r\n    }\r\n\r\n    /**\r\n     * Recursively transform a node tree via a transform function.\r\n     *\r\n     * For example, to replace all nodes of type SymbolNode having name 'x' with\r\n     * a ConstantNode with value 2:\r\n     *\r\n     *     const res = Node.transform(function (node, path, parent) {\r\n     *       if (node && node.isSymbolNode) && (node.name === 'x')) {\r\n     *         return new ConstantNode(2)\r\n     *       }\r\n     *       else {\r\n     *         return node\r\n     *       }\r\n     *     })\r\n     *\r\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n     *          A mapping function accepting a node, and returning\r\n     *          a replacement for the node or the original node. The \"signature\"\r\n     *          of the callback must be:\r\n     *          callback(node: Node, index: string, parent: Node) : Node\r\n     * @return {Node} Returns the original node or its replacement\r\n     */\r\n    transform(callback) {\r\n      function _transform(child, path, parent) {\r\n        var replacement = callback(child, path, parent);\r\n        if (replacement !== child) {\r\n          // stop iterating when the node is replaced\r\n          return replacement;\r\n        }\r\n        return child.map(_transform);\r\n      }\r\n      return _transform(this, null, null);\r\n    }\r\n\r\n    /**\r\n     * Find any node in the node tree matching given filter function. For\r\n     * example, to find all nodes of type SymbolNode having name 'x':\r\n     *\r\n     *     const results = Node.filter(function (node) {\r\n     *       return (node && node.isSymbolNode) && (node.name === 'x')\r\n     *     })\r\n     *\r\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n     *            A test function returning true when a node matches, and false\r\n     *            otherwise. Function signature:\r\n     *            callback(node: Node, index: string, parent: Node) : boolean\r\n     * @return {Node[]} nodes\r\n     *            An array with nodes matching given filter criteria\r\n     */\r\n    filter(callback) {\r\n      var nodes = [];\r\n      this.traverse(function (node, path, parent) {\r\n        if (callback(node, path, parent)) {\r\n          nodes.push(node);\r\n        }\r\n      });\r\n      return nodes;\r\n    }\r\n\r\n    /**\r\n     * Create a shallow clone of this node\r\n     * @return {Node}\r\n     */\r\n    clone() {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('Cannot clone a Node interface');\r\n    }\r\n\r\n    /**\r\n     * Create a deep clone of this node\r\n     * @return {Node}\r\n     */\r\n    cloneDeep() {\r\n      return this.map(function (node) {\r\n        return node.cloneDeep();\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Deep compare this node with another node.\r\n     * @param {Node} other\r\n     * @return {boolean} Returns true when both nodes are of the same type and\r\n     *                   contain the same values (as do their childs)\r\n     */\r\n    equals(other) {\r\n      return other ? this.type === other.type && deepStrictEqual(this, other) : false;\r\n    }\r\n\r\n    /**\r\n     * Get string representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\"or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\r\n    toString(options) {\r\n      var customString = this._getCustomString(options);\r\n      if (typeof customString !== 'undefined') {\r\n        return customString;\r\n      }\r\n      return this._toString(options);\r\n    }\r\n\r\n    /**\r\n     * Internal function to generate the string output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @throws {Error}\r\n     */\r\n    _toString() {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('_toString not implemented for ' + this.type);\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * Both .toJSON() and the static .fromJSON(json) should be implemented by all\r\n     * implementations of Node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\" or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\r\n    toHTML(options) {\r\n      var customString = this._getCustomString(options);\r\n      if (typeof customString !== 'undefined') {\r\n        return customString;\r\n      }\r\n      return this._toHTML(options);\r\n    }\r\n\r\n    /**\r\n     * Internal function to generate the HTML output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @throws {Error}\r\n     */\r\n    _toHTML() {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('_toHTML not implemented for ' + this.type);\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\"or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\r\n    toTex(options) {\r\n      var customString = this._getCustomString(options);\r\n      if (typeof customString !== 'undefined') {\r\n        return customString;\r\n      }\r\n      return this._toTex(options);\r\n    }\r\n\r\n    /**\r\n     * Internal function to generate the LaTeX output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @param {Object} [options]\r\n     * @throws {Error}\r\n     */\r\n    _toTex(options) {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('_toTex not implemented for ' + this.type);\r\n    }\r\n\r\n    /**\r\n     * Helper used by `to...` functions.\r\n     */\r\n    _getCustomString(options) {\r\n      if (options && typeof options === 'object') {\r\n        switch (typeof options.handler) {\r\n          case 'object':\r\n          case 'undefined':\r\n            return;\r\n          case 'function':\r\n            return options.handler(this, options);\r\n          default:\r\n            throw new TypeError('Object or function expected as callback');\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Get identifier.\r\n     * @return {string}\r\n     */\r\n    getIdentifier() {\r\n      return this.type;\r\n    }\r\n\r\n    /**\r\n     * Get the content of the current Node.\r\n     * @return {Node} node\r\n     **/\r\n    getContent() {\r\n      return this;\r\n    }\r\n  }\r\n  return Node;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}