{"ast":null,"code":"/* global module */\n\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\nif (typeof module !== 'undefined' && typeof nerdamer === 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n  require('./Algebra.js');\n}\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n    _ = core.PARSER,\n    Frac = core.Frac,\n    Settings = core.Settings,\n    isSymbol = core.Utils.isSymbol,\n    FN = core.groups.FN,\n    Symbol = core.Symbol,\n    text = core.Utils.text,\n    inBrackets = core.Utils.inBrackets,\n    isInt = core.Utils.isInt,\n    format = core.Utils.format,\n    even = core.Utils.even,\n    evaluate = core.Utils.evaluate,\n    N = core.groups.N,\n    S = core.groups.S,\n    FN = core.groups.FN,\n    PL = core.groups.PL,\n    CP = core.groups.CP,\n    CB = core.groups.CB,\n    EX = core.groups.EX,\n    P = core.groups.P,\n    LOG = Settings.LOG,\n    EXP = 'exp',\n    ABS = 'abs',\n    SQRT = 'sqrt',\n    SIN = 'sin',\n    COS = 'cos',\n    TAN = 'tan',\n    SEC = 'sec',\n    CSC = 'csc',\n    COT = 'cot',\n    ASIN = 'asin',\n    ACOS = 'acos',\n    ATAN = 'atan',\n    ASEC = 'asec',\n    ACSC = 'acsc',\n    ACOT = 'acot',\n    SINH = 'sinh',\n    COSH = 'cosh',\n    TANH = 'tanh',\n    CSCH = 'csch',\n    SECH = 'sech',\n    COTH = 'coth',\n    ASECH = 'asech',\n    ACSCH = 'acsch',\n    ACOTH = 'acoth';\n\n  //custom errors\n  function NoIntegralFound(msg) {\n    this.message = msg || \"\";\n  }\n  NoIntegralFound.prototype = new Error();\n\n  //Preparations\n  Symbol.prototype.hasIntegral = function () {\n    return this.containsFunction('integrate');\n  };\n  //transforms a function\n  Symbol.prototype.fnTransform = function () {\n    if (this.group !== FN) return this;\n    var retval,\n      a = this.args[0];\n    var m = new Symbol(this.multiplier);\n    var sym = this.clone().toUnitMultiplier();\n    if (this.isLinear()) {\n      switch (this.fname) {\n        case SINH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\n          break;\n        case COSH:\n          retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\n          break;\n        case TANH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\n          break;\n        case TAN:\n          retval = _.parse(format('sin({0})/cos({0})', a));\n          break;\n        case CSC:\n          retval = _.parse(format('1/sin({0})', a));\n          break;\n        case SEC:\n          retval = _.parse(format('1/cos({0})', a));\n          break;\n        default:\n          retval = sym;\n      }\n    } else if (this.power.equals(2)) {\n      switch (this.fname) {\n        case SIN:\n          retval = _.parse(format('1/2-cos(2*({0}))/2', a));\n          break;\n        case COS:\n          retval = _.parse(format('1/2+cos(2*({0}))/2', a));\n          break;\n        case TAN:\n          //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\n          retval = _.parse(format('sin({0})^2/cos({0})^2', a));\n          break;\n        case COSH:\n          retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\n          break;\n        case SINH:\n          retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\n          break;\n        case TANH:\n          retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\n          break;\n        case SEC:\n          retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\n          break;\n        default:\n          retval = sym;\n      }\n    } else if (this.fname === SEC) {\n      retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === CSC) {\n      retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === TAN) {\n      if (this.power.lessThan(0)) {\n        retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\n      } else {\n        retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\n      }\n    } else if (this.fname === SIN && this.power.lessThan(0)) {\n      retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === COS && this.power.lessThan(0)) {\n      retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === SIN && this.power.equals(3)) {\n      retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\n    } else if (this.fname === COS && this.power.equals(3)) {\n      retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\n    }\n    //cos(a*x)^(2*n) or sin(a*x)^(2*n)\n    else if ((this.fname === COS || this.fname === SIN) && even(this.power)) {\n      var n = this.power / 2;\n      //convert to a double angle\n      var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\n      //raise to the n and expand\n      var transformed = _.expand(_.pow(double_angle, _.parse(n)));\n      retval = new Symbol(0);\n      transformed.each(function (s) {\n        var t = s.fnTransform();\n        retval = _.add(retval, t);\n      }, true);\n    } else retval = sym;\n    return _.multiply(retval, m);\n  };\n  Symbol.prototype.hasTrig = function () {\n    if (this.isConstant(true) || this.group === S) return false;\n    if (this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname))) return true;\n    if (this.symbols) {\n      for (var x in this.symbols) if (this.symbols[x].hasTrig()) return true;\n    }\n    return false;\n  };\n  core.Expression.prototype.hasIntegral = function () {\n    return this.symbol.hasIntegral();\n  };\n  /**\r\n   * Attempts to rewrite a symbol under one common denominator\r\n   * @param {Symbol} symbol \r\n   */\n  core.Utils.toCommonDenominator = function (symbol) {\n    //transform x/a+x -> (ax+x)/a\n    if (symbol.isComposite() && symbol.isLinear()) {\n      var m = new Symbol(symbol.multiplier);\n      var denominator = new Symbol(1);\n      var numerator = new Symbol(0);\n      symbol.each(function (x) {\n        denominator = _.multiply(denominator, x.getDenom());\n      }, true);\n\n      //remove the denomitor in each term\n      symbol.each(function (x) {\n        var num = x.getNum();\n        var den = x.getDenom();\n        var factor = _.multiply(num, _.divide(denominator.clone(), den));\n        numerator = _.add(numerator, factor);\n      });\n      var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\n      return retval;\n    }\n    return symbol;\n  };\n  //A function to check if a function name is an inverse trig function\n  core.Utils.in_inverse_trig = function (x) {\n    var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\n    return inv_trig_fns.indexOf(x) !== -1;\n  };\n  //A function to check if a function name is a trig function\n  core.Utils.in_trig = function (x) {\n    var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\n    return trig_fns.indexOf(x) !== -1;\n  };\n  core.Utils.in_htrig = function (x) {\n    var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  // Matrix functions\n  core.Matrix.jacobian = function (eqns, vars) {\n    var jacobian = new core.Matrix();\n    //get the variables if not supplied\n    if (!vars) {\n      vars = core.Utils.arrayGetVariables(eqns);\n    }\n    vars.forEach(function (v, i) {\n      eqns.forEach(function (eq, j) {\n        var e = core.Calculus.diff(eq.clone(), v);\n        jacobian.set(j, i, e);\n      });\n    });\n    return jacobian;\n  };\n  core.Matrix.prototype.max = function () {\n    var max = new Symbol(0);\n    this.each(function (x) {\n      var e = x.abs();\n      if (e.gt(max)) max = e;\n    });\n    return max;\n  };\n  core.Matrix.cMatrix = function (value, vars) {\n    var m = new core.Matrix();\n    //make an initial guess\n    vars.forEach(function (v, i) {\n      m.set(i, 0, _.parse(value));\n    });\n    return m;\n  };\n  var all_functions = core.Utils.all_functions = function (arr) {\n      for (var i = 0, l = arr.length; i < l; i++) if (arr[i].group !== FN) return false;\n      return true;\n    },\n    cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n      var a, b;\n      a = symbol1.args[0];\n      b = symbol2.args[0];\n      return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\n    },\n    cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\n      //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\n      //we technically know how to do this transform but more is needed for correct output\n      if (Number(symbol2.power) !== 1) return _.multiply(symbol1, symbol2);\n      var a;\n      a = symbol1.args[0];\n      return _.parse(format('(sin(2*({0})))/2', a));\n    },\n    sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n      var a, b;\n      a = symbol1.args[0];\n      b = symbol2.args[0];\n      return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\n    },\n    trigTransform = core.Utils.trigTransform = function (arr) {\n      var map = {},\n        symbol,\n        t,\n        retval = new Symbol(1);\n      for (var i = 0, l = arr.length; i < l; i++) {\n        symbol = arr[i];\n        if (symbol.group === FN) {\n          var fname = symbol.fname;\n          if (fname === COS && map[SIN]) {\n            if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n              t = cosAsinBtransform(symbol, map[SIN]);\n            } else {\n              t = cosAsinAtransform(symbol, map[SIN]);\n            }\n            delete map[SIN];\n            retval = _.multiply(retval, t);\n          } else if (fname === SIN && map[COS]) {\n            if (map[COS].args[0].toString() !== symbol.args[0].toString()) {\n              t = cosAsinBtransform(symbol, map[COS]);\n            } else {\n              t = cosAsinAtransform(symbol, map[COS]);\n            }\n            delete map[COS];\n            retval = _.multiply(retval, t);\n          } else if (fname === SIN && map[SIN]) {\n            if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n              t = sinAsinBtransform(symbol, map[SIN]);\n              delete map[SIN];\n            } else {\n              //This should actually be redundant code but let's put just in case\n              t = _.multiply(symbol, map[SIN]);\n              delete map[SIN];\n            }\n            retval = t;\n          } else {\n            map[fname] = symbol;\n          }\n        } else retval = _.multiply(retval, symbol);\n      }\n\n      //put back the remaining functions\n      for (var x in map) retval = _.multiply(retval, map[x]);\n      return retval;\n    };\n  core.Settings.integration_depth = 10;\n  core.Settings.max_lim_depth = 10;\n  var __ = core.Calculus = {\n    version: '1.4.6',\n    sum: function (fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        start = Number(start);\n        end = Number(end);\n        retval = core.Utils.block(modifier, function () {\n          var f = fn.text(),\n            subs = {\n              '~': true\n            },\n            //lock subs. Is this even being used?\n            retval = new core.Symbol(0);\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n            var ans = _.parse(f, subs);\n            retval = _.add(retval, ans);\n          }\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('sum', arguments);\n      }\n      return retval;\n    },\n    product: function (fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        retval = core.Utils.block(modifier, function () {\n          start = Number(start);\n          end = Number(end.multiplier);\n          var f = fn.text(),\n            subs = {},\n            retval = new core.Symbol(1);\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n            retval = _.multiply(retval, _.parse(f, subs));\n          }\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('product', arguments);\n      }\n      return retval;\n    },\n    diff: function (symbol, wrt, nth) {\n      if (core.Utils.isVector(symbol)) {\n        var vector = new core.Vector([]);\n        symbol.each(function (x) {\n          vector.elements.push(__.diff(x, wrt, nth));\n        });\n        return vector;\n      } else if (core.Utils.isMatrix(symbol)) {\n        var matrix = new core.Matrix();\n        symbol.each(function (x, i, j) {\n          matrix.set(i, j, __.diff(x, wrt, nth));\n        });\n        return matrix;\n      }\n      var d = isSymbol(wrt) ? wrt.text() : wrt;\n      //the nth derivative\n      nth = isSymbol(nth) ? nth.multiplier : nth || 1;\n      if (d === undefined) d = core.Utils.variables(symbol)[0];\n\n      //unwrap sqrt\n      if (symbol.group === FN && symbol.fname === SQRT) {\n        var s = symbol.args[0],\n          sp = symbol.power.clone();\n        //these groups go to zero anyway so why waste time?\n        if (s.group !== N || s.group !== P) {\n          s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\n          s.multiplier = s.multiplier.multiply(symbol.multiplier);\n        }\n        symbol = s;\n      }\n      if (symbol.group === FN && !isSymbol(symbol.power)) {\n        var a = derive(_.parse(symbol));\n        var b = __.diff(symbol.args[0].clone(), d);\n        symbol = _.multiply(a, b); //chain rule\n      } else {\n        symbol = derive(symbol);\n      }\n      if (nth > 1) {\n        nth--;\n        symbol = __.diff(symbol, wrt, nth);\n      }\n      return symbol;\n\n      // Equivalent to \"derivative of the outside\".\n      function polydiff(symbol) {\n        if (symbol.value === d || symbol.contains(d, true)) {\n          symbol.multiplier = symbol.multiplier.multiply(symbol.power);\n          symbol.power = symbol.power.subtract(new Frac(1));\n          if (symbol.power.equals(0)) {\n            symbol = Symbol(symbol.multiplier);\n          }\n        }\n        return symbol;\n      }\n      function derive(symbol) {\n        var g = symbol.group,\n          a,\n          b,\n          cp;\n        if (g === N || g === S && symbol.value !== d || g === P) {\n          symbol = Symbol(0);\n        } else if (g === S) {\n          symbol = polydiff(symbol);\n        } else if (g === CB) {\n          var m = symbol.multiplier.clone();\n          symbol.toUnitMultiplier();\n          var retval = _.multiply(product_rule(symbol), polydiff(symbol));\n          retval.multiplier = retval.multiplier.multiply(m);\n          return retval;\n        } else if (g === FN && symbol.power.equals(1)) {\n          // Table of known derivatives\n          switch (symbol.fname) {\n            case LOG:\n              cp = symbol.clone();\n              symbol = symbol.args[0].clone(); //get the arguments\n              symbol.power = symbol.power.negate();\n              symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\n              break;\n            case COS:\n              //cos -> -sin\n              symbol.fname = SIN;\n              symbol.multiplier.negate();\n              break;\n            case SIN:\n              //sin -> cos\n              symbol.fname = COS;\n              break;\n            case TAN:\n              //tan -> sec^2\n              symbol.fname = SEC;\n              symbol.power = new Frac(2);\n              break;\n            case SEC:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, TAN);\n              break;\n            case CSC:\n              symbol = qdiff(symbol, '-cot');\n              break;\n            case COT:\n              symbol.fname = CSC;\n              symbol.multiplier.negate();\n              symbol.power = new Frac(2);\n              break;\n            case ASIN:\n              symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n            case ACOS:\n              symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n            case ATAN:\n              symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n            case ABS:\n              m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier();\n              //depending on the complexity of the symbol it's easier to just parse it into a new symbol\n              //this should really be readdressed soon\n              b = symbol.args[0].clone();\n              b.toUnitMultiplier();\n              symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\n              symbol.multiplier = m;\n              break;\n            case 'parens':\n              //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\n              //1*g'\n              symbol = Symbol(1);\n              break;\n            case 'cosh':\n              //cosh -> -sinh\n              symbol.fname = 'sinh';\n              break;\n            case 'sinh':\n              //sinh -> cosh\n              symbol.fname = 'cosh';\n              break;\n            case TANH:\n              //tanh -> sech^2\n              symbol.fname = SECH;\n              symbol.power = new Frac(2);\n              break;\n            case SECH:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, '-tanh');\n              break;\n            case CSCH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\n              break;\n            case COTH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-csch(' + arg + ')^2');\n              break;\n            case 'asinh':\n              symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n            case 'acosh':\n              symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n            case 'atanh':\n              symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n            case ASECH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\n              break;\n            case ACOTH:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\n              break;\n            case ACSCH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\n              break;\n            case ASEC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n            case ACSC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n            case ACOT:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\n              break;\n            case 'S':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\n              break;\n            case 'C':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\n              break;\n            case 'Si':\n              var arg = symbol.args[0];\n              symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\n              break;\n            case 'Shi':\n              var arg = symbol.args[0];\n              symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\n              break;\n            case 'Ci':\n              var arg = symbol.args[0];\n              symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\n              break;\n            case 'Chi':\n              var arg = symbol.args[0];\n              symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\n              break;\n            case 'Ei':\n              var arg = symbol.args[0];\n              symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\n              break;\n            case 'Li':\n              var arg = symbol.args[0];\n              symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\n              break;\n            case 'erf':\n              symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\n              break;\n            case 'atan2':\n              var x_ = String(symbol.args[0]),\n                y_ = String(symbol.args[1]);\n              symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\n              break;\n            case 'sign':\n              symbol = new Symbol(0);\n              break;\n            case 'sinc':\n              symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\n              break;\n            case Settings.LOG10:\n              symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\n              break;\n            default:\n              symbol = _.symfunction('diff', [symbol, wrt]);\n          }\n        } else if (g === EX || g === FN && isSymbol(symbol.power)) {\n          var value;\n          if (g === EX) {\n            value = symbol.value;\n          } else if (g === FN && symbol.contains(d)) {\n            value = symbol.fname + inBrackets(text(symbol.args[0]));\n          } else {\n            value = symbol.value + inBrackets(text(symbol.args[0]));\n          }\n          a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\n          b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\n          symbol = _.multiply(symbol, b);\n        } else if (g === FN && !symbol.power.equals(1)) {\n          b = symbol.clone();\n          b.toLinear();\n          b.toUnitMultiplier();\n          symbol = _.multiply(polydiff(symbol.clone()), derive(b));\n        } else if (g === CP || g === PL) {\n          // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\n          var c = symbol.clone();\n          var result = new Symbol(0);\n          for (var x in symbol.symbols) {\n            result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\n          }\n          symbol = _.multiply(polydiff(c), result);\n        }\n        symbol.updateHash();\n        return symbol;\n      }\n      ;\n      function qdiff(symbol, val, altVal) {\n        return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\n      }\n      ;\n      function product_rule(symbol) {\n        //grab all the symbols within the CB symbol\n        var symbols = symbol.collectSymbols(),\n          result = new Symbol(0),\n          l = symbols.length;\n        //loop over all the symbols\n        for (var i = 0; i < l; i++) {\n          var df = __.diff(symbols[i].clone(), d);\n          for (var j = 0; j < l; j++) {\n            //skip the symbol of which we just pulled the derivative\n            if (i !== j) {\n              //multiply out the remaining symbols\n              df = _.multiply(df, symbols[j].clone());\n            }\n          }\n          //add the derivative to the result\n          result = _.add(result, df);\n        }\n        return result; //done\n      }\n      ;\n    },\n    integration: {\n      u_substitution: function (symbols, dx) {\n        function try_combo(a, b, f) {\n          var d = __.diff(b, dx);\n          var q = f ? f(a, b) : _.divide(a.clone(), d);\n          if (!q.contains(dx, true)) return q;\n          return null;\n        }\n        function do_fn_sub(fname, arg) {\n          var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\n          subbed = subbed.sub(new Symbol(u), arg);\n          subbed.updateHash();\n          return subbed;\n        }\n        var a = symbols[0].clone(),\n          b = symbols[1].clone(),\n          g1 = a.group,\n          g2 = b.group,\n          //may cause problems if person is using this already. Will need\n          //to find algorithm for detecting conflict\n          u = '__u__',\n          Q;\n        if (g1 === FN && g2 !== FN) {\n          //e.g. 2*x*cos(x^2)\n          var arg = a.args[0];\n          Q = try_combo(b, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(a.fname, arg));\n          Q = try_combo(b, a);\n          if (Q) {\n            return __.integration.poly_integrate(a);\n          }\n        } else if (g2 === FN && g1 !== FN) {\n          //e.g. 2*(x+1)*cos((x+1)^2\n          var arg = b.args[0];\n          Q = try_combo(a, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(b.fname, arg));\n        } else if (g1 === FN && g2 === FN) {\n          Q = try_combo(a.clone(), b.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(b.clone(), a.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n        } else if (g1 === EX && g2 !== EX) {\n          var p = a.power;\n          Q = try_combo(b, p.clone());\n          if (!Q) {\n            //one more try\n            var dc = __.integration.decompose_arg(p.clone(), dx);\n            //consider the possibility of a^x^(n-1)*x^n dx\n            var xp = __.diff(dc[2].clone(), dx);\n            var dc2 = __.integration.decompose_arg(xp.clone(), dx);\n            //if their powers equal, so if dx*p == b\n            if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\n              var m = _.divide(dc[0].clone(), dc2[0].clone());\n              var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\n              new_val = _.multiply(new_val, new Symbol(u));\n              return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\n            }\n          }\n          var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\n            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\n          return retval;\n        } else if (g2 === EX && g1 !== EX) {\n          var p = b.power;\n          Q = try_combo(a, p.clone());\n          var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\n          return _.multiply(integrated.sub(new Symbol(u), p), Q);\n        } else if (a.isComposite() || b.isComposite()) {\n          var f = function (a, b) {\n            var d = __.diff(b, dx);\n            var A = core.Algebra.Factor.factor(a),\n              B = core.Algebra.Factor.factor(d);\n            var q = _.divide(A, B);\n            return q;\n          };\n          var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\n            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\n          Q = try_combo(f1.clone(), f2.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(f2.clone(), f1.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(a), Q);\n        }\n      },\n      //simple integration of a single polynomial x^(n+1)/(n+1)\n      poly_integrate: function (x) {\n        var p = x.power.toString(),\n          m = x.multiplier.toDecimal(),\n          s = x.toUnitMultiplier().toLinear();\n        if (Number(p) === -1) {\n          return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\n        }\n        return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\n      },\n      //If we're just spinning wheels we want to stop. This is why we \n      //wrap integration in a try catch block and call this to stop.\n      stop: function (msg) {\n        msg = msg || 'Unable to compute integral!';\n        core.Utils.warn(msg);\n        throw new NoIntegralFound(msg);\n      },\n      partial_fraction: function (input, dx, depth, opt) {\n        //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\n        if (!isSymbol(dx)) dx = _.parse(dx);\n        var result, partial_fractions;\n        result = new Symbol(0);\n        partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\n        if (partial_fractions.group === CB && partial_fractions.isLinear()) {\n          //perform a quick check to make sure that all partial fractions are linear\n          partial_fractions.each(function (x) {\n            if (!x.isLinear()) __.integration.stop();\n          });\n          partial_fractions.each(function (x) {\n            result = _.add(result, __.integrate(x, dx, depth, opt));\n          });\n        } else {\n          result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\n        }\n        return result;\n      },\n      get_udv: function (symbol) {\n        var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\n        //first we sort them \n        var setSymbol = function (x) {\n          var g = x.group;\n          if (g === FN) {\n            var fname = x.fname;\n            if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname)) parts[3].push(x);else if (core.Utils.in_inverse_trig(fname)) parts[1].push(x);else if (fname === LOG) parts[0].push(x);else {\n              __.integration.stop();\n            }\n          } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\n            parts[2].push(x);\n          } else if (g === EX || x.isComposite() && !x.isLinear()) parts[4].push(x);else __.integration.stop();\n        };\n        if (symbol.group === CB) symbol.each(function (x) {\n          setSymbol(Symbol.unwrapSQRT(x, true));\n        });else setSymbol(symbol);\n        var u,\n          dv = new Symbol(1);\n        //compile u and dv\n        for (var i = 0; i < 5; i++) {\n          var part = parts[i],\n            t,\n            l = part.length;\n          if (l > 0) {\n            if (l > 1) {\n              t = new Symbol(1);\n              for (var j = 0; j < l; j++) t = _.multiply(t, part[j].clone());\n            } else t = part[0].clone();\n            if (!u) {\n              u = t; //the first u encountered gets chosen\n              u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\n            } else dv = _.multiply(dv, t); //everything else belongs to dv\n          }\n        }\n        return [u, dv];\n      },\n      trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\n        parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\n        var b = parts[3],\n          ax = parts[2],\n          a = parts[0],\n          x = parts[1];\n        if (x.power.equals(2) && a.greaterThan(0)) {\n          //use tan(x)\n          var t = core.Utils.getU(symbol),\n            //get an appropriate u\n            u = _.parse(TAN + inBrackets(t)),\n            //u\n            du = _.parse(SEC + inBrackets(t) + '^2'),\n            //du\n            f = _.multiply(symbol.sub(x, u), du);\n          var integral = __.integrate(f, t, depth, opt).sub(u, x);\n          core.Utils.clearU(u);\n          return integral;\n        }\n      },\n      by_parts: function (symbol, dx, depth, o) {\n        o.previous = o.previous || [];\n        var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\n        //first LIATE\n        udv = __.integration.get_udv(symbol);\n        u = udv[0];\n        dv = udv[1];\n        du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\n        c = du.clone().stripVar(dx);\n        //strip any coefficients\n        du = _.divide(du, c.clone());\n        v = __.integrate(dv.clone(), dx, depth || 0);\n        vdu = _.multiply(v.clone(), du);\n        vdu_s = vdu.toString();\n        //currently only supports e^x*(some trig)\n        if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {\n          //We're going to exploit the fact that vdu can never be constant\n          //to work out way out of this cycle. We'll return the length of\n          //the this.previous array until we're back at level one\n          o.is_cyclic = true;\n          //return the integral. \n          return new Symbol(1);\n        } else o.previous.push(vdu_s);\n        uv = _.multiply(u, v);\n        //clear the multiplier so we're dealing with a bare integral\n        m = vdu.multiplier.clone();\n        vdu.toUnitMultiplier();\n        integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\n        integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\n        retval = _.subtract(uv, integral_vdu);\n        //we know that there cannot be constants so they're a holdover from a cyclic integral\n        if (o.is_cyclic) {\n          //start popping the previous stack so we know how deep in we are\n          o.previous.pop();\n          if (o.previous.length === 0) {\n            retval = _.expand(retval);\n            var rem = new Symbol(0);\n            retval.each(function (x) {\n              if (!x.contains(dx)) rem = _.add(rem, x.clone());\n            });\n            //get the actual uv\n            retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\n          }\n        }\n        return retval;\n      },\n      /*\r\n       * dependents: [Solve, integrate]\r\n       */\n      decompose_arg: core.Utils.decompose_fn\n    },\n    //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\n    integrate: function (original_symbol, dt, depth, opt) {\n      //assume integration wrt independent variable if expression only has one variable\n      if (!dt) {\n        var vars = core.Utils.variables(original_symbol);\n        if (vars.length === 1) dt = vars[0];\n        //defaults to x\n        dt = dt || 'x';\n      }\n      //add support for integrating vectors\n      if (core.Utils.isVector(original_symbol)) {\n        var vector = new core.Vector([]);\n        original_symbol.each(function (x) {\n          vector.elements.push(__.integrate(x, dt));\n        });\n        return vector;\n      }\n      if (!isNaN(dt)) _.error('variable expected but received ' + dt);\n      //get rid of constants right away\n      if (original_symbol.isConstant(true)) return _.multiply(original_symbol.clone(), _.parse(dt));\n\n      //configurations options for integral. This is needed for tracking extra options\n      //e.g. cyclic integrals or additional settings\n      opt = opt || {};\n      return core.Utils.block('PARSE2NUMBER', function () {\n        //make a note of the original symbol. Set only if undefined\n        depth = depth || 0;\n        var dx = isSymbol(dt) ? dt.toString() : dt,\n          //we don't want the symbol in sqrt form. x^(1/2) is prefererred\n          symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\n          g = symbol.group,\n          retval;\n        try {\n          //We stop integration after x amount of recursive calls\n          if (++depth > core.Settings.integration_depth) __.integration.stop('Maximum depth reached. Exiting!');\n\n          //constants. We first eliminate anything that doesn't have dx. Everything after this has \n          //to have dx or else it would have been taken care of below\n          if (!symbol.contains(dx, true)) {\n            retval = _.multiply(symbol.clone(), _.parse(dx));\n          }\n          //e.g. 2*x\n          else if (g === S) {\n            retval = __.integration.poly_integrate(symbol, dx, depth);\n          } else if (g === EX) {\n            if (symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS)) __.integration.stop();\n            //check the base\n            if (symbol.contains(dx) && symbol.previousGroup !== FN) {\n              //if the symbol also contains dx then we stop since we currently \n              //don't know what to do with it e.g. x^x\n              if (symbol.power.contains(dx)) __.integration.stop();else {\n                var t = __.diff(symbol.clone().toLinear(), dx);\n                if (t.contains(dx)) __.integration.stop();\n                //since at this point it's the base only then we do standard single poly integration\n                //e.g. x^y\n                retval = __.integration.poly_integrate(symbol, dx, depth);\n              }\n            }\n            //e.g. a^x or 9^x\n            else {\n              var a = __.diff(symbol.power.clone(), dx);\n              if (a.contains(dx)) {\n                var aa = a.stripVar(dx),\n                  x = _.divide(a.clone(), aa.clone());\n                if (x.group === S && x.isLinear()) {\n                  aa.multiplier = aa.multiplier.divide(new Frac(2));\n                  return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\n                } else __.integration.stop();\n              }\n              if (symbol.isE()) {\n                if (a.isLinear()) retval = symbol;else {\n                  if (a.isE() && a.power.group === S && a.power.power.equals(1)) retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);else __.integration.stop();\n                }\n              } else {\n                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\n                retval = _.divide(symbol, d);\n              }\n              retval = _.divide(retval, a);\n            }\n          } else if (symbol.isComposite() && symbol.isLinear()) {\n            var m = _.parse(symbol.multiplier);\n            symbol.toUnitMultiplier();\n            retval = new Symbol(0);\n            symbol.each(function (x) {\n              retval = _.add(retval, __.integrate(x, dx, depth));\n            });\n            retval = _.multiply(m, retval);\n          } else if (g === CP) {\n            if (symbol.power.greaterThan(1)) symbol = _.expand(symbol);\n            if (symbol.power.equals(1)) {\n              retval = new Symbol(0);\n              symbol.each(function (x) {\n                retval = _.add(retval, __.integrate(x, dx, depth));\n              }, true);\n            } else {\n              var p = Number(symbol.power),\n                m = symbol.multiplier.clone(); //temporarily remove the multiplier\n              symbol.toUnitMultiplier();\n              var\n                //below we consider the form ax+b\n                fn = symbol.clone().toLinear(),\n                //get just the pure function without the power\n                decomp = __.integration.decompose_arg(fn, dx),\n                //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\n                b = decomp[3],\n                ax = decomp[2],\n                a = decomp[0],\n                x = decomp[1];\n              if (p === -1 && x.group !== PL && x.power.equals(2)) {\n                var b_is_positive = isInt(b) ? b > 0 : true;\n                //we can now check for atan\n                if (x.group === S && x.power.equals(2) && b_is_positive) {\n                  ////then we have atan\n                  //abs is redundants since the sign appears in both denom and num.\n                  var unwrapAbs = function (s) {\n                    var result = new Symbol(1);\n                    s.each(function (x) {\n                      result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\n                    });\n                    return result;\n                  };\n                  var A = a.clone(),\n                    B = b.clone();\n                  A = _.pow(A, new Symbol(1 / 2));\n                  B = _.pow(B, new Symbol(1 / 2));\n                  //unwrap abs\n\n                  var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\n                    f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\n                  retval = _.divide(f, d);\n                } else if (x.group === S && x.isLinear()) {\n                  retval = _.divide(__.integration.poly_integrate(symbol), a);\n                } else {\n                  //1/(x^4+1)\n                  if (x.power.equals(4)) {\n                    //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\n                    var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\n                    var br = inBrackets;\n                    //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\n                    //get quadratic factors\n                    A = _.parse(SQRT + br(a) + '*' + dx + '^2');\n                    B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\n                    C = _.parse(SQRT + br(b));\n                    f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\n                    f2 = _.add(_.subtract(A, B), C);\n                    //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\n                    D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\n                    E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\n                    //let F = 2b√2∜b\n                    F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\n                    //calculate the factors\n                    L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\n                    L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\n                    retval = _.add(__.integrate(L1, dx, depth, opt), __.integrate(L2, dx, depth, opt));\n                  } else\n                    //let's try partial fractions\n                    retval = __.integration.partial_fraction(symbol, dx, depth);\n                }\n              } else if (p === -1 / 2) {\n                //detect asin and atan\n                if (x.group === S && x.power.equals(2)) {\n                  if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\n                    a.negate();\n                    //it's asin\n                    if (b.isConstant() && a.isConstant()) {\n                      var d = _.symfunction(SQRT, [a.clone()]),\n                        d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\n                      retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\n                    }\n                    //I'm not sure about this one. I'm trusting Wolfram Alpha here\n                    else {\n                      var sqrt_a = _.symfunction(SQRT, [a]),\n                        sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\n                      retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\n                    }\n                  } else {\n                    /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\n                    __.integration.stop();\n                  }\n                } else {\n                  //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\n                  __.integration.stop();\n                }\n              } else if (p === 1 / 2 && x.power.equals(2) && a.greaterThan(0)) {\n                // TODO: Revisit\n                __.integration.stop();\n              } else {\n                if (x.isLinear() && x.group !== PL) retval = _.divide(__.integration.poly_integrate(symbol), a);else if (x.power.equals(2) && a.greaterThan(0)) {\n                  var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\n                  //1/(a*x^2+b^2)^n\n                  //strip the value of b so b = 1\n                  sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\n                  sqb = _.parse(SQRT + inBrackets(b));\n                  aob = _.multiply(sqa.clone(), sqb.clone()).invert();\n                  bsqi = _.pow(b, new Symbol(symbol.power));\n                  uv = core.Utils.getU(symbol);\n                  u = _.multiply(aob, x.clone().toLinear());\n                  v = _.parse(ATAN + inBrackets(u));\n                  //the conversion will be 1+tan(x)^2 -> sec(x)^2\n                  //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \n                  //then the remaining sec will be (n-1)*2;\n                  var n = (Math.abs(symbol.power) - 1) * 2;\n                  //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\n                  var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\n                  core.Utils.clearU(uv);\n                  return _.multiply(integral.sub(uv, v), bsqi);\n                } else {\n                  if (symbol.group !== CB && !symbol.power.lessThan(0)) {\n                    retval = __.integration.by_parts(symbol, dx, depth, opt);\n                  } else {\n                    var f = symbol.clone().toLinear();\n                    var factored = core.Algebra.Factor.factor(f);\n                    var was_factored = factored.toString() !== f.toString();\n                    if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\n                      try {\n                        var f1, fx, u, sq;\n                        sq = core.Algebra.sqComplete(f, dx);\n                        u = core.Utils.getU(f);\n                        f1 = sq.f.sub(sq.a, u);\n                        fx = _.pow(f1, _.parse(symbol.power));\n                        retval = __.integrate(fx, u).sub(u, sq.a);\n                      } catch (e) {\n                        __.integration.stop();\n                      }\n                    } else retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                  }\n                }\n              }\n              retval.multiplier = retval.multiplier.multiply(m);\n            }\n          } else if (g === FN) {\n            var arg = symbol.args[0],\n              m = symbol.multiplier.clone();\n            symbol.toUnitMultiplier();\n            var decomp = __.integration.decompose_arg(arg, dx);\n            //easies way I can think of to get the coefficient and to make sure\n            //that the symbol is linear wrt dx. I'm not actually trying to get the \n            //derivative\n            var a = decomp[0],\n              x = decomp[1],\n              fname = symbol.fname;\n            //log is a special case that can be handled with integration by parts\n            if (fname === LOG || fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear()) {\n              /*integration by parts */\n              var p = symbol.power.toString();\n              if (isInt(p)) depth = depth - p; //it needs more room to find the integral\n\n              if (!arg.isComposite()) retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));else {\n                //integral u du\n                var u = core.Utils.getU(symbol);\n                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\n                var du = __.diff(arg, dx);\n                var u_du = _.multiply(f, du);\n                var integral = __.integrate(u_du, u, depth, opt);\n                retval = _.multiply(_.parse(m), integral.sub(u, arg));\n              }\n            } else if (fname === TAN && symbol.power.lessThan(0)) {\n              //convert to cotangent\n              var sym = symbol.clone();\n              sym.power.negate();\n              sym.fname = COT;\n              return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\n            } else {\n              if (!a.contains(dx, true) && symbol.isLinear()) {\n                //perform a deep search for safety\n                //first handle the special cases \n                if (fname === ABS) {\n                  //REVISIT **TODO**\n                  var x = _.divide(arg.clone(), a.clone());\n                  if (x.group === S && !x.power.lessThan(0)) {\n                    if (core.Utils.even(x.power)) {\n                      retval = __.integrate(arg, dx, depth);\n                    } else {\n                      var integrated = __.integrate(x, dx, depth);\n                      integrated.power = integrated.power.subtract(new Frac(1));\n                      retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\n                    }\n                  } else __.integration.stop();\n                } else {\n                  var ag = symbol.args[0].group,\n                    decomposed = __.integration.decompose_arg(arg, dx);\n                  if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc()) __.integration.stop();\n                  /**TODO**/ //ASIN, ACOS, ATAN\n                  switch (fname) {\n                    case COS:\n                      retval = _.symfunction(SIN, [arg]);\n                      break;\n                    case SIN:\n                      retval = _.symfunction(COS, [arg]);\n                      retval.negate();\n                      break;\n                    case TAN:\n                      retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\n                      break;\n                    case SEC:\n                      retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\n                      break;\n                    case CSC:\n                      retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\n                      break;\n                    case COT:\n                      retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\n                      break;\n                    case SINH:\n                      retval = _.symfunction(COSH, [arg]);\n                      break;\n                    case COSH:\n                      retval = _.symfunction(SINH, [arg]);\n                      break;\n                    case TANH:\n                      retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\n                      break;\n                    case ASEC:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    case ACSC:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    case ACOT:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    //inverse htrig\n                    case ASECH:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    case ACSCH:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    case ACOTH:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    //end inverse htrig\n                    //htrigh\n                    case SECH:\n                      retval = _.parse(format('atan(sinh({0}))', arg));\n                      break;\n                    case CSCH:\n                      retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\n                      break;\n                    case COTH:\n                      retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\n                      break;\n                    //end htrig\n                    case EXP:\n                      retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\n                      break;\n                    case 'S':\n                      var arg = symbol.args[0].clone(),\n                        dc = __.integration.decompose_arg(arg, dx),\n                        x_ = dc[1],\n                        a_ = dc[0];\n                      var b_ = dc[3];\n                      retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\n                      break;\n                    case 'C':\n                      var arg = symbol.args[0].clone(),\n                        dc = __.integration.decompose_arg(arg, dx),\n                        x_ = dc[1],\n                        a_ = dc[0];\n                      var b_ = dc[3];\n                      retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\n                      break;\n                    case 'erf':\n                      var arg = symbol.args[0].clone(),\n                        dc = __.integration.decompose_arg(arg, dx),\n                        x_ = dc[1],\n                        a_ = dc[0];\n                      retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\n                      break;\n                    case 'sign':\n                      retval = _.multiply(symbol.clone(), arg.clone());\n                      break;\n                    default:\n                      __.integration.stop();\n                  }\n                  retval = _.divide(retval, a);\n                }\n              } else if (x.isLinear()) {\n                if (fname === COS || fname === SIN) {\n                  var p = Number(symbol.power);\n                  //check to see if it's negative and then just transform it to sec or csc\n                  if (p < 0) {\n                    symbol.fname = fname === SIN ? CSC : SEC;\n                    symbol.invert().updateHash();\n                    retval = __.integrate(symbol, dx, depth);\n                  } else {\n                    var arg = symbol.args[0],\n                      rd = symbol.clone(),\n                      //cos^(n-1)\n                      rd2 = symbol.clone(),\n                      //cos^(n-2)\n                      q = new Symbol((p - 1) / p),\n                      //\n                      na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\n                    rd.power = rd.power.subtract(new Frac(1));\n                    rd2.power = rd2.power.subtract(new Frac(2));\n                    var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\n                    if (fname === SIN) t.negate();\n                    retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\n                  }\n                }\n                //tan(x)^n or cot(x)^n\n                else if (fname === TAN || fname === COT) {\n                  //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                  if (symbol.args[0].isLinear(dx)) {\n                    var n = symbol.power.subtract(new Frac(1)).toString(),\n                      r = symbol.clone().toUnitMultiplier(),\n                      w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\n                    r.power = r.power.subtract(new Frac(2));\n                    if (r.power.equals(0)) r = _.parse(r);\n                    retval = _.subtract(w, __.integrate(r, dx, depth));\n                  }\n                }\n                //sec(x)^n or csc(x)^n\n                else if (fname === SEC || fname === CSC) {\n                  //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                  var n1 = symbol.power.subtract(new Frac(1)).toString(),\n                    n2 = symbol.power.subtract(new Frac(2)).toString(),\n                    f2 = fname === SEC ? TAN : COT,\n                    r = symbol.clone().toUnitMultiplier(),\n                    parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\n                    w = _.parse(parse_str);\n                  r.power = r.power.subtract(new Frac(2));\n                  if (r.power.equals(0)) r = _.parse(r);\n                  retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\n                } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\n                  retval = __.integrate(symbol.fnTransform(), dx, depth);\n                } else __.integration.stop();\n              } else __.integration.stop();\n              retval.multiplier = retval.multiplier.multiply(m);\n            }\n          } else if (g === PL) {\n            retval = __.integration.partial_fraction(symbol, dx, depth);\n          } else if (g === CB) {\n            var den = symbol.getDenom();\n            if (den.group === S) symbol = _.expand(symbol);\n\n            //separate the coefficient since all we care about are symbols containing dx\n            var coeff = symbol.stripVar(dx);\n            //now get only those that apply\n            var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\n            //peform a correction for stripVar. This is a serious TODO!\n            if (coeff.contains(dx)) {\n              cfsymbol = _.multiply(cfsymbol, coeff);\n              coeff = new Symbol(1);\n            }\n\n            //if we only have one symbol left then let's not waste time. Just pull the integral\n            //and let the chips fall where they may\n            if (cfsymbol.group !== CB) {\n              if (cfsymbol.equals(1)) {\n                return __.integrate(_.expand(symbol), dx, depth);\n              }\n\n              //only factor for multivariate which are polynomials\n              if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\n                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\n              }\n              retval = __.integrate(cfsymbol, dx, depth);\n            } else {\n              //we collect the symbols and sort them descending group, descending power, descending alpabethically\n              var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\n                if (a.group === b.group) {\n                  if (Number(a.power) === Number(b.power)) if (a < b) return 1; //I want sin first\n                  else return -1;\n                  return b.power - a.power; //descending power\n                }\n                return b.group - a.group; //descending groups\n              }).map(function (x) {\n                var unwrapped = Symbol.unwrapSQRT(x, true);\n                if (unwrapped.fname === EXP) {\n                  return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\n                }\n                return unwrapped;\n              });\n              var l = symbols.length;\n              if (symbol.power < 0) {\n                if (l === 2) {\n                  return __.integrate(_.expand(symbol), dx, depth, opt);\n                }\n              }\n              //otherwise the denominator is one lumped together symbol \n              else {\n                //generate an image for \n                if (l === 2) {\n                  //try u substitution\n                  try {\n                    retval = __.integration.u_substitution(symbols, dx);\n                  } catch (e) {\n                    /* failed :`(*/\n                    ;\n                  }\n                  if (!retval) {\n                    //no success with u substitution so let's try known combinations\n                    //are they two functions\n                    var g1 = symbols[0].group,\n                      g2 = symbols[1].group,\n                      sym1 = symbols[0],\n                      sym2 = symbols[1],\n                      fn1 = sym1.fname,\n                      fn2 = sym2.fname;\n                    //reset the symbol minus the coeff\n                    symbol = _.multiply(sym1.clone(), sym2.clone());\n                    if (g1 === FN && g2 === FN) {\n                      if (fn1 === LOG || fn2 === LOG) {\n                        retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\n                      } else {\n                        symbols.sort(function (a, b) {\n                          return b.fname > a.fname;\n                        });\n                        var arg1 = sym1.args[0];\n                        //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\n                        if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S)) __.integration.stop();\n                        var decomp = __.integration.decompose_arg(arg1, dx);\n                        x = decomp[1], a = decomp[0];\n                        if (!x.isLinear())\n                          //again... linear arguments only wrt x\n                          __.integration.stop();\n\n                        //they have to have the same arguments and then we have cleared all the check to \n                        //make sure we can integrate FN & FN\n                        var arg2 = sym2.args[0];\n                        //make sure that their argument matches\n                        if (arg1.equals(arg2)) {\n                          if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\n                            if (sym1.power.lessThan(0)) __.integration.stop(); //we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\n                            //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\n                            if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\n                              sym1.fname = TAN;\n                              sym1.updateHash();\n                              retval = __.integrate(sym1, dx, depth);\n                            } else {\n                              if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\n                                //transform sin^(2*n) to (1-cos^2)^n\n                                var n = Number(sym1.power) / 2,\n                                  new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\n                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                              } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\n                                //transform cos^(2*n) to (1-sin^2)^n\n                                var n = Number(sym1.power) / 2,\n                                  new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\n                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                              } else {\n                                var p1_even = core.Utils.even(sym1.power),\n                                  p2_even = core.Utils.even(sym2.power);\n                                retval = new Symbol(0);\n                                if (!p1_even || !p2_even) {\n                                  var u, r, trans;\n                                  //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\n                                  //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\n                                  if (!p1_even) {\n                                    //u = sin(x)\n                                    u = sym2;\n                                    r = sym1;\n                                  } else {\n                                    u = sym1;\n                                    r = sym2;\n                                  }\n                                  //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\n                                  var sign = u.fname === COS ? -1 : 1,\n                                    n = r.power,\n                                    //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \n                                    //even powers afterwards which can be transformed\n                                    k = (n - 1) / 2,\n                                    //make the transformation cos(x)^2 = 1 - sin(x)^2\n                                    trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\n                                    sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\n                                  //we can now just loop through and integrate each since it's now just a polynomial with functions\n                                  sym.each(function (x) {\n                                    retval = _.add(retval, __.integration.poly_integrate(x.clone()));\n                                  });\n                                } else {\n                                  //performs double angle transformation\n                                  var double_angle = function (symbol) {\n                                    var p = symbol.power,\n                                      k = p / 2,\n                                      e;\n                                    if (symbol.fname === COS) e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;else e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\n                                    return _.parse(e);\n                                  };\n                                  //they're both even so transform both using double angle identities and we'll just\n                                  //be able to integrate by the sum of integrals\n                                  var a = double_angle(sym1),\n                                    b = double_angle(sym2),\n                                    t = _.multiply(a, b);\n                                  var sym = _.expand(t);\n                                  sym.each(function (x) {\n                                    retval = _.add(retval, __.integrate(x, dx, depth));\n                                  });\n                                  return _.multiply(retval, coeff);\n                                }\n                              }\n                            }\n                          }\n                          //tan(x)*sec(x)^n \n                          else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\n                            retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\n                          } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {\n                            //remaining: tan(x)^3*sec(x)^6\n                            if (sym1.isLinear() && sym2.isLinear()) {\n                              retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\n                            } else if (even(sym1.power)) {\n                              var p = Number(sym1.power) / 2;\n                              //transform tangent\n                              var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\n                              retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\n                            } else __.integration.stop();\n                          } else if (fn1 === SEC && fn2 === COS) {\n                            sym1.fname = COS;\n                            sym1.invert().updateHash();\n                            retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                          } else if (fn1 === SIN && fn2 === CSC) {\n                            sym2.fname = SIN;\n                            sym2.invert().updateHash();\n                            retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                          }\n                          //tan/cos\n                          else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\n                            var t = _.multiply(sym1.fnTransform(), sym2);\n                            retval = __.integrate(_.expand(t), dx, depth);\n                          } else {\n                            var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\n                            retval = __.integrate(_.expand(t), dx, depth);\n                          }\n                        }\n                        //TODO: In progress\n                        else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\n                          if (sym1.isLinear() && sym2.isLinear()) {\n                            //if in the form cos(a*x)*sin(b*x)\n                            if (sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\n                              //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\n                              var ax, bx;\n                              if (fn2 === SIN) {\n                                ax = sym1.args[0];\n                                bx = sym2.args[0];\n                              } else {\n                                bx = sym1.args[0];\n                                ax = sym2.args[0];\n                              }\n\n                              //make the transformation\n                              f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\n\n                              //integrate it\n                              retval = __.integrate(f, dx, depth);\n                            } else {\n                              var transformed = trigTransform(symbols);\n                              retval = __.integrate(_.expand(transformed), dx, depth);\n                            }\n                          } else {\n                            var transformed = new Symbol(1);\n                            symbols.map(function (sym) {\n                              var s = sym.fnTransform();\n                              transformed = _.multiply(transformed, s);\n                            });\n                            var t = _.expand(transformed);\n                            retval = __.integrate(t, dx, depth);\n                            if (retval.hasIntegral()) {\n                              retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\n                            }\n                          }\n                        } else {\n                          __.integration.stop();\n                        }\n                      }\n                    } else if (g1 === FN && g2 === S) {\n                      var sym1_is_linear = sym1.isLinear();\n                      if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Ci', [sym1.args[0]]);else if (sym1.fname === COS && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Chi', [sym1.args[0]]);else if (sym1.fname === COSH && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Si', [sym1.args[0]]);else if (sym1.fname === SIN && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Shi', [sym1.args[0]]);else if (sym1.fname === SINH && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === LOG && sym2.power.equals(-1)) {\n                        //log(x)^n/x = log(x)^(n+1)/(n+1)\n                        retval = __.integration.poly_integrate(sym1, dx, depth);\n                      } else if (sym1.fname === 'erf') {\n                        if (sym2.power.equals(1)) {\n                          var dc = __.integration.decompose_arg(sym1.args[0], dx),\n                            a_ = dc[0],\n                            x_ = dc[1],\n                            arg = sym1.args[0].toString();\n                          retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg));\n                        }\n                      } else {\n                        //since group S is guaranteed convergence we need not worry about tracking depth of integration\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else if (g1 === EX && g2 === S) {\n                      var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\n                      if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\n                        retval = _.symfunction('Ei', [sym1.power.clone()]);\n                      } else if (fn1 === LOG && x.value === sym2.value) {\n                        retval = __.integration.poly_integrate(sym1, dx, depth);\n                      } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    } else if (g1 === PL && g2 === S) {\n                      //first try to reduce the top\n                      if (sym2.value === sym1.value && sym1.power.equals(-1)) {\n                        //find the lowest power in the denominator\n                        var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\n                        //get the lowest common value between denominator and numerator\n                        var pc = Math.min(pd, sym2.power);\n                        //reduce both denominator and numerator by that factor\n                        var factor = sym2.clone();\n                        factor.power = new Frac(pc);\n                        sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\n                        var t = new Symbol(0);\n                        sym1.each(function (x) {\n                          t = _.add(t, _.divide(x.clone(), factor.clone()));\n                        });\n                        t.multiplier = sym1.multiplier;\n                        symbol = _.divide(sym2, t);\n                      } else {\n                        symbol = _.expand(symbol);\n                      }\n                      retval = __.integration.partial_fraction(symbol, dx, depth);\n                    } else if (g1 === CP && g2 === S) {\n                      var f = sym1.clone().toLinear(),\n                        f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\n                      //handle cases x^(2*n)/sqrt(1-x^2)\n                      if (sym1.power.equals(-1 / 2)) {\n                        var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\n                        var a = decomp[0].negate(),\n                          x = decomp[1],\n                          b = decomp[3],\n                          p1 = Number(sym1.power),\n                          p2 = Number(sym2.power);\n                        if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\n                          //if the substitution \n                          var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)), _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])), _.pow(a.clone(), new Symbol(2)));\n                          c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\n                          var dummy = _.parse('sin(u)');\n                          dummy.power = dummy.power.multiply(sym2.power);\n                          var integral = __.integrate(dummy, 'u', depth);\n                          var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\n                          retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\n                        } else if (p1 === -1 / 2) {\n                          var u_transform = function (f, u) {\n                            var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\n                            if (!integral.hasIntegral()) return integral;\n                          };\n                          if (p2 === -1) {\n                            retval = u_transform(_.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(), 'sqrt(1-1/({0})^2)');\n                          } else if (p2 === -2) {\n                            //apply transformation to see if it matches asin(x)\n                            retval = u_transform(_.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(), 'sqrt(1-1/({0})^2)');\n                          }\n                        }\n                      } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\n                      } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {\n                        //sum of integrals\n                        var expanded = _.expand(sym1);\n                        retval = new Symbol(0);\n                        expanded.each(function (x) {\n                          if (x.group === PL) {\n                            x.each(function (y) {\n                              retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\n                            });\n                          } else retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\n                        });\n                      } else if (sym1.power.lessThan(-2)) {\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\n                        var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                          a = decomp[0].negate(),\n                          x = decomp[1],\n                          b = decomp[3],\n                          fn = sym1.clone().toLinear();\n                        if (x.group !== PL && x.isLinear()) {\n                          var p = Number(sym2.power),\n                            du = '_u_',\n                            u = new Symbol(du),\n                            //pull the integral with the subsitution\n                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\n                            scope = {};\n\n                          //generate a scope for resubbing the symbol\n                          scope[du] = fn;\n                          var U2 = _.parse(U, scope);\n                          retval = __.integrate(U2, dx, 0);\n                        } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\n                          //factor out coefficients\n                          var factors = new core.Algebra.Classes.Factors();\n                          sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\n                          var div = core.Algebra.divide(sym2, sym1);\n                          //it assumed that the result will be of group CB\n                          if (div.group !== CB) {\n                            retval = new Symbol(0);\n                            div.each(function (t) {\n                              retval = _.add(retval, __.integrate(t, dx, depth));\n                            });\n                            //put back the factors\n                            factors.each(function (factor) {\n                              retval = _.divide(retval, factor);\n                            });\n                            retval = _.expand(retval);\n                          } else {\n                            //try something else\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else retval = __.integration.partial_fraction(symbol, dx, depth);\n                      } else {\n                        //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \n                        if (sym1.power.den.equals(2)) {\n                          //assume the function is in the form (a^2-b*x^n)^(m/2)\n                          var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                            //using the above definition\n                            a = dc[3],\n                            x = dc[1],\n                            b = dc[0],\n                            bx = dc[2];\n                          if (x.power.equals(2) && b.lessThan(0)) {\n                            //if n is even && b is negative\n                            //make a equal 1 so we can do a trig sub\n                            if (!a.equals(1)) {\n                              //divide a out of everything\n                              //move a to the coeff\n                              coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\n                            }\n                            var u = dx;\n                            var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\n                              du = _.symfunction(COS, [new Symbol(u)]),\n                              cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\n                              X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\n                              val = _.multiply(_.multiply(cosn, du), X),\n                              integral = __.integrate(val, u, depth);\n                            //but remember that u = asin(sqrt(b)*a*x)\n                            retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\n                          } else {\n                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                          }\n                        } else if (f_is_linear) {\n                          retval = __.integration.partial_fraction(symbol, dx, depth);\n                        }\n                      }\n                    } else if (sym1.isComposite() && sym2.isComposite()) {\n                      //sum of integrals\n                      retval = new Symbol(0);\n                      if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\n                        //combine and pull the integral of each\n                        var sym = _.expand(symbol);\n                        sym.each(function (x) {\n                          retval = _.add(retval, __.integrate(x, dx, depth));\n                        }, true);\n                      } else {\n                        var p1 = Number(sym1.power),\n                          p2 = Number(sym2.power);\n                        if (p1 < 0 && p2 > 0) {\n                          //swap\n                          var t = sym1;\n                          sym1 = sym2;\n                          sym2 = t;\n                        }\n                        if (p1 === -1 && p2 === -1) {\n                          retval = __.integration.partial_fraction(symbol, dx);\n                        } else {\n                          sym1.each(function (x) {\n                            var k = _.multiply(x, sym2.clone());\n                            var integral = __.integrate(k, dx, depth);\n                            retval = _.add(retval, integral);\n                          });\n                        }\n                      }\n                    } else if (g1 === CP && symbols[0].power.greaterThan(0)) {\n                      sym1 = _.expand(sym1);\n                      retval = new Symbol(0);\n                      sym1.each(function (x) {\n                        retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\n                      }, true);\n                    } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\n                      sym1 = sym1.fnTransform();\n                      retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\n                    } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\n                      if (g2 === FN && g1 === CP) {\n                        var t = sym1;\n                        sym1 = sym2;\n                        sym2 = t; //swap\n                      }\n                      var du, sym2_clone, p, q, sa, sb;\n                      du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\n                      sym2_clone = Symbol.unwrapSQRT(sym2, true);\n                      if (du.power.equals(sym2_clone.power)) {\n                        p = new Symbol(sym2.power);\n                        sa = du.clone().toLinear();\n                        sb = sym2.clone().toLinear();\n                        q = core.Algebra.divide(sa.toLinear(), sb);\n                        if (q.isConstant()) {\n                          var nq = _.pow(q, p.negate());\n                          retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\n                        }\n                      } else {\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else {\n                      var syma = sym1.clone().toLinear();\n                      var symb = sym2.clone().toLinear();\n                      if (g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) && !syma.contains(dx) && !symb.contains(dx)) {\n                        retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))', syma.toString(), symb.toString(), sym1.power.multiplier.toString(), sym2.power.multiplier.toString(), dx));\n                      } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    }\n                  }\n                } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\n                  var first = symbols[0];\n                  if (first.group === CP) {\n                    //TODO {support higher powers of x in the future}\n                    if (first.power.greaterThan(1)) first = _.expand(first);\n                    var r = _.multiply(symbols[1], symbols[2]);\n                    retval = new Symbol(0);\n                    first.each(function (x) {\n                      var t = _.multiply(x, r.clone());\n                      var intg = __.integrate(t, dx, depth);\n                      retval = _.add(retval, intg);\n                    }, true);\n                  } else {\n                    //try integration by parts although technically it will never work\n                    retval = __.integration.by_parts(symbol, dx, depth, opt);\n                  }\n                } else if (all_functions(symbols)) {\n                  var t = new Symbol(1);\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    t = _.multiply(t, symbols[i].fnTransform());\n                  }\n                  t = _.expand(t);\n                  retval = __.integrate(t, dx, depth);\n                } else {\n                  //one more go\n                  var transformed = trigTransform(symbols);\n                  retval = __.integrate(_.expand(transformed), dx, depth);\n                }\n              }\n            }\n            retval = _.multiply(retval, coeff);\n          }\n          //if an integral was found then we return it\n          if (retval) return retval;\n        } catch (error) {\n          //do nothing if it's a NoIntegralFound error otherwise let it bubble\n          if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero)) throw error;\n        }\n\n        //no symbol found so we return the integral again\n        return _.symfunction('integrate', [original_symbol, dt]);\n      }, false);\n    },\n    defint: function (symbol, from, to, dx) {\n      dx = dx || 'x'; //make x the default variable of integration\n      var get_value = function (integral, vars, point) {\n        try {\n          return _.parse(integral, vars);\n        } catch (e) {\n          //it failed for some reason so return the limit\n          var lim = __.Limit.limit(integral, dx, point);\n          return lim;\n        }\n      };\n      var vars = core.Utils.variables(symbol),\n        hasTrig = symbol.hasTrig();\n      var retval, integral;\n\n      // Fix #593 - Only assume the first variable if dx is not defined.\n      if (vars.length === 1 && !dx) dx = vars[0];\n      if (!hasTrig) {\n        integral = __.integrate(symbol, dx);\n      }\n      if (!hasTrig && !integral.hasIntegral()) {\n        var upper = {},\n          lower = {},\n          a,\n          b;\n        upper[dx] = to;\n        lower[dx] = from;\n        a = get_value(integral, upper, to, dx);\n        b = get_value(integral, lower, from, dx);\n        retval = _.subtract(a, b);\n      } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {\n        var f = core.Utils.build(symbol);\n        retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\n      } else retval = _.symfunction('defint', [symbol, from, to, dx]);\n      return retval;\n    },\n    Limit: {\n      interval: function (start, end) {\n        return _.parse(format('[{0}, {1}]', start, end));\n      },\n      diverges: function () {\n        return __.Limit.interval('-Infinity', 'Infinity');\n      },\n      divide: function (f, g, x, lim, depth) {\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        }\n        var fin = f.clone(),\n          gin = g.clone();\n\n        //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\n        //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\n        //the two-sided limit.\n        //Known limit\n        if (g.fname === ABS) {\n          var sign = f.sign();\n          var lim_sign = lim.sign();\n          if (lim.isInfinity) return _.multiply(new Symbol(sign), new Symbol(lim_sign));else if (lim.equals(0)) {\n            var fm = _.parse(f.multiplier);\n            var gm = _.parse(g.multiplier);\n            return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\n          } else {\n            //TODO: Support more limits\n            __.Limit.diverges();\n          }\n        }\n        var isInfinity = function (L) {\n          if (core.Utils.isVector(L)) {\n            for (var i = 0; i < L.elements.length; i++) if (!L.elements[i].isInfinity) return false;\n            return true;\n          }\n          return L.isInfinity;\n        };\n        var equals = function (L, v) {\n          if (core.Utils.isVector(L)) {\n            return false;\n          }\n          return L.equals(v);\n        };\n        var retval;\n        do {\n          var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\n          var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\n\n          //if it's in indeterminate form apply L'Hospital's rule\n          var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\n          //pull the derivatives\n          if (indeterminate) {\n            var ft = __.diff(f.clone(), x);\n            var gt = __.diff(g.clone(), x);\n            var t_symbol = _.expand(_.divide(ft, gt));\n            f = t_symbol.getNum();\n            g = t_symbol.getDenom();\n          }\n        } while (indeterminate);\n\n        //REMEMBER: \n        //- 1/cos(x)\n        //n/0 is still possible since we only checked for 0/0\n        var den_is_zero = lim2.equals(0);\n        var p = Number(gin.power);\n        if (lim.isConstant(true) && den_is_zero) {\n          retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\n        } else if (den_is_zero) {\n          retval = __.Limit.diverges();\n        } else {\n          retval = _.divide(lim1, lim2);\n        }\n        return retval;\n      },\n      rewriteToLog: function (symbol) {\n        var p = symbol.power.clone();\n        symbol.toLinear();\n        return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\n      },\n      getSubbed: function (f, x, lim) {\n        var retval;\n        //1. rewrite EX with base e\n        if (f.group === EX) {\n          f = __.rewriteToLog(f);\n        }\n        //2. try simple substitution\n        try {\n          retval = f.sub(x, lim);\n        } catch (e) {\n          //Nope. No go, so just return the unsubbed function so we can test the limit instead.\n          retval = f;\n        }\n        return retval;\n      },\n      isInterval: function (limit) {\n        return core.Utils.isVector(limit);\n      },\n      isConvergent: function (limit) {\n        //it's not convergent if it lies on the interval -Infinity to Infinity\n        if (\n        //It lies on the interval -Infinity to Infinity\n        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\n        //We weren't able to calculate the limit\n        limit.containsFunction('limit')) {\n          return false; //Then no\n        }\n        return true; //It is\n      },\n      limit: function (symbol, x, lim, depth) {\n        //Simplify the symbol\n        if (symbol.isLinear() && symbol.isComposite()) {\n          //Apply sum of limits\n          var limit = new Symbol(0);\n          symbol.each(function (s) {\n            limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\n          }, true);\n          return limit;\n        }\n        ;\n        symbol = core.Algebra.Simplify.simplify(symbol);\n        depth = depth || 1;\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        }\n\n        //store the multiplier\n        var m = _.parse(symbol.multiplier);\n        //strip the multiplier\n        symbol.toUnitMultiplier();\n        try {\n          //https://en.wikipedia.org/wiki/List_of_limits\n          var retval;\n          //we try the simplest option first where c is some limit\n          //lim a as x->c = a where c \n          if (symbol.isConstant(true)) {\n            retval = symbol;\n          } else {\n            var point = {};\n            point[x] = lim;\n            //lim x as x->c = c where c\n\n            try {\n              //evaluate the function at the given limit\n              var t = _.parse(symbol.sub(x, lim), point);\n\n              //a constant or infinity is known so we're done\n              if (t.isConstant(true) || t.isInfinity) retval = t;\n            } catch (e) {/*Nothing. Maybe we tried to divide by zero.*/\n            }\n            ;\n            if (!retval) {\n              //split the symbol in the numerator and the denominator\n              var num = symbol.getNum();\n              var den = symbol.getDenom();\n              if (den.isConstant(true)) {\n                //We still don't have a limit so we generate tests.\n                if (symbol.group === EX) {\n                  //https://en.wikipedia.org/wiki/List_of_limits\n                  //Speed boost for exponentials by detecting patterns\n                  var f = symbol.clone().toLinear();\n                  var p = symbol.power.clone();\n                  var _num = f.getNum();\n                  var _den = f.getDenom();\n                  var fn = core.Utils.decompose_fn(_den, x, true);\n                  //start detection of pattern (x/(x+1))^x\n                  if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\n                    retval = _.parse(format('(1/e^({0}))', fn.b));\n                  } else {\n                    var symbol_ = __.Limit.rewriteToLog(symbol.clone());\n                    //get the base\n                    var pow = symbol_.power.clone();\n                    var base = symbol_.clone().toLinear();\n                    var lim_base = __.Limit.limit(base, x, lim, depth);\n                    var lim_pow = __.Limit.limit(pow, x, lim, depth);\n                    retval = _.pow(lim_base, lim_pow);\n                  }\n                } else if (symbol.group === FN && symbol.args.length === 1) {\n                  var evaluates;\n                  //Squeeze theorem lim f(g(x)) = lim f(lim g))\n                  var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\n                  if (core.Utils.isVector(arg)) {\n                    //get the limit over that interval\n                    retval = arg.map(function (e) {\n                      var clone = symbol.clone();\n                      clone.args[0] = e;\n                      return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\n                    });\n                    return _.multiply(m, retval);\n                  }\n                  //if the argument is constant then we're done\n                  else if (arg.isConstant(true)) {\n                    //double check that it evaluates\n                    var trial = _.symfunction(symbol.fname, [arg]);\n                    //trial evaluation\n                    try {\n                      evaluate(trial);\n                      evaluates = true;\n                    } catch (e) {\n                      evaluates = false;\n                    }\n                  }\n                  if (evaluates) {\n                    retval = trial;\n                  } else {\n                    //if the limit converges. We'll deal with non-convergent ones later\n                    if (__.Limit.isConvergent(arg)) {\n                      if (symbol.fname === LOG) {\n                        switch (arg.toString()) {\n                          //lim -> 0\n                          case '0':\n                            retval = Symbol.infinity().negate();\n                            break;\n                          case 'Infinity':\n                            retval = Symbol.infinity();\n                            break;\n                          case '-Infinity':\n                            retval = Symbol.infinity();\n                            break;\n                        }\n                      } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\n                        retval = __.Limit.interval(-1, 1);\n                      } else if (symbol.fname === TAN) {\n                        var s_arg = symbol.args[0];\n                        var n = s_arg.getNum();\n                        var d = s_arg.getDenom();\n                        var pi = n.toUnitMultiplier();\n                        if (lim.isInfinity || pi.equals('pi') && d.equals(2)) {\n                          retval = divergent();\n                        }\n                      } else if (symbol.fname === Settings.FACTORIAL) {\n                        if (arg.isInfinity) return Symbol.infinity();\n                      }\n                    }\n                  }\n                } else if (symbol.group === S) {\n                  if (symbol.power > 0)\n                    //these functions always converge to the limit\n                    return _.parse(symbol, point);else {\n                    //we're dealing with 1/x^n but remember that infinity has already been dealt\n                    //with by substitution\n                    if (core.Utils.even(symbol.power)) {\n                      //even powers converge to infinity\n                      retval = Symbol.infinity();\n                    } else {\n                      //odd ones don't\n                      retval = __.Limit.diverges();\n                    }\n                  }\n                } else if (symbol.group === CB) {\n                  var lim1, lim2;\n                  //loop through all the symbols\n                  //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\n                  //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return a.group - b.group;\n                  });\n                  var f = symbols.pop();\n                  //calculate the first limit so we can keep going down the list\n                  lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\n\n                  //reduces all the limits one at a time\n                  while (symbols.length) {\n                    //get the second limit\n                    var g = symbols.pop();\n                    //get the limit of g\n                    lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\n\n                    //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\n                    if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {\n                      if (g.containsFunction(LOG)) {\n                        //swap them\n                        g = [f, f = g][0];\n                      }\n                      //invert the symbol\n                      g.invert();\n\n                      // Product of infinities\n                      if (lim1.isInfinity && lim2.isInfinity) {\n                        lim1 = Symbol.infinity();\n                      } else {\n                        lim1 = __.Limit.divide(f, g, x, lim, depth);\n                      }\n                    } else {\n                      //lim f*g = (lim f)*(lim g)\n                      lim1 = _.multiply(lim1, lim2);\n                      //let f*g equal f and h equal g \n                      f = _.multiply(f, g);\n                    }\n                  }\n\n                  //Done, lim1 is the limit we're looking for     \n                  retval = lim1;\n                } else if (symbol.isComposite()) {\n                  var _lim;\n                  if (!symbol.isLinear()) symbol = _.expand(symbol);\n                  //Apply lim f+g = (lim f)+(lim g)\n                  retval = new Symbol(0);\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return b.group - a.group;\n                  });\n                  var _symbols = [];\n                  //Analyze the functions first\n                  var fns = new Symbol(0);\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i].clone();\n                    if (sym.group === FN || sym.group === CB && sym.hasFunc()) {\n                      fns = _.add(fns, sym);\n                    } else _symbols.push(sym);\n                  }\n                  _symbols.unshift(fns);\n\n                  //make sure that we didn't just repackage the exact same symbol\n                  if (_symbols.length !== 1) {\n                    symbols = _symbols;\n                  }\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i];\n                    //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\n                    try {\n                      _lim = __.Limit.limit(sym, x, lim, depth);\n                    } catch (e) {\n                      _lim = __.Limit.diverges();\n                    }\n                    try {\n                      retval = _.add(retval, _lim);\n                    } catch (e) {\n                      if (depth++ > Settings.max_lim_depth) {\n                        return;\n                      }\n                      ;\n                      retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\n                    }\n                  }\n                }\n              } else {\n                retval = __.Limit.divide(num, den, x, lim, depth);\n              }\n            }\n          }\n\n          //if we still don't have a solution\n          if (!retval)\n            //return it symbolically\n            retval = _.symfunction('limit', [symbol, x, lim]);\n        } catch (e) {\n          //if all else fails return the symbolic function\n          retval = _.symfunction('limit', [symbol, x, lim]);\n        }\n        return _.multiply(m, retval);\n      }\n    },\n    Fresnel: {\n      S: function (x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n        return _.symfunction('S', arguments);\n      },\n      C: function (x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n        return _.symfunction('C', arguments);\n      }\n    }\n  };\n  nerdamer.register([{\n    name: 'diff',\n    visible: true,\n    numargs: [1, 3],\n    build: function () {\n      return __.diff;\n    }\n  }, {\n    name: 'sum',\n    visible: true,\n    numargs: 4,\n    build: function () {\n      return __.sum;\n    }\n  }, {\n    name: 'product',\n    visible: true,\n    numargs: 4,\n    build: function () {\n      return __.product;\n    }\n  }, {\n    name: 'integrate',\n    visible: true,\n    numargs: [1, 2],\n    build: function () {\n      return __.integrate;\n    }\n  }, {\n    name: 'defint',\n    visible: true,\n    numargs: [3, 4],\n    build: function () {\n      return __.defint;\n    }\n  }, {\n    name: 'S',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Fresnel.S;\n    }\n  }, {\n    name: 'C',\n    visible: true,\n    numargs: 1,\n    build: function () {\n      return __.Fresnel.C;\n    }\n  }, {\n    name: 'limit',\n    visible: true,\n    numargs: [3, 4],\n    build: function () {\n      return __.Limit.limit;\n    }\n  }]);\n  //link registered functions externally\n  nerdamer.updateAPI();\n})();","map":{"version":3,"names":["module","nerdamer","require","core","getCore","_","PARSER","Frac","Settings","isSymbol","Utils","FN","groups","Symbol","text","inBrackets","isInt","format","even","evaluate","N","S","PL","CP","CB","EX","P","LOG","EXP","ABS","SQRT","SIN","COS","TAN","SEC","CSC","COT","ASIN","ACOS","ATAN","ASEC","ACSC","ACOT","SINH","COSH","TANH","CSCH","SECH","COTH","ASECH","ACSCH","ACOTH","NoIntegralFound","msg","message","prototype","Error","hasIntegral","containsFunction","fnTransform","group","retval","a","args","m","multiplier","sym","clone","toUnitMultiplier","isLinear","fname","parse","power","equals","lessThan","negate","n","double_angle","pow","toLinear","transformed","expand","each","s","t","add","multiply","hasTrig","isConstant","in_trig","in_inverse_trig","symbols","x","Expression","symbol","toCommonDenominator","isComposite","denominator","numerator","getDenom","num","getNum","den","factor","divide","Algebra","inv_trig_fns","indexOf","trig_fns","in_htrig","Matrix","jacobian","eqns","vars","arrayGetVariables","forEach","v","i","eq","j","e","Calculus","diff","set","max","abs","gt","cMatrix","value","all_functions","arr","l","length","cosAsinBtransform","cosAsinBtranform","symbol1","symbol2","b","cosAsinAtransform","cosAsinAtranform","Number","sinAsinBtransform","trigTransform","map","toString","integration_depth","max_lim_depth","__","version","sum","fn","index","start","end","exceptions","NerdamerTypeError","isNumericSymbol","modifier","block","f","subs","ans","symfunction","arguments","product","wrt","nth","isVector","vector","Vector","elements","push","isMatrix","matrix","d","undefined","variables","sp","derive","polydiff","contains","subtract","g","cp","product_rule","qdiff","arg","String","x_","y_","LOG10","c","result","updateHash","val","altVal","collectSymbols","df","integration","u_substitution","dx","try_combo","q","do_fn_sub","subbed","integrate","u","sub","g1","g2","Q","poly_integrate","p","dc","decompose_arg","xp","dc2","new_val","by_parts","integrated","A","Factor","B","f1","f2","toDecimal","stop","warn","partial_fraction","input","depth","opt","partial_fractions","PartFrac","partfrac","get_udv","parts","setSymbol","unwrapSQRT","dv","part","trig_sub","ax","greaterThan","getU","du","integral","clearU","o","previous","udv","vdu","uv","integral_vdu","vdu_s","stripVar","isE","is_cyclic","pop","rem","decompose_fn","original_symbol","dt","isNaN","error","previousGroup","PARENTHESIS","aa","decomp","b_is_positive","unwrapAbs","C","D","E","F","f3","f4","L1","L2","br","d2","sqrt_a","sqrt_ax","sqa","sqb","aob","bsqi","invert","Math","factored","was_factored","degree","fx","sq","sqComplete","u_du","ag","decomposed","hasFunc","a_","b_","rd","rd2","na","r","w","n1","n2","parse_str","coeff","cfsymbol","isPoly","sort","unwrapped","sym1","sym2","fn1","fn2","arg1","arg2","new_sym","p1_even","p2_even","trans","sign","k","bx","sym1_is_linear","pd","min","apply","keys","pc","f_is_linear","p1","p2","dummy","bksub","u_transform","sqrt","expanded","y","U","scope","U2","factors","Classes","Factors","coeffFactor","div","cosn","X","sym2_clone","sa","sb","nq","syma","symb","first","intg","DivisionByZero","defint","from","to","get_value","point","lim","Limit","limit","upper","lower","build","Math2","num_integrate","interval","diverges","fin","gin","lim_sign","isInfinity","fm","gm","L","lim1","lim2","indeterminate","ft","t_symbol","den_is_zero","infinity","rewriteToLog","getSubbed","isInterval","isConvergent","Simplify","simplify","_num","_den","isOne","symbol_","base","lim_base","lim_pow","evaluates","trial","s_arg","pi","divergent","FACTORIAL","_lim","_symbols","fns","unshift","Fresnel","register","name","visible","numargs","updateAPI"],"sources":["C:/Users/ROG/ai-solver/node_modules/nerdamer/Calculus.js"],"sourcesContent":["/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif((typeof module) !== 'undefined' && typeof nerdamer === 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b√2∜b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else if(p === 1/2 && x.power.equals(2) && a.greaterThan(0)) {\r\n                                // TODO: Revisit\r\n                                __.integration.stop();\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.updateAPI();\r\n\r\n})();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}