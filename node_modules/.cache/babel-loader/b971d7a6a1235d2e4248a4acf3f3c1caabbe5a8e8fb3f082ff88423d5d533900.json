{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../../../utils/factory.js';\nvar name = 'qr';\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'complex'];\nexport var createQr = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    zeros,\n    identity,\n    isZero,\n    equal,\n    sign,\n    sqrt,\n    conj,\n    unaryMinus,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    complex\n  } = _ref;\n  /**\r\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\r\n   * two matrices (`Q`, `R`) where `Q` is an\r\n   * orthogonal matrix and `R` is an upper triangular matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.qr(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [\r\n   *      [1, -1,  4],\r\n   *      [1,  4, -2],\r\n   *      [1,  4,  2],\r\n   *      [1,  -1, 0]\r\n   *    ]\r\n   *    const result = math.qr(m)\r\n   *    // r = {\r\n   *    //   Q: [\r\n   *    //     [0.5, -0.5,   0.5],\r\n   *    //     [0.5,  0.5,  -0.5],\r\n   *    //     [0.5,  0.5,   0.5],\r\n   *    //     [0.5, -0.5,  -0.5],\r\n   *    //   ],\r\n   *    //   R: [\r\n   *    //     [2, 3,  2],\r\n   *    //     [0, 5, -2],\r\n   *    //     [0, 0,  4],\r\n   *    //     [0, 0,  0]\r\n   *    //   ]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    lup, lusolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array\r\n   * for which to get the QR decomposition.\r\n   *\r\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\r\n   * matrix and R: the upper triangular matrix\r\n   */\n  return _extends(typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseQR(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseQR(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a);\n      // lup, use matrix implementation\n      var r = _denseQR(m);\n      // result\n      return {\n        Q: r.Q.valueOf(),\n        R: r.R.valueOf()\n      };\n    }\n  }), {\n    _denseQRimpl\n  });\n  function _denseQRimpl(m) {\n    // rows & columns (m x n)\n    var rows = m._size[0]; // m\n    var cols = m._size[1]; // n\n\n    var Q = identity([rows], 'dense');\n    var Qdata = Q._data;\n    var R = m.clone();\n    var Rdata = R._data;\n\n    // vars\n    var i, j, k;\n    var w = zeros([rows], '');\n    for (k = 0; k < Math.min(cols, rows); ++k) {\n      /*\r\n       * **k-th Household matrix**\r\n       *\r\n       * The matrix I - 2*v*transpose(v)\r\n       * x     = first column of A\r\n       * x1    = first element of x\r\n       * alpha = x1 / |x1| * |x|\r\n       * e1    = tranpose([1, 0, 0, ...])\r\n       * u     = x - alpha * e1\r\n       * v     = u / |u|\r\n       *\r\n       * Household matrix = I - 2 * v * tranpose(v)\r\n       *\r\n       *  * Initially Q = I and R = A.\r\n       *  * Household matrix is a reflection in a plane normal to v which\r\n       *    will zero out all but the top right element in R.\r\n       *  * Appplying reflection to both Q and R will not change product.\r\n       *  * Repeat this process on the (1,1) minor to get R as an upper\r\n       *    triangular matrix.\r\n       *  * Reflections leave the magnitude of the columns of Q unchanged\r\n       *    so Q remains othoganal.\r\n       *\r\n       */\n\n      var pivot = Rdata[k][k];\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\n      var conjSgn = conj(sgn);\n      var alphaSquared = 0;\n      for (i = k; i < rows; i++) {\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\n      }\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\n      if (!isZero(alpha)) {\n        // first element in vector u\n        var u1 = subtractScalar(pivot, alpha);\n\n        // w = v * u1 / |u|    (only elements k to (rows-1) are used)\n        w[k] = 1;\n        for (i = k + 1; i < rows; i++) {\n          w[i] = divideScalar(Rdata[i][k], u1);\n        }\n\n        // tau = - conj(u1 / alpha)\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\n        var s = void 0;\n\n        /*\r\n         * tau and w have been choosen so that\r\n         *\r\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\r\n         */\n\n        /*\r\n         * -- calculate R = R - tau * w * tranpose(w) * R --\r\n         * Only do calculation with rows k to (rows-1)\r\n         * Additionally columns 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\n        for (j = k; j < cols; j++) {\n          s = 0.0;\n\n          // calculate jth element of [tranpose(w) * R]\n          for (i = k; i < rows; i++) {\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\n          }\n\n          // calculate the jth element of [tau * transpose(w) * R]\n          s = multiplyScalar(s, tau);\n          for (i = k; i < rows; i++) {\n            Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\n          }\n        }\n        /*\r\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\r\n         * Q is a square matrix (rows x rows)\r\n         * Only do calculation with columns k to (rows-1)\r\n         * Additionally rows 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\n        for (i = 0; i < rows; i++) {\n          s = 0.0;\n\n          // calculate ith element of [Q * w]\n          for (j = k; j < rows; j++) {\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\n          }\n\n          // calculate the ith element of [tau * Q * w]\n          s = multiplyScalar(s, tau);\n          for (j = k; j < rows; ++j) {\n            Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\n          }\n        }\n      }\n    }\n\n    // return matrices\n    return {\n      Q,\n      R,\n      toString: function toString() {\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\n      }\n    };\n  }\n  function _denseQR(m) {\n    var ret = _denseQRimpl(m);\n    var Rdata = ret.R._data;\n    if (m._data.length > 0) {\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\n      for (var i = 0; i < Rdata.length; ++i) {\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\n          Rdata[i][j] = zero;\n        }\n      }\n    }\n    return ret;\n  }\n  function _sparseQR(m) {\n    throw new Error('qr not implemented for sparse matrices yet');\n  }\n});","map":{"version":3,"names":["_extends","factory","name","dependencies","createQr","_ref","typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtractScalar","complex","DenseMatrix","m","_denseQR","SparseMatrix","_sparseQR","Array","a","r","Q","valueOf","R","_denseQRimpl","rows","_size","cols","Qdata","_data","clone","Rdata","i","j","k","w","Math","min","pivot","sgn","conjSgn","alphaSquared","alpha","u1","tau","s","toString","ret","length","zero","type","Error"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\r\nimport { factory } from '../../../utils/factory.js';\r\nvar name = 'qr';\r\nvar dependencies = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'complex'];\r\nexport var createQr = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    zeros,\r\n    identity,\r\n    isZero,\r\n    equal,\r\n    sign,\r\n    sqrt,\r\n    conj,\r\n    unaryMinus,\r\n    addScalar,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtractScalar,\r\n    complex\r\n  } = _ref;\r\n  /**\r\n   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in\r\n   * two matrices (`Q`, `R`) where `Q` is an\r\n   * orthogonal matrix and `R` is an upper triangular matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.qr(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [\r\n   *      [1, -1,  4],\r\n   *      [1,  4, -2],\r\n   *      [1,  4,  2],\r\n   *      [1,  -1, 0]\r\n   *    ]\r\n   *    const result = math.qr(m)\r\n   *    // r = {\r\n   *    //   Q: [\r\n   *    //     [0.5, -0.5,   0.5],\r\n   *    //     [0.5,  0.5,  -0.5],\r\n   *    //     [0.5,  0.5,   0.5],\r\n   *    //     [0.5, -0.5,  -0.5],\r\n   *    //   ],\r\n   *    //   R: [\r\n   *    //     [2, 3,  2],\r\n   *    //     [0, 5, -2],\r\n   *    //     [0, 0,  4],\r\n   *    //     [0, 0,  0]\r\n   *    //   ]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    lup, lusolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array\r\n   * for which to get the QR decomposition.\r\n   *\r\n   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal\r\n   * matrix and R: the upper triangular matrix\r\n   */\r\n  return _extends(typed(name, {\r\n    DenseMatrix: function DenseMatrix(m) {\r\n      return _denseQR(m);\r\n    },\r\n    SparseMatrix: function SparseMatrix(m) {\r\n      return _sparseQR(m);\r\n    },\r\n    Array: function Array(a) {\r\n      // create dense matrix from array\r\n      var m = matrix(a);\r\n      // lup, use matrix implementation\r\n      var r = _denseQR(m);\r\n      // result\r\n      return {\r\n        Q: r.Q.valueOf(),\r\n        R: r.R.valueOf()\r\n      };\r\n    }\r\n  }), {\r\n    _denseQRimpl\r\n  });\r\n  function _denseQRimpl(m) {\r\n    // rows & columns (m x n)\r\n    var rows = m._size[0]; // m\r\n    var cols = m._size[1]; // n\r\n\r\n    var Q = identity([rows], 'dense');\r\n    var Qdata = Q._data;\r\n    var R = m.clone();\r\n    var Rdata = R._data;\r\n\r\n    // vars\r\n    var i, j, k;\r\n    var w = zeros([rows], '');\r\n    for (k = 0; k < Math.min(cols, rows); ++k) {\r\n      /*\r\n       * **k-th Household matrix**\r\n       *\r\n       * The matrix I - 2*v*transpose(v)\r\n       * x     = first column of A\r\n       * x1    = first element of x\r\n       * alpha = x1 / |x1| * |x|\r\n       * e1    = tranpose([1, 0, 0, ...])\r\n       * u     = x - alpha * e1\r\n       * v     = u / |u|\r\n       *\r\n       * Household matrix = I - 2 * v * tranpose(v)\r\n       *\r\n       *  * Initially Q = I and R = A.\r\n       *  * Household matrix is a reflection in a plane normal to v which\r\n       *    will zero out all but the top right element in R.\r\n       *  * Appplying reflection to both Q and R will not change product.\r\n       *  * Repeat this process on the (1,1) minor to get R as an upper\r\n       *    triangular matrix.\r\n       *  * Reflections leave the magnitude of the columns of Q unchanged\r\n       *    so Q remains othoganal.\r\n       *\r\n       */\r\n\r\n      var pivot = Rdata[k][k];\r\n      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));\r\n      var conjSgn = conj(sgn);\r\n      var alphaSquared = 0;\r\n      for (i = k; i < rows; i++) {\r\n        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));\r\n      }\r\n      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));\r\n      if (!isZero(alpha)) {\r\n        // first element in vector u\r\n        var u1 = subtractScalar(pivot, alpha);\r\n\r\n        // w = v * u1 / |u|    (only elements k to (rows-1) are used)\r\n        w[k] = 1;\r\n        for (i = k + 1; i < rows; i++) {\r\n          w[i] = divideScalar(Rdata[i][k], u1);\r\n        }\r\n\r\n        // tau = - conj(u1 / alpha)\r\n        var tau = unaryMinus(conj(divideScalar(u1, alpha)));\r\n        var s = void 0;\r\n\r\n        /*\r\n         * tau and w have been choosen so that\r\n         *\r\n         * 2 * v * tranpose(v) = tau * w * tranpose(w)\r\n         */\r\n\r\n        /*\r\n         * -- calculate R = R - tau * w * tranpose(w) * R --\r\n         * Only do calculation with rows k to (rows-1)\r\n         * Additionally columns 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\r\n        for (j = k; j < cols; j++) {\r\n          s = 0.0;\r\n\r\n          // calculate jth element of [tranpose(w) * R]\r\n          for (i = k; i < rows; i++) {\r\n            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));\r\n          }\r\n\r\n          // calculate the jth element of [tau * transpose(w) * R]\r\n          s = multiplyScalar(s, tau);\r\n          for (i = k; i < rows; i++) {\r\n            Rdata[i][j] = multiplyScalar(subtractScalar(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);\r\n          }\r\n        }\r\n        /*\r\n         * -- calculate Q = Q - tau * Q * w * transpose(w) --\r\n         * Q is a square matrix (rows x rows)\r\n         * Only do calculation with columns k to (rows-1)\r\n         * Additionally rows 0 to (k-1) will not be changed by this\r\n         *   multiplication so do not bother recalculating them\r\n         */\r\n        for (i = 0; i < rows; i++) {\r\n          s = 0.0;\r\n\r\n          // calculate ith element of [Q * w]\r\n          for (j = k; j < rows; j++) {\r\n            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));\r\n          }\r\n\r\n          // calculate the ith element of [tau * Q * w]\r\n          s = multiplyScalar(s, tau);\r\n          for (j = k; j < rows; ++j) {\r\n            Qdata[i][j] = divideScalar(subtractScalar(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // return matrices\r\n    return {\r\n      Q,\r\n      R,\r\n      toString: function toString() {\r\n        return 'Q: ' + this.Q.toString() + '\\nR: ' + this.R.toString();\r\n      }\r\n    };\r\n  }\r\n  function _denseQR(m) {\r\n    var ret = _denseQRimpl(m);\r\n    var Rdata = ret.R._data;\r\n    if (m._data.length > 0) {\r\n      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;\r\n      for (var i = 0; i < Rdata.length; ++i) {\r\n        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {\r\n          Rdata[i][j] = zero;\r\n        }\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n  function _sparseQR(m) {\r\n    throw new Error('qr not implemented for sparse matrices yet');\r\n  }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}