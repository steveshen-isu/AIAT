{"ast":null,"code":"import naturalSort from 'javascript-natural-sort';\nimport { isDenseMatrix, isSparseMatrix, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'compareNatural';\nvar dependencies = ['typed', 'compare'];\nexport var createCompareNatural = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    compare\n  } = _ref;\n  var compareBooleans = compare.signatures['boolean,boolean'];\n\n  /**\r\n   * Compare two values of any type in a deterministic, natural way.\r\n   *\r\n   * For numeric values, the function works the same as `math.compare`.\r\n   * For types of values that can't be compared mathematically,\r\n   * the function compares in a natural way.\r\n   *\r\n   * For numeric values, x and y are considered equal when the relative\r\n   * difference between x and y is smaller than the configured relTol and absTol.\r\n   * The function cannot be used to compare values smaller than\r\n   * approximately 2.22e-16.\r\n   *\r\n   * For Complex numbers, first the real parts are compared. If equal,\r\n   * the imaginary parts are compared.\r\n   *\r\n   * Strings are compared with a natural sorting algorithm, which\r\n   * orders strings in a \"logic\" way following some heuristics.\r\n   * This differs from the function `compare`, which converts the string\r\n   * into a numeric value and compares that. The function `compareText`\r\n   * on the other hand compares text lexically.\r\n   *\r\n   * Arrays and Matrices are compared value by value until there is an\r\n   * unequal pair of values encountered. Objects are compared by sorted\r\n   * keys until the keys or their values are unequal.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.compareNatural(x, y)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.compareNatural(6, 1)              // returns 1\r\n   *    math.compareNatural(2, 3)              // returns -1\r\n   *    math.compareNatural(7, 7)              // returns 0\r\n   *\r\n   *    math.compareNatural('10', '2')         // returns 1\r\n   *    math.compareText('10', '2')            // returns -1\r\n   *    math.compare('10', '2')                // returns 1\r\n   *\r\n   *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1\r\n   *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1\r\n   *    math.compare('Answer: 10', 'Answer: 2')\r\n   *        // Error: Cannot convert \"Answer: 10\" to a number\r\n   *\r\n   *    const a = math.unit('5 cm')\r\n   *    const b = math.unit('40 mm')\r\n   *    math.compareNatural(a, b)              // returns 1\r\n   *\r\n   *    const c = math.complex('2 + 3i')\r\n   *    const d = math.complex('2 + 4i')\r\n   *    math.compareNatural(c, d)              // returns -1\r\n   *\r\n   *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1\r\n   *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1\r\n   *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1\r\n   *    math.compareNatural([1, 2], [1, 2])       // returns 0\r\n   *\r\n   *    math.compareNatural({a: 2}, {a: 4})       // returns -1\r\n   *\r\n   * See also:\r\n   *\r\n   *    compare, compareText\r\n   *\r\n   * @param  {*} x First value to compare\r\n   * @param  {*} y Second value to compare\r\n   * @return {number} Returns the result of the comparison:\r\n   *                  1 when x > y, -1 when x < y, and 0 when x == y.\r\n   */\n  return typed(name, {\n    'any, any': _compareNatural\n  }); // just to check # args\n\n  function _compareNatural(x, y) {\n    var typeX = typeOf(x);\n    var typeY = typeOf(y);\n    var c;\n\n    // numeric types\n    if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {\n      c = compare(x, y);\n      if (c.toString() !== '0') {\n        // c can be number, BigNumber, or Fraction\n        return c > 0 ? 1 : -1; // return a number\n      } else {\n        return naturalSort(typeX, typeY);\n      }\n    }\n\n    // matrix types\n    var matTypes = ['Array', 'DenseMatrix', 'SparseMatrix'];\n    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {\n      c = compareMatricesAndArrays(_compareNatural, x, y);\n      if (c !== 0) {\n        return c;\n      } else {\n        return naturalSort(typeX, typeY);\n      }\n    }\n\n    // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'\n    if (typeX !== typeY) {\n      return naturalSort(typeX, typeY);\n    }\n    if (typeX === 'Complex') {\n      return compareComplexNumbers(x, y);\n    }\n    if (typeX === 'Unit') {\n      if (x.equalBase(y)) {\n        return _compareNatural(x.value, y.value);\n      }\n\n      // compare by units\n      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());\n    }\n    if (typeX === 'boolean') {\n      return compareBooleans(x, y);\n    }\n    if (typeX === 'string') {\n      return naturalSort(x, y);\n    }\n    if (typeX === 'Object') {\n      return compareObjects(_compareNatural, x, y);\n    }\n    if (typeX === 'null') {\n      return 0;\n    }\n    if (typeX === 'undefined') {\n      return 0;\n    }\n\n    // this should not occur...\n    throw new TypeError('Unsupported type of value \"' + typeX + '\"');\n  }\n\n  /**\r\n   * Compare mixed matrix/array types, by converting to same-shaped array.\r\n   * This comparator is non-deterministic regarding input types.\r\n   * @param {Array | SparseMatrix | DenseMatrix | *} x\r\n   * @param {Array | SparseMatrix | DenseMatrix | *} y\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\n  function compareMatricesAndArrays(compareNatural, x, y) {\n    if (isSparseMatrix(x) && isSparseMatrix(y)) {\n      return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);\n    }\n    if (isSparseMatrix(x)) {\n      // note: convert to array is expensive\n      return compareMatricesAndArrays(compareNatural, x.toArray(), y);\n    }\n    if (isSparseMatrix(y)) {\n      // note: convert to array is expensive\n      return compareMatricesAndArrays(compareNatural, x, y.toArray());\n    }\n\n    // convert DenseArray into Array\n    if (isDenseMatrix(x)) {\n      return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);\n    }\n    if (isDenseMatrix(y)) {\n      return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);\n    }\n\n    // convert scalars to array\n    if (!Array.isArray(x)) {\n      return compareMatricesAndArrays(compareNatural, [x], y);\n    }\n    if (!Array.isArray(y)) {\n      return compareMatricesAndArrays(compareNatural, x, [y]);\n    }\n    return compareArrays(compareNatural, x, y);\n  }\n\n  /**\r\n   * Compare two Arrays\r\n   *\r\n   * - First, compares value by value\r\n   * - Next, if all corresponding values are equal,\r\n   *   look at the length: longest array will be considered largest\r\n   *\r\n   * @param {Array} x\r\n   * @param {Array} y\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\n  function compareArrays(compareNatural, x, y) {\n    // compare each value\n    for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {\n      var v = compareNatural(x[i], y[i]);\n      if (v !== 0) {\n        return v;\n      }\n    }\n\n    // compare the size of the arrays\n    if (x.length > y.length) {\n      return 1;\n    }\n    if (x.length < y.length) {\n      return -1;\n    }\n\n    // both Arrays have equal size and content\n    return 0;\n  }\n\n  /**\r\n   * Compare two objects\r\n   *\r\n   * - First, compare sorted property names\r\n   * - Next, compare the property values\r\n   *\r\n   * @param {Object} x\r\n   * @param {Object} y\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\n  function compareObjects(compareNatural, x, y) {\n    var keysX = Object.keys(x);\n    var keysY = Object.keys(y);\n\n    // compare keys\n    keysX.sort(naturalSort);\n    keysY.sort(naturalSort);\n    var c = compareArrays(compareNatural, keysX, keysY);\n    if (c !== 0) {\n      return c;\n    }\n\n    // compare values\n    for (var i = 0; i < keysX.length; i++) {\n      var v = compareNatural(x[keysX[i]], y[keysY[i]]);\n      if (v !== 0) {\n        return v;\n      }\n    }\n    return 0;\n  }\n});\n\n/**\r\n * Compare two complex numbers, `x` and `y`:\r\n *\r\n * - First, compare the real values of `x` and `y`\r\n * - If equal, compare the imaginary values of `x` and `y`\r\n *\r\n * @params {Complex} x\r\n * @params {Complex} y\r\n * @returns {number} Returns the comparison result: -1, 0, or 1\r\n */\nfunction compareComplexNumbers(x, y) {\n  if (x.re > y.re) {\n    return 1;\n  }\n  if (x.re < y.re) {\n    return -1;\n  }\n  if (x.im > y.im) {\n    return 1;\n  }\n  if (x.im < y.im) {\n    return -1;\n  }\n  return 0;\n}","map":{"version":3,"names":["naturalSort","isDenseMatrix","isSparseMatrix","typeOf","factory","name","dependencies","createCompareNatural","_ref","typed","compare","compareBooleans","signatures","_compareNatural","x","y","typeX","typeY","c","toString","matTypes","includes","compareMatricesAndArrays","compareComplexNumbers","equalBase","value","compareArrays","formatUnits","compareObjects","TypeError","compareNatural","toJSON","values","toArray","data","Array","isArray","i","ii","Math","min","length","v","keysX","Object","keys","keysY","sort","re","im"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/relational/compareNatural.js"],"sourcesContent":["import naturalSort from 'javascript-natural-sort';\r\nimport { isDenseMatrix, isSparseMatrix, typeOf } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'compareNatural';\r\nvar dependencies = ['typed', 'compare'];\r\nexport var createCompareNatural = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    compare\r\n  } = _ref;\r\n  var compareBooleans = compare.signatures['boolean,boolean'];\r\n\r\n  /**\r\n   * Compare two values of any type in a deterministic, natural way.\r\n   *\r\n   * For numeric values, the function works the same as `math.compare`.\r\n   * For types of values that can't be compared mathematically,\r\n   * the function compares in a natural way.\r\n   *\r\n   * For numeric values, x and y are considered equal when the relative\r\n   * difference between x and y is smaller than the configured relTol and absTol.\r\n   * The function cannot be used to compare values smaller than\r\n   * approximately 2.22e-16.\r\n   *\r\n   * For Complex numbers, first the real parts are compared. If equal,\r\n   * the imaginary parts are compared.\r\n   *\r\n   * Strings are compared with a natural sorting algorithm, which\r\n   * orders strings in a \"logic\" way following some heuristics.\r\n   * This differs from the function `compare`, which converts the string\r\n   * into a numeric value and compares that. The function `compareText`\r\n   * on the other hand compares text lexically.\r\n   *\r\n   * Arrays and Matrices are compared value by value until there is an\r\n   * unequal pair of values encountered. Objects are compared by sorted\r\n   * keys until the keys or their values are unequal.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.compareNatural(x, y)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.compareNatural(6, 1)              // returns 1\r\n   *    math.compareNatural(2, 3)              // returns -1\r\n   *    math.compareNatural(7, 7)              // returns 0\r\n   *\r\n   *    math.compareNatural('10', '2')         // returns 1\r\n   *    math.compareText('10', '2')            // returns -1\r\n   *    math.compare('10', '2')                // returns 1\r\n   *\r\n   *    math.compareNatural('Answer: 10', 'Answer: 2') // returns 1\r\n   *    math.compareText('Answer: 10', 'Answer: 2')    // returns -1\r\n   *    math.compare('Answer: 10', 'Answer: 2')\r\n   *        // Error: Cannot convert \"Answer: 10\" to a number\r\n   *\r\n   *    const a = math.unit('5 cm')\r\n   *    const b = math.unit('40 mm')\r\n   *    math.compareNatural(a, b)              // returns 1\r\n   *\r\n   *    const c = math.complex('2 + 3i')\r\n   *    const d = math.complex('2 + 4i')\r\n   *    math.compareNatural(c, d)              // returns -1\r\n   *\r\n   *    math.compareNatural([1, 2, 4], [1, 2, 3]) // returns 1\r\n   *    math.compareNatural([1, 2, 3], [1, 2])    // returns 1\r\n   *    math.compareNatural([1, 5], [1, 2, 3])    // returns 1\r\n   *    math.compareNatural([1, 2], [1, 2])       // returns 0\r\n   *\r\n   *    math.compareNatural({a: 2}, {a: 4})       // returns -1\r\n   *\r\n   * See also:\r\n   *\r\n   *    compare, compareText\r\n   *\r\n   * @param  {*} x First value to compare\r\n   * @param  {*} y Second value to compare\r\n   * @return {number} Returns the result of the comparison:\r\n   *                  1 when x > y, -1 when x < y, and 0 when x == y.\r\n   */\r\n  return typed(name, {\r\n    'any, any': _compareNatural\r\n  }); // just to check # args\r\n\r\n  function _compareNatural(x, y) {\r\n    var typeX = typeOf(x);\r\n    var typeY = typeOf(y);\r\n    var c;\r\n\r\n    // numeric types\r\n    if ((typeX === 'number' || typeX === 'BigNumber' || typeX === 'Fraction') && (typeY === 'number' || typeY === 'BigNumber' || typeY === 'Fraction')) {\r\n      c = compare(x, y);\r\n      if (c.toString() !== '0') {\r\n        // c can be number, BigNumber, or Fraction\r\n        return c > 0 ? 1 : -1; // return a number\r\n      } else {\r\n        return naturalSort(typeX, typeY);\r\n      }\r\n    }\r\n\r\n    // matrix types\r\n    var matTypes = ['Array', 'DenseMatrix', 'SparseMatrix'];\r\n    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {\r\n      c = compareMatricesAndArrays(_compareNatural, x, y);\r\n      if (c !== 0) {\r\n        return c;\r\n      } else {\r\n        return naturalSort(typeX, typeY);\r\n      }\r\n    }\r\n\r\n    // in case of different types, order by name of type, i.e. 'BigNumber' < 'Complex'\r\n    if (typeX !== typeY) {\r\n      return naturalSort(typeX, typeY);\r\n    }\r\n    if (typeX === 'Complex') {\r\n      return compareComplexNumbers(x, y);\r\n    }\r\n    if (typeX === 'Unit') {\r\n      if (x.equalBase(y)) {\r\n        return _compareNatural(x.value, y.value);\r\n      }\r\n\r\n      // compare by units\r\n      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());\r\n    }\r\n    if (typeX === 'boolean') {\r\n      return compareBooleans(x, y);\r\n    }\r\n    if (typeX === 'string') {\r\n      return naturalSort(x, y);\r\n    }\r\n    if (typeX === 'Object') {\r\n      return compareObjects(_compareNatural, x, y);\r\n    }\r\n    if (typeX === 'null') {\r\n      return 0;\r\n    }\r\n    if (typeX === 'undefined') {\r\n      return 0;\r\n    }\r\n\r\n    // this should not occur...\r\n    throw new TypeError('Unsupported type of value \"' + typeX + '\"');\r\n  }\r\n\r\n  /**\r\n   * Compare mixed matrix/array types, by converting to same-shaped array.\r\n   * This comparator is non-deterministic regarding input types.\r\n   * @param {Array | SparseMatrix | DenseMatrix | *} x\r\n   * @param {Array | SparseMatrix | DenseMatrix | *} y\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\r\n  function compareMatricesAndArrays(compareNatural, x, y) {\r\n    if (isSparseMatrix(x) && isSparseMatrix(y)) {\r\n      return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);\r\n    }\r\n    if (isSparseMatrix(x)) {\r\n      // note: convert to array is expensive\r\n      return compareMatricesAndArrays(compareNatural, x.toArray(), y);\r\n    }\r\n    if (isSparseMatrix(y)) {\r\n      // note: convert to array is expensive\r\n      return compareMatricesAndArrays(compareNatural, x, y.toArray());\r\n    }\r\n\r\n    // convert DenseArray into Array\r\n    if (isDenseMatrix(x)) {\r\n      return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);\r\n    }\r\n    if (isDenseMatrix(y)) {\r\n      return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);\r\n    }\r\n\r\n    // convert scalars to array\r\n    if (!Array.isArray(x)) {\r\n      return compareMatricesAndArrays(compareNatural, [x], y);\r\n    }\r\n    if (!Array.isArray(y)) {\r\n      return compareMatricesAndArrays(compareNatural, x, [y]);\r\n    }\r\n    return compareArrays(compareNatural, x, y);\r\n  }\r\n\r\n  /**\r\n   * Compare two Arrays\r\n   *\r\n   * - First, compares value by value\r\n   * - Next, if all corresponding values are equal,\r\n   *   look at the length: longest array will be considered largest\r\n   *\r\n   * @param {Array} x\r\n   * @param {Array} y\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\r\n  function compareArrays(compareNatural, x, y) {\r\n    // compare each value\r\n    for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {\r\n      var v = compareNatural(x[i], y[i]);\r\n      if (v !== 0) {\r\n        return v;\r\n      }\r\n    }\r\n\r\n    // compare the size of the arrays\r\n    if (x.length > y.length) {\r\n      return 1;\r\n    }\r\n    if (x.length < y.length) {\r\n      return -1;\r\n    }\r\n\r\n    // both Arrays have equal size and content\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Compare two objects\r\n   *\r\n   * - First, compare sorted property names\r\n   * - Next, compare the property values\r\n   *\r\n   * @param {Object} x\r\n   * @param {Object} y\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\r\n  function compareObjects(compareNatural, x, y) {\r\n    var keysX = Object.keys(x);\r\n    var keysY = Object.keys(y);\r\n\r\n    // compare keys\r\n    keysX.sort(naturalSort);\r\n    keysY.sort(naturalSort);\r\n    var c = compareArrays(compareNatural, keysX, keysY);\r\n    if (c !== 0) {\r\n      return c;\r\n    }\r\n\r\n    // compare values\r\n    for (var i = 0; i < keysX.length; i++) {\r\n      var v = compareNatural(x[keysX[i]], y[keysY[i]]);\r\n      if (v !== 0) {\r\n        return v;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n});\r\n\r\n/**\r\n * Compare two complex numbers, `x` and `y`:\r\n *\r\n * - First, compare the real values of `x` and `y`\r\n * - If equal, compare the imaginary values of `x` and `y`\r\n *\r\n * @params {Complex} x\r\n * @params {Complex} y\r\n * @returns {number} Returns the comparison result: -1, 0, or 1\r\n */\r\nfunction compareComplexNumbers(x, y) {\r\n  if (x.re > y.re) {\r\n    return 1;\r\n  }\r\n  if (x.re < y.re) {\r\n    return -1;\r\n  }\r\n  if (x.im > y.im) {\r\n    return 1;\r\n  }\r\n  if (x.im < y.im) {\r\n    return -1;\r\n  }\r\n  return 0;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}