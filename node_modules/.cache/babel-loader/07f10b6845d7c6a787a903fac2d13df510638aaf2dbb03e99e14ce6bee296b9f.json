{"ast":null,"code":"import { isArray, isMatrix } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nimport { csIpvec } from '../sparse/csIpvec.js';\nvar name = 'lusolve';\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\nexport var createLusolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    lup,\n    slu,\n    usolve,\n    lsolve,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n\n  /**\r\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\r\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\r\n   *\r\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\r\n   *\r\n   *    const f = math.lup(m)\r\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\r\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    lup, slu, lsolve, usolve\r\n   *\r\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\r\n   * @param {Matrix | Array} b               Column Vector\r\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\r\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\r\n   *\r\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\r\n   */\n  return typed(name, {\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\n      a = matrix(a);\n      var d = lup(a);\n      var x = _lusolve(d.L, d.U, d.p, null, b);\n      return x.valueOf();\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(a, b) {\n      var d = lup(a);\n      return _lusolve(d.L, d.U, d.p, null, b);\n    },\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {\n      var d = slu(a, order, threshold);\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    },\n    'Object, Array | Matrix': function Object_Array__Matrix(d, b) {\n      return _lusolve(d.L, d.U, d.p, d.q, b);\n    }\n  });\n  function _toMatrix(a) {\n    if (isMatrix(a)) {\n      return a;\n    }\n    if (isArray(a)) {\n      return matrix(a);\n    }\n    throw new TypeError('Invalid Matrix LU decomposition');\n  }\n  function _lusolve(l, u, p, q, b) {\n    // verify decomposition\n    l = _toMatrix(l);\n    u = _toMatrix(u);\n\n    // apply row permutations if needed (b is a DenseMatrix)\n    if (p) {\n      b = solveValidation(l, b, true);\n      b._data = csIpvec(p, b._data);\n    }\n\n    // use forward substitution to resolve L * y = b\n    var y = lsolve(l, b);\n    // use backward substitution to resolve U * x = y\n    var x = usolve(u, y);\n\n    // apply column permutations if needed (x is a DenseMatrix)\n    if (q) {\n      x._data = csIpvec(q, x._data);\n    }\n    return x;\n  }\n});","map":{"version":3,"names":["isArray","isMatrix","factory","createSolveValidation","csIpvec","name","dependencies","createLusolve","_ref","typed","matrix","lup","slu","usolve","lsolve","DenseMatrix","solveValidation","Array_Array__Matrix","a","b","d","x","_lusolve","L","U","p","valueOf","DenseMatrix_Array__Matrix","SparseMatrix_Array__Matrix","SparseMatrix_Array__Matrix_number_number","order","threshold","q","Object_Array__Matrix","_toMatrix","TypeError","l","u","_data","y"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js"],"sourcesContent":["import { isArray, isMatrix } from '../../../utils/is.js';\r\nimport { factory } from '../../../utils/factory.js';\r\nimport { createSolveValidation } from './utils/solveValidation.js';\r\nimport { csIpvec } from '../sparse/csIpvec.js';\r\nvar name = 'lusolve';\r\nvar dependencies = ['typed', 'matrix', 'lup', 'slu', 'usolve', 'lsolve', 'DenseMatrix'];\r\nexport var createLusolve = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    lup,\r\n    slu,\r\n    usolve,\r\n    lsolve,\r\n    DenseMatrix\r\n  } = _ref;\r\n  var solveValidation = createSolveValidation({\r\n    DenseMatrix\r\n  });\r\n\r\n  /**\r\n   * Solves the linear system `A * x = b` where `A` is an [n x n] matrix and `b` is a [n] column vector.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b\r\n   *    math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]\r\n   *\r\n   *    const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]\r\n   *\r\n   *    const f = math.lup(m)\r\n   *    const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]\r\n   *    const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = math.lusolve(a, b)  // [[2], [5]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    lup, slu, lsolve, usolve\r\n   *\r\n   * @param {Matrix | Array | Object} A      Invertible Matrix or the Matrix LU decomposition\r\n   * @param {Matrix | Array} b               Column Vector\r\n   * @param {number} [order]                 The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix\r\n   * @param {Number} [threshold]             Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.\r\n   *\r\n   * @return {DenseMatrix | Array}           Column vector with the solution to the linear system A * x = b\r\n   */\r\n  return typed(name, {\r\n    'Array, Array | Matrix': function Array_Array__Matrix(a, b) {\r\n      a = matrix(a);\r\n      var d = lup(a);\r\n      var x = _lusolve(d.L, d.U, d.p, null, b);\r\n      return x.valueOf();\r\n    },\r\n    'DenseMatrix, Array | Matrix': function DenseMatrix_Array__Matrix(a, b) {\r\n      var d = lup(a);\r\n      return _lusolve(d.L, d.U, d.p, null, b);\r\n    },\r\n    'SparseMatrix, Array | Matrix': function SparseMatrix_Array__Matrix(a, b) {\r\n      var d = lup(a);\r\n      return _lusolve(d.L, d.U, d.p, null, b);\r\n    },\r\n    'SparseMatrix, Array | Matrix, number, number': function SparseMatrix_Array__Matrix_number_number(a, b, order, threshold) {\r\n      var d = slu(a, order, threshold);\r\n      return _lusolve(d.L, d.U, d.p, d.q, b);\r\n    },\r\n    'Object, Array | Matrix': function Object_Array__Matrix(d, b) {\r\n      return _lusolve(d.L, d.U, d.p, d.q, b);\r\n    }\r\n  });\r\n  function _toMatrix(a) {\r\n    if (isMatrix(a)) {\r\n      return a;\r\n    }\r\n    if (isArray(a)) {\r\n      return matrix(a);\r\n    }\r\n    throw new TypeError('Invalid Matrix LU decomposition');\r\n  }\r\n  function _lusolve(l, u, p, q, b) {\r\n    // verify decomposition\r\n    l = _toMatrix(l);\r\n    u = _toMatrix(u);\r\n\r\n    // apply row permutations if needed (b is a DenseMatrix)\r\n    if (p) {\r\n      b = solveValidation(l, b, true);\r\n      b._data = csIpvec(p, b._data);\r\n    }\r\n\r\n    // use forward substitution to resolve L * y = b\r\n    var y = lsolve(l, b);\r\n    // use backward substitution to resolve U * x = y\r\n    var x = usolve(u, y);\r\n\r\n    // apply column permutations if needed (x is a DenseMatrix)\r\n    if (q) {\r\n      x._data = csIpvec(q, x._data);\r\n    }\r\n    return x;\r\n  }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}