{"ast":null,"code":"import { pickShallow } from './object.js';\n\n/**\r\n * Create a factory function, which can be used to inject dependencies.\r\n *\r\n * The created functions are memoized, a consecutive call of the factory\r\n * with the exact same inputs will return the same function instance.\r\n * The memoized cache is exposed on `factory.cache` and can be cleared\r\n * if needed.\r\n *\r\n * Example:\r\n *\r\n *     const name = 'log'\r\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\r\n *\r\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\r\n *       // ... create the function log here and return it\r\n *     }\r\n *\r\n * @param {string} name           Name of the function to be created\r\n * @param {string[]} dependencies The names of all required dependencies\r\n * @param {function} create       Callback function called with an object with all dependencies\r\n * @param {Object} [meta]         Optional object with meta information that will be attached\r\n *                                to the created factory function as property `meta`.\r\n * @returns {function}\r\n */\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n\n/**\r\n * Sort all factories such that when loading in order, the dependencies are resolved.\r\n *\r\n * @param {Array} factories\r\n * @returns {Array} Returns a new array with the sorted factories.\r\n */\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (factory.dependencies.includes(dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  }\n\n  // sort regular factory functions\n  factories.filter(isFactory).forEach(addFactory);\n\n  // sort legacy factory functions AFTER the regular factory functions\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n}\n\n// TODO: comment or cleanup if unused in the end\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n\n/**\r\n * Test whether an object is a factory. This is the case when it has\r\n * properties name, dependencies, and a function create.\r\n * @param {*} obj\r\n * @returns {boolean}\r\n */\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n\n/**\r\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\r\n *\r\n * Will throw an exception when there are dependencies missing.\r\n *\r\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\r\n * @param {string[]} dependencies\r\n * @param {Object} scope\r\n */\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\n\n    // TODO: create a custom error class for this, a MathjsError or something like that\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","includes","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/utils/factory.js"],"sourcesContent":["import { pickShallow } from './object.js';\r\n\r\n/**\r\n * Create a factory function, which can be used to inject dependencies.\r\n *\r\n * The created functions are memoized, a consecutive call of the factory\r\n * with the exact same inputs will return the same function instance.\r\n * The memoized cache is exposed on `factory.cache` and can be cleared\r\n * if needed.\r\n *\r\n * Example:\r\n *\r\n *     const name = 'log'\r\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\r\n *\r\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\r\n *       // ... create the function log here and return it\r\n *     }\r\n *\r\n * @param {string} name           Name of the function to be created\r\n * @param {string[]} dependencies The names of all required dependencies\r\n * @param {function} create       Callback function called with an object with all dependencies\r\n * @param {Object} [meta]         Optional object with meta information that will be attached\r\n *                                to the created factory function as property `meta`.\r\n * @returns {function}\r\n */\r\nexport function factory(name, dependencies, create, meta) {\r\n  function assertAndCreate(scope) {\r\n    // we only pass the requested dependencies to the factory function\r\n    // to prevent functions to rely on dependencies that are not explicitly\r\n    // requested.\r\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\r\n    assertDependencies(name, dependencies, scope);\r\n    return create(deps);\r\n  }\r\n  assertAndCreate.isFactory = true;\r\n  assertAndCreate.fn = name;\r\n  assertAndCreate.dependencies = dependencies.slice().sort();\r\n  if (meta) {\r\n    assertAndCreate.meta = meta;\r\n  }\r\n  return assertAndCreate;\r\n}\r\n\r\n/**\r\n * Sort all factories such that when loading in order, the dependencies are resolved.\r\n *\r\n * @param {Array} factories\r\n * @returns {Array} Returns a new array with the sorted factories.\r\n */\r\nexport function sortFactories(factories) {\r\n  var factoriesByName = {};\r\n  factories.forEach(factory => {\r\n    factoriesByName[factory.fn] = factory;\r\n  });\r\n  function containsDependency(factory, dependency) {\r\n    // TODO: detect circular references\r\n    if (isFactory(factory)) {\r\n      if (factory.dependencies.includes(dependency.fn || dependency.name)) {\r\n        return true;\r\n      }\r\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  var sorted = [];\r\n  function addFactory(factory) {\r\n    var index = 0;\r\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\r\n      index++;\r\n    }\r\n    sorted.splice(index, 0, factory);\r\n  }\r\n\r\n  // sort regular factory functions\r\n  factories.filter(isFactory).forEach(addFactory);\r\n\r\n  // sort legacy factory functions AFTER the regular factory functions\r\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\r\n  return sorted;\r\n}\r\n\r\n// TODO: comment or cleanup if unused in the end\r\nexport function create(factories) {\r\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  sortFactories(factories).forEach(factory => factory(scope));\r\n  return scope;\r\n}\r\n\r\n/**\r\n * Test whether an object is a factory. This is the case when it has\r\n * properties name, dependencies, and a function create.\r\n * @param {*} obj\r\n * @returns {boolean}\r\n */\r\nexport function isFactory(obj) {\r\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\r\n}\r\n\r\n/**\r\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\r\n *\r\n * Will throw an exception when there are dependencies missing.\r\n *\r\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\r\n * @param {string[]} dependencies\r\n * @param {Object} scope\r\n */\r\nexport function assertDependencies(name, dependencies, scope) {\r\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\r\n  .every(dependency => scope[dependency] !== undefined);\r\n  if (!allDefined) {\r\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\r\n\r\n    // TODO: create a custom error class for this, a MathjsError or something like that\r\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\r\n  }\r\n}\r\nexport function isOptionalDependency(dependency) {\r\n  return dependency && dependency[0] === '?';\r\n}\r\nexport function stripOptionalNotation(dependency) {\r\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}