{"ast":null,"code":"import { clone } from '../../../utils/object.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    abs,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtractScalar,\n    larger,\n    equalScalar,\n    unaryMinus,\n    DenseMatrix,\n    SparseMatrix,\n    Spa\n  } = _ref;\n  /**\r\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\r\n   * row permutation vector `p` where `A[p,:] = L * U`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lup(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [[2, 1], [1, 4]]\r\n   *    const r = math.lup(m)\r\n   *    // r = {\r\n   *    //   L: [[1, 0], [0.5, 1]],\r\n   *    //   U: [[2, 1], [0, 3.5]],\r\n   *    //   P: [0, 1]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    slu, lsolve, lusolve, usolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\r\n   *\r\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\r\n   */\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a);\n      // lup, use matrix implementation\n      var r = _denseLUP(m);\n      // result\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1];\n    // minimum rows and columns\n    var n = Math.min(rows, columns);\n    // matrix array, clone original data\n    var data = clone(m._data);\n    // l matrix arrays\n    var ldata = [];\n    var lsize = [rows, n];\n    // u matrix arrays\n    var udata = [];\n    var usize = [n, columns];\n    // vars\n    var i, j, k;\n    // permutation vector\n    var p = [];\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    }\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j);\n          // v[i, j]\n          var s = 0;\n          // loop up to min\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n          data[i][j] = subtractScalar(data[i][j], s);\n        }\n      }\n      // row with larger value in cvector, row >= j\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0;\n      // loop rows\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j];\n        // absolute value\n        var absv = abs(v);\n        // value is greater than pivote value\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i;\n          // update max value\n          pabsv = absv;\n          // value @ [j, j]\n          vjj = v;\n        }\n      }\n      // swap rows (j <-> pi)\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0];\n        // swap j <-> pi in data\n        DenseMatrix._swapRows(j, pi, data);\n      }\n      // check column is in lower triangular matrix\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    }\n    // loop columns\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          }\n          // L\n          ldata[i] = [];\n        }\n        // check we are in the upper triangular matrix\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          }\n          // check column exists in lower triangular matrix\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n          continue;\n        }\n        // diagonal value\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          }\n          // check column exists in lower triangular matrix\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n          continue;\n        }\n        // check row exists in upper triangular matrix\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        }\n        // check column exists in lower triangular matrix\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    }\n    // l matrix\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    });\n    // u matrix\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    });\n    // p vector\n    var pv = [];\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    }\n    // return matrices\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1];\n    // minimum rows and columns\n    var n = Math.min(rows, columns);\n    // matrix arrays (will not be modified, thanks to permutation vector)\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr;\n    // l matrix arrays\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n];\n    // u matrix arrays\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns];\n    // vars\n    var i, j, k;\n    // permutation vectors, (current index -> original index) and (original index -> current index)\n    var pvCo = [];\n    var pvOc = [];\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    }\n    // swap indices in permutation vectors (condition x < y)!\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y];\n      // update permutation vector current -> original\n      pvCo[kx] = y;\n      pvCo[ky] = x;\n      // update permutation vector original -> current\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    };\n    // loop columns\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa();\n      // check lower triangular matrix has a value @ column j\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length);\n        // first value in j column for lower triangular matrix\n        lvalues.push(1);\n        lindex.push(j);\n      }\n      // update ptr\n      uptr.push(uvalues.length);\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1];\n      // copy column j into sparse accumulator\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k];\n        // copy column values into sparse accumulator (use permutation vector)\n        spa.set(pvCo[i], values[k]);\n      }\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      }\n      // row with larger value in spa, row >= j\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj);\n      // loop values in spa (order by row, below diagonal)\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v);\n        // value is greater than pivote value\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x;\n          // update max value\n          pabsv = absv;\n          // value @ [j, j]\n          vjj = v;\n        }\n      });\n      // swap rows (j <-> pi)\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);\n        // swap values j <-> pi in U\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);\n        // swap values in spa\n        spa.swap(j, pi);\n        // update permutation vector (swap values @ j, pi)\n        swapIndeces(j, pi);\n      }\n      // loop values in spa (order by row)\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj);\n          // check value is non zero\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n    for (j = 0; j < columns; j++) {\n      _loop();\n    }\n    // update ptrs\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length);\n\n    // return matrices\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});","map":{"version":3,"names":["clone","factory","name","dependencies","createLup","_ref","typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtractScalar","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa","m","_denseLUP","_sparseLUP","Array","a","r","L","valueOf","U","p","rows","_size","columns","n","Math","min","data","_data","ldata","lsize","udata","usize","i","j","k","s","pi","pabsv","vjj","v","absv","_swapRows","vij","l","size","u","pv","length","toString","values","_values","index","_index","ptr","_ptr","lvalues","lindex","lptr","uvalues","uindex","uptr","pvCo","pvOc","swapIndeces","x","y","kx","ky","_loop","spa","push","k0","k1","set","forEach","vkj","_forEachRow","vik","accumulate","get","swap"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\r\nimport { factory } from '../../../utils/factory.js';\r\nvar name = 'lup';\r\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtractScalar', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\r\nexport var createLup = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    abs,\r\n    addScalar,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtractScalar,\r\n    larger,\r\n    equalScalar,\r\n    unaryMinus,\r\n    DenseMatrix,\r\n    SparseMatrix,\r\n    Spa\r\n  } = _ref;\r\n  /**\r\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\r\n   * row permutation vector `p` where `A[p,:] = L * U`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lup(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [[2, 1], [1, 4]]\r\n   *    const r = math.lup(m)\r\n   *    // r = {\r\n   *    //   L: [[1, 0], [0.5, 1]],\r\n   *    //   U: [[2, 1], [0, 3.5]],\r\n   *    //   P: [0, 1]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    slu, lsolve, lusolve, usolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\r\n   *\r\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\r\n   */\r\n  return typed(name, {\r\n    DenseMatrix: function DenseMatrix(m) {\r\n      return _denseLUP(m);\r\n    },\r\n    SparseMatrix: function SparseMatrix(m) {\r\n      return _sparseLUP(m);\r\n    },\r\n    Array: function Array(a) {\r\n      // create dense matrix from array\r\n      var m = matrix(a);\r\n      // lup, use matrix implementation\r\n      var r = _denseLUP(m);\r\n      // result\r\n      return {\r\n        L: r.L.valueOf(),\r\n        U: r.U.valueOf(),\r\n        p: r.p\r\n      };\r\n    }\r\n  });\r\n  function _denseLUP(m) {\r\n    // rows & columns\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    // minimum rows and columns\r\n    var n = Math.min(rows, columns);\r\n    // matrix array, clone original data\r\n    var data = clone(m._data);\r\n    // l matrix arrays\r\n    var ldata = [];\r\n    var lsize = [rows, n];\r\n    // u matrix arrays\r\n    var udata = [];\r\n    var usize = [n, columns];\r\n    // vars\r\n    var i, j, k;\r\n    // permutation vector\r\n    var p = [];\r\n    for (i = 0; i < rows; i++) {\r\n      p[i] = i;\r\n    }\r\n    // loop columns\r\n    for (j = 0; j < columns; j++) {\r\n      // skip first column in upper triangular matrix\r\n      if (j > 0) {\r\n        // loop rows\r\n        for (i = 0; i < rows; i++) {\r\n          // min i,j\r\n          var min = Math.min(i, j);\r\n          // v[i, j]\r\n          var s = 0;\r\n          // loop up to min\r\n          for (k = 0; k < min; k++) {\r\n            // s = l[i, k] - data[k, j]\r\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\r\n          }\r\n          data[i][j] = subtractScalar(data[i][j], s);\r\n        }\r\n      }\r\n      // row with larger value in cvector, row >= j\r\n      var pi = j;\r\n      var pabsv = 0;\r\n      var vjj = 0;\r\n      // loop rows\r\n      for (i = j; i < rows; i++) {\r\n        // data @ i, j\r\n        var v = data[i][j];\r\n        // absolute value\r\n        var absv = abs(v);\r\n        // value is greater than pivote value\r\n        if (larger(absv, pabsv)) {\r\n          // store row\r\n          pi = i;\r\n          // update max value\r\n          pabsv = absv;\r\n          // value @ [j, j]\r\n          vjj = v;\r\n        }\r\n      }\r\n      // swap rows (j <-> pi)\r\n      if (j !== pi) {\r\n        // swap values j <-> pi in p\r\n        p[j] = [p[pi], p[pi] = p[j]][0];\r\n        // swap j <-> pi in data\r\n        DenseMatrix._swapRows(j, pi, data);\r\n      }\r\n      // check column is in lower triangular matrix\r\n      if (j < rows) {\r\n        // loop rows (lower triangular matrix)\r\n        for (i = j + 1; i < rows; i++) {\r\n          // value @ i, j\r\n          var vij = data[i][j];\r\n          if (!equalScalar(vij, 0)) {\r\n            // update data\r\n            data[i][j] = divideScalar(data[i][j], vjj);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // loop columns\r\n    for (j = 0; j < columns; j++) {\r\n      // loop rows\r\n      for (i = 0; i < rows; i++) {\r\n        // initialize row in arrays\r\n        if (j === 0) {\r\n          // check row exists in upper triangular matrix\r\n          if (i < columns) {\r\n            // U\r\n            udata[i] = [];\r\n          }\r\n          // L\r\n          ldata[i] = [];\r\n        }\r\n        // check we are in the upper triangular matrix\r\n        if (i < j) {\r\n          // check row exists in upper triangular matrix\r\n          if (i < columns) {\r\n            // U\r\n            udata[i][j] = data[i][j];\r\n          }\r\n          // check column exists in lower triangular matrix\r\n          if (j < rows) {\r\n            // L\r\n            ldata[i][j] = 0;\r\n          }\r\n          continue;\r\n        }\r\n        // diagonal value\r\n        if (i === j) {\r\n          // check row exists in upper triangular matrix\r\n          if (i < columns) {\r\n            // U\r\n            udata[i][j] = data[i][j];\r\n          }\r\n          // check column exists in lower triangular matrix\r\n          if (j < rows) {\r\n            // L\r\n            ldata[i][j] = 1;\r\n          }\r\n          continue;\r\n        }\r\n        // check row exists in upper triangular matrix\r\n        if (i < columns) {\r\n          // U\r\n          udata[i][j] = 0;\r\n        }\r\n        // check column exists in lower triangular matrix\r\n        if (j < rows) {\r\n          // L\r\n          ldata[i][j] = data[i][j];\r\n        }\r\n      }\r\n    }\r\n    // l matrix\r\n    var l = new DenseMatrix({\r\n      data: ldata,\r\n      size: lsize\r\n    });\r\n    // u matrix\r\n    var u = new DenseMatrix({\r\n      data: udata,\r\n      size: usize\r\n    });\r\n    // p vector\r\n    var pv = [];\r\n    for (i = 0, n = p.length; i < n; i++) {\r\n      pv[p[i]] = i;\r\n    }\r\n    // return matrices\r\n    return {\r\n      L: l,\r\n      U: u,\r\n      p: pv,\r\n      toString: function toString() {\r\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\r\n      }\r\n    };\r\n  }\r\n  function _sparseLUP(m) {\r\n    // rows & columns\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    // minimum rows and columns\r\n    var n = Math.min(rows, columns);\r\n    // matrix arrays (will not be modified, thanks to permutation vector)\r\n    var values = m._values;\r\n    var index = m._index;\r\n    var ptr = m._ptr;\r\n    // l matrix arrays\r\n    var lvalues = [];\r\n    var lindex = [];\r\n    var lptr = [];\r\n    var lsize = [rows, n];\r\n    // u matrix arrays\r\n    var uvalues = [];\r\n    var uindex = [];\r\n    var uptr = [];\r\n    var usize = [n, columns];\r\n    // vars\r\n    var i, j, k;\r\n    // permutation vectors, (current index -> original index) and (original index -> current index)\r\n    var pvCo = [];\r\n    var pvOc = [];\r\n    for (i = 0; i < rows; i++) {\r\n      pvCo[i] = i;\r\n      pvOc[i] = i;\r\n    }\r\n    // swap indices in permutation vectors (condition x < y)!\r\n    var swapIndeces = function swapIndeces(x, y) {\r\n      // find pv indeces getting data from x and y\r\n      var kx = pvOc[x];\r\n      var ky = pvOc[y];\r\n      // update permutation vector current -> original\r\n      pvCo[kx] = y;\r\n      pvCo[ky] = x;\r\n      // update permutation vector original -> current\r\n      pvOc[x] = ky;\r\n      pvOc[y] = kx;\r\n    };\r\n    // loop columns\r\n    var _loop = function _loop() {\r\n      // sparse accumulator\r\n      var spa = new Spa();\r\n      // check lower triangular matrix has a value @ column j\r\n      if (j < rows) {\r\n        // update ptr\r\n        lptr.push(lvalues.length);\r\n        // first value in j column for lower triangular matrix\r\n        lvalues.push(1);\r\n        lindex.push(j);\r\n      }\r\n      // update ptr\r\n      uptr.push(uvalues.length);\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = ptr[j];\r\n      var k1 = ptr[j + 1];\r\n      // copy column j into sparse accumulator\r\n      for (k = k0; k < k1; k++) {\r\n        // row\r\n        i = index[k];\r\n        // copy column values into sparse accumulator (use permutation vector)\r\n        spa.set(pvCo[i], values[k]);\r\n      }\r\n      // skip first column in upper triangular matrix\r\n      if (j > 0) {\r\n        // loop rows in column j (above diagonal)\r\n        spa.forEach(0, j - 1, function (k, vkj) {\r\n          // loop rows in column k (L)\r\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\r\n            // check row is below k\r\n            if (i > k) {\r\n              // update spa value\r\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\r\n            }\r\n          });\r\n        });\r\n      }\r\n      // row with larger value in spa, row >= j\r\n      var pi = j;\r\n      var vjj = spa.get(j);\r\n      var pabsv = abs(vjj);\r\n      // loop values in spa (order by row, below diagonal)\r\n      spa.forEach(j + 1, rows - 1, function (x, v) {\r\n        // absolute value\r\n        var absv = abs(v);\r\n        // value is greater than pivote value\r\n        if (larger(absv, pabsv)) {\r\n          // store row\r\n          pi = x;\r\n          // update max value\r\n          pabsv = absv;\r\n          // value @ [j, j]\r\n          vjj = v;\r\n        }\r\n      });\r\n      // swap rows (j <-> pi)\r\n      if (j !== pi) {\r\n        // swap values j <-> pi in L\r\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);\r\n        // swap values j <-> pi in U\r\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);\r\n        // swap values in spa\r\n        spa.swap(j, pi);\r\n        // update permutation vector (swap values @ j, pi)\r\n        swapIndeces(j, pi);\r\n      }\r\n      // loop values in spa (order by row)\r\n      spa.forEach(0, rows - 1, function (x, v) {\r\n        // check we are above diagonal\r\n        if (x <= j) {\r\n          // update upper triangular matrix\r\n          uvalues.push(v);\r\n          uindex.push(x);\r\n        } else {\r\n          // update value\r\n          v = divideScalar(v, vjj);\r\n          // check value is non zero\r\n          if (!equalScalar(v, 0)) {\r\n            // update lower triangular matrix\r\n            lvalues.push(v);\r\n            lindex.push(x);\r\n          }\r\n        }\r\n      });\r\n    };\r\n    for (j = 0; j < columns; j++) {\r\n      _loop();\r\n    }\r\n    // update ptrs\r\n    uptr.push(uvalues.length);\r\n    lptr.push(lvalues.length);\r\n\r\n    // return matrices\r\n    return {\r\n      L: new SparseMatrix({\r\n        values: lvalues,\r\n        index: lindex,\r\n        ptr: lptr,\r\n        size: lsize\r\n      }),\r\n      U: new SparseMatrix({\r\n        values: uvalues,\r\n        index: uindex,\r\n        ptr: uptr,\r\n        size: usize\r\n      }),\r\n      p: pvCo,\r\n      toString: function toString() {\r\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\r\n      }\r\n    };\r\n  }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}