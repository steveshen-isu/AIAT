{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  class ArrayNode extends Node {\n    /**\r\n     * @constructor ArrayNode\r\n     * @extends {Node}\r\n     * Holds an 1-dimensional array with items\r\n     * @param {Node[]} [items]   1 dimensional array with items\r\n     */\n    constructor(items) {\n      super();\n      this.items = items || [];\n\n      // validate input\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected');\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isArrayNode() {\n      return true;\n    }\n\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n    _compile(math, argNames) {\n      var evalItems = map(this.items, function (item) {\n        return item._compile(math, argNames);\n      });\n      var asMatrix = math.config.matrix !== 'Array';\n      if (asMatrix) {\n        var matrix = math.matrix;\n        return function evalArrayNode(scope, args, context) {\n          return matrix(map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          }));\n        };\n      } else {\n        return function evalArrayNode(scope, args, context) {\n          return map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          });\n        };\n      }\n    }\n\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.items.length; i++) {\n        var node = this.items[i];\n        callback(node, 'items[' + i + ']', this);\n      }\n    }\n\n    /**\r\n     * Create a new ArrayNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ArrayNode} Returns a transformed copy of the node\r\n     */\n    map(callback) {\n      var items = [];\n      for (var i = 0; i < this.items.length; i++) {\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n      }\n      return new ArrayNode(items);\n    }\n\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ArrayNode}\r\n     */\n    clone() {\n      return new ArrayNode(this.items.slice(0));\n    }\n\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n    _toString(options) {\n      var items = this.items.map(function (node) {\n        return node.toString(options);\n      });\n      return '[' + items.join(', ') + ']';\n    }\n\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        items: this.items\n      };\n    }\n\n    /**\r\n     * Instantiate an ArrayNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ArrayNode}\r\n     */\n    static fromJSON(json) {\n      return new ArrayNode(json.items);\n    }\n\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n    _toHTML(options) {\n      var items = this.items.map(function (node) {\n        return node.toHTML(options);\n      });\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n    _toTex(options) {\n      function itemsToTex(items, nested) {\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n        var itemsFormRow = nested || mixedItems;\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n        var itemsTex = items.map(function (node) {\n          if (node.items) {\n            return itemsToTex(node.items, !nested);\n          } else {\n            return node.toTex(options);\n          }\n        }).join(itemSep);\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n      }\n      return itemsToTex(this.items, false);\n    }\n  }\n  _defineProperty(ArrayNode, \"name\", name);\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isArrayNode","isNode","map","factory","name","dependencies","createArrayNode","_ref","Node","ArrayNode","constructor","items","Array","isArray","every","TypeError","type","_compile","math","argNames","evalItems","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","_toHTML","toHTML","_toTex","itemsToTex","nested","mixedItems","some","itemsFormRow","itemSep","itemsTex","toTex","isClass"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isArrayNode, isNode } from '../../utils/is.js';\r\nimport { map } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'ArrayNode';\r\nvar dependencies = ['Node'];\r\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n  class ArrayNode extends Node {\r\n    /**\r\n     * @constructor ArrayNode\r\n     * @extends {Node}\r\n     * Holds an 1-dimensional array with items\r\n     * @param {Node[]} [items]   1 dimensional array with items\r\n     */\r\n    constructor(items) {\r\n      super();\r\n      this.items = items || [];\r\n\r\n      // validate input\r\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\r\n        throw new TypeError('Array containing Nodes expected');\r\n      }\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isArrayNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var evalItems = map(this.items, function (item) {\r\n        return item._compile(math, argNames);\r\n      });\r\n      var asMatrix = math.config.matrix !== 'Array';\r\n      if (asMatrix) {\r\n        var matrix = math.matrix;\r\n        return function evalArrayNode(scope, args, context) {\r\n          return matrix(map(evalItems, function (evalItem) {\r\n            return evalItem(scope, args, context);\r\n          }));\r\n        };\r\n      } else {\r\n        return function evalArrayNode(scope, args, context) {\r\n          return map(evalItems, function (evalItem) {\r\n            return evalItem(scope, args, context);\r\n          });\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        var node = this.items[i];\r\n        callback(node, 'items[' + i + ']', this);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a new ArrayNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ArrayNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      var items = [];\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\r\n      }\r\n      return new ArrayNode(items);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ArrayNode}\r\n     */\r\n    clone() {\r\n      return new ArrayNode(this.items.slice(0));\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toString(options) {\r\n      var items = this.items.map(function (node) {\r\n        return node.toString(options);\r\n      });\r\n      return '[' + items.join(', ') + ']';\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        items: this.items\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an ArrayNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ArrayNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new ArrayNode(json.items);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toHTML(options) {\r\n      var items = this.items.map(function (node) {\r\n        return node.toHTML(options);\r\n      });\r\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      function itemsToTex(items, nested) {\r\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\r\n        var itemsFormRow = nested || mixedItems;\r\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\r\n        var itemsTex = items.map(function (node) {\r\n          if (node.items) {\r\n            return itemsToTex(node.items, !nested);\r\n          } else {\r\n            return node.toTex(options);\r\n          }\r\n        }).join(itemSep);\r\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\r\n      }\r\n      return itemsToTex(this.items, false);\r\n    }\r\n  }\r\n  _defineProperty(ArrayNode, \"name\", name);\r\n  return ArrayNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"AAAA,OAAOA,eAAe,MAAM,uCAAuC;AACnE,SAASC,WAAW,EAAEC,MAAM,QAAQ,mBAAmB;AACvD,SAASC,GAAG,QAAQ,sBAAsB;AAC1C,SAASC,OAAO,QAAQ,wBAAwB;AAChD,IAAIC,IAAI,GAAG,WAAW;AACtB,IAAIC,YAAY,GAAG,CAAC,MAAM,CAAC;AAC3B,OAAO,IAAIC,eAAe,GAAG,eAAeH,OAAO,CAACC,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EAC9E,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR,MAAME,SAAS,SAASD,IAAI,CAAC;IAC3B;AACJ;AACA;AACA;AACA;AACA;IACIE,WAAWA,CAACC,KAAK,EAAE;MACjB,KAAK,CAAC,CAAC;MACP,IAAI,CAACA,KAAK,GAAGA,KAAK,IAAI,EAAE;;MAExB;MACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAAC,IAAI,CAACF,KAAK,CAAC,IAAI,CAAC,IAAI,CAACA,KAAK,CAACG,KAAK,CAACb,MAAM,CAAC,EAAE;QAC3D,MAAM,IAAIc,SAAS,CAAC,iCAAiC,CAAC;MACxD;IACF;IACA,IAAIC,IAAIA,CAAA,EAAG;MACT,OAAOZ,IAAI;IACb;IACA,IAAIJ,WAAWA,CAAA,EAAG;MAChB,OAAO,IAAI;IACb;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIiB,QAAQA,CAACC,IAAI,EAAEC,QAAQ,EAAE;MACvB,IAAIC,SAAS,GAAGlB,GAAG,CAAC,IAAI,CAACS,KAAK,EAAE,UAAUU,IAAI,EAAE;QAC9C,OAAOA,IAAI,CAACJ,QAAQ,CAACC,IAAI,EAAEC,QAAQ,CAAC;MACtC,CAAC,CAAC;MACF,IAAIG,QAAQ,GAAGJ,IAAI,CAACK,MAAM,CAACC,MAAM,KAAK,OAAO;MAC7C,IAAIF,QAAQ,EAAE;QACZ,IAAIE,MAAM,GAAGN,IAAI,CAACM,MAAM;QACxB,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;UAClD,OAAOJ,MAAM,CAACtB,GAAG,CAACkB,SAAS,EAAE,UAAUS,QAAQ,EAAE;YAC/C,OAAOA,QAAQ,CAACH,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC;UACvC,CAAC,CAAC,CAAC;QACL,CAAC;MACH,CAAC,MAAM;QACL,OAAO,SAASH,aAAaA,CAACC,KAAK,EAAEC,IAAI,EAAEC,OAAO,EAAE;UAClD,OAAO1B,GAAG,CAACkB,SAAS,EAAE,UAAUS,QAAQ,EAAE;YACxC,OAAOA,QAAQ,CAACH,KAAK,EAAEC,IAAI,EAAEC,OAAO,CAAC;UACvC,CAAC,CAAC;QACJ,CAAC;MACH;IACF;;IAEA;AACJ;AACA;AACA;IACIE,OAAOA,CAACC,QAAQ,EAAE;MAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACsB,MAAM,EAAED,CAAC,EAAE,EAAE;QAC1C,IAAIE,IAAI,GAAG,IAAI,CAACvB,KAAK,CAACqB,CAAC,CAAC;QACxBD,QAAQ,CAACG,IAAI,EAAE,QAAQ,GAAGF,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC;MAC1C;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACI9B,GAAGA,CAAC6B,QAAQ,EAAE;MACZ,IAAIpB,KAAK,GAAG,EAAE;MACd,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACsB,MAAM,EAAED,CAAC,EAAE,EAAE;QAC1CrB,KAAK,CAACqB,CAAC,CAAC,GAAG,IAAI,CAACG,OAAO,CAACJ,QAAQ,CAAC,IAAI,CAACpB,KAAK,CAACqB,CAAC,CAAC,EAAE,QAAQ,GAAGA,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC,CAAC;MAC5E;MACA,OAAO,IAAIvB,SAAS,CAACE,KAAK,CAAC;IAC7B;;IAEA;AACJ;AACA;AACA;IACIyB,KAAKA,CAAA,EAAG;MACN,OAAO,IAAI3B,SAAS,CAAC,IAAI,CAACE,KAAK,CAAC0B,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3C;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACIC,SAASA,CAACC,OAAO,EAAE;MACjB,IAAI5B,KAAK,GAAG,IAAI,CAACA,KAAK,CAACT,GAAG,CAAC,UAAUgC,IAAI,EAAE;QACzC,OAAOA,IAAI,CAACM,QAAQ,CAACD,OAAO,CAAC;MAC/B,CAAC,CAAC;MACF,OAAO,GAAG,GAAG5B,KAAK,CAAC8B,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;IACrC;;IAEA;AACJ;AACA;AACA;IACIC,MAAMA,CAAA,EAAG;MACP,OAAO;QACLC,MAAM,EAAEvC,IAAI;QACZO,KAAK,EAAE,IAAI,CAACA;MACd,CAAC;IACH;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,OAAOiC,QAAQA,CAACC,IAAI,EAAE;MACpB,OAAO,IAAIpC,SAAS,CAACoC,IAAI,CAAClC,KAAK,CAAC;IAClC;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACImC,OAAOA,CAACP,OAAO,EAAE;MACf,IAAI5B,KAAK,GAAG,IAAI,CAACA,KAAK,CAACT,GAAG,CAAC,UAAUgC,IAAI,EAAE;QACzC,OAAOA,IAAI,CAACa,MAAM,CAACR,OAAO,CAAC;MAC7B,CAAC,CAAC;MACF,OAAO,iEAAiE,GAAG5B,KAAK,CAAC8B,IAAI,CAAC,uCAAuC,CAAC,GAAG,iEAAiE;IACpM;;IAEA;AACJ;AACA;AACA;AACA;IACIO,MAAMA,CAACT,OAAO,EAAE;MACd,SAASU,UAAUA,CAACtC,KAAK,EAAEuC,MAAM,EAAE;QACjC,IAAIC,UAAU,GAAGxC,KAAK,CAACyC,IAAI,CAACpD,WAAW,CAAC,IAAI,CAACW,KAAK,CAACG,KAAK,CAACd,WAAW,CAAC;QACrE,IAAIqD,YAAY,GAAGH,MAAM,IAAIC,UAAU;QACvC,IAAIG,OAAO,GAAGD,YAAY,GAAG,GAAG,GAAG,MAAM;QACzC,IAAIE,QAAQ,GAAG5C,KAAK,CAACT,GAAG,CAAC,UAAUgC,IAAI,EAAE;UACvC,IAAIA,IAAI,CAACvB,KAAK,EAAE;YACd,OAAOsC,UAAU,CAACf,IAAI,CAACvB,KAAK,EAAE,CAACuC,MAAM,CAAC;UACxC,CAAC,MAAM;YACL,OAAOhB,IAAI,CAACsB,KAAK,CAACjB,OAAO,CAAC;UAC5B;QACF,CAAC,CAAC,CAACE,IAAI,CAACa,OAAO,CAAC;QAChB,OAAOH,UAAU,IAAI,CAACE,YAAY,IAAIA,YAAY,IAAI,CAACH,MAAM,GAAG,kBAAkB,GAAGK,QAAQ,GAAG,gBAAgB,GAAGA,QAAQ;MAC7H;MACA,OAAON,UAAU,CAAC,IAAI,CAACtC,KAAK,EAAE,KAAK,CAAC;IACtC;EACF;EACAZ,eAAe,CAACU,SAAS,EAAE,MAAM,EAAEL,IAAI,CAAC;EACxC,OAAOK,SAAS;AAClB,CAAC,EAAE;EACDgD,OAAO,EAAE,IAAI;EACbxD,MAAM,EAAE;AACV,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}