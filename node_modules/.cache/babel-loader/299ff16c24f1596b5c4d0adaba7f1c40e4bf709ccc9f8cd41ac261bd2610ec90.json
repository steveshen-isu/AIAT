{"ast":null,"code":"import { isArray, isMatrix, isRange } from '../../utils/is.js';\nimport { clone } from '../../utils/object.js';\nimport { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'Index';\nvar dependencies = ['ImmutableDenseMatrix', 'getMatrixDataType'];\nexport var createIndexClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    ImmutableDenseMatrix,\n    getMatrixDataType\n  } = _ref;\n  /**\r\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\r\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\r\n   *\r\n   * Usage:\r\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\r\n   *\r\n   * Where each parameter can be any of:\r\n   *     A number\r\n   *     A string (containing a name of an object property)\r\n   *     An instance of Range\r\n   *     An Array with the Set values\r\n   *     An Array with Booleans\r\n   *     A Matrix with the Set values\r\n   *     A Matrix with Booleans\r\n   *\r\n   * The parameters start, end, and step must be integer numbers.\r\n   *\r\n   * @class Index\r\n   * @Constructor Index\r\n   * @param {...*} ranges\r\n   */\n  function Index(ranges) {\n    if (!(this instanceof Index)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    this._dimensions = [];\n    this._sourceSize = [];\n    this._isScalar = true;\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\n      var arg = arguments[i];\n      var argIsArray = isArray(arg);\n      var argIsMatrix = isMatrix(arg);\n      var sourceSize = null;\n      if (isRange(arg)) {\n        this._dimensions.push(arg);\n        this._isScalar = false;\n      } else if (argIsArray || argIsMatrix) {\n        // create matrix\n        var m = void 0;\n        if (getMatrixDataType(arg) === 'boolean') {\n          if (argIsArray) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());\n          if (argIsMatrix) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());\n          sourceSize = arg.valueOf().length;\n        } else {\n          m = _createImmutableMatrix(arg.valueOf());\n        }\n        this._dimensions.push(m);\n        // size\n        var size = m.size();\n        // scalar\n        if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {\n          this._isScalar = false;\n        }\n      } else if (typeof arg === 'number') {\n        this._dimensions.push(_createImmutableMatrix([arg]));\n      } else if (typeof arg === 'string') {\n        // object property (arguments.count should be 1)\n        this._dimensions.push(arg);\n      } else {\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\n      }\n      this._sourceSize.push(sourceSize);\n      // TODO: implement support for wildcard '*'\n    }\n  }\n\n  /**\r\n   * Attach type information\r\n   */\n  Index.prototype.type = 'Index';\n  Index.prototype.isIndex = true;\n  function _createImmutableMatrix(arg) {\n    // loop array elements\n    for (var i = 0, l = arg.length; i < l; i++) {\n      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {\n        throw new TypeError('Index parameters must be positive integer numbers');\n      }\n    }\n    // create matrix\n    return new ImmutableDenseMatrix(arg);\n  }\n\n  /**\r\n   * Create a clone of the index\r\n   * @memberof Index\r\n   * @return {Index} clone\r\n   */\n  Index.prototype.clone = function () {\n    var index = new Index();\n    index._dimensions = clone(this._dimensions);\n    index._isScalar = this._isScalar;\n    index._sourceSize = this._sourceSize;\n    return index;\n  };\n\n  /**\r\n   * Create an index from an array with ranges/numbers\r\n   * @memberof Index\r\n   * @param {Array.<Array | number>} ranges\r\n   * @return {Index} index\r\n   * @private\r\n   */\n  Index.create = function (ranges) {\n    var index = new Index();\n    Index.apply(index, ranges);\n    return index;\n  };\n\n  /**\r\n   * Retrieve the size of the index, the number of elements for each dimension.\r\n   * @memberof Index\r\n   * @returns {number[]} size\r\n   */\n  Index.prototype.size = function () {\n    var size = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var d = this._dimensions[i];\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\n    }\n    return size;\n  };\n\n  /**\r\n   * Get the maximum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} max\r\n   */\n  Index.prototype.max = function () {\n    var values = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.max();\n    }\n    return values;\n  };\n\n  /**\r\n   * Get the minimum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} min\r\n   */\n  Index.prototype.min = function () {\n    var values = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var range = this._dimensions[i];\n      values[i] = typeof range === 'string' ? range : range.min();\n    }\n    return values;\n  };\n\n  /**\r\n   * Loop over each of the ranges of the index\r\n   * @memberof Index\r\n   * @param {Function} callback   Called for each range with a Range as first\r\n   *                              argument, the dimension as second, and the\r\n   *                              index object as third.\r\n   */\n  Index.prototype.forEach = function (callback) {\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      callback(this._dimensions[i], i, this);\n    }\n  };\n\n  /**\r\n   * Retrieve the dimension for the given index\r\n   * @memberof Index\r\n   * @param {Number} dim                  Number of the dimension\r\n   * @returns {Range | null} range\r\n   */\n  Index.prototype.dimension = function (dim) {\n    if (typeof dim !== 'number') {\n      return null;\n    }\n    return this._dimensions[dim] || null;\n  };\n\n  /**\r\n   * Test whether this index contains an object property\r\n   * @returns {boolean} Returns true if the index is an object property\r\n   */\n  Index.prototype.isObjectProperty = function () {\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\n  };\n\n  /**\r\n   * Returns the object property name when the Index holds a single object property,\r\n   * else returns null\r\n   * @returns {string | null}\r\n   */\n  Index.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this._dimensions[0] : null;\n  };\n\n  /**\r\n   * Test whether this index contains only a single value.\r\n   *\r\n   * This is the case when the index is created with only scalar values as ranges,\r\n   * not for ranges resolving into a single value.\r\n   * @memberof Index\r\n   * @return {boolean} isScalar\r\n   */\n  Index.prototype.isScalar = function () {\n    return this._isScalar;\n  };\n\n  /**\r\n   * Expand the Index into an array.\r\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\n  Index.prototype.toArray = function () {\n    var array = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\n    }\n    return array;\n  };\n\n  /**\r\n   * Get the primitive value of the Index, a two dimensional array.\r\n   * Equivalent to Index.toArray().\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\n  Index.prototype.valueOf = Index.prototype.toArray;\n\n  /**\r\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\r\n   * @memberof Index\r\n   * @returns {String} str\r\n   */\n  Index.prototype.toString = function () {\n    var strings = [];\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\n      var dimension = this._dimensions[i];\n      if (typeof dimension === 'string') {\n        strings.push(JSON.stringify(dimension));\n      } else {\n        strings.push(dimension.toString());\n      }\n    }\n    return '[' + strings.join(', ') + ']';\n  };\n\n  /**\r\n   * Get a JSON representation of the Index\r\n   * @memberof Index\r\n   * @returns {Object} Returns a JSON object structured as:\r\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   */\n  Index.prototype.toJSON = function () {\n    return {\n      mathjs: 'Index',\n      dimensions: this._dimensions\n    };\n  };\n\n  /**\r\n   * Instantiate an Index from a JSON object\r\n   * @memberof Index\r\n   * @param {Object} json A JSON object structured as:\r\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   * @return {Index}\r\n   */\n  Index.fromJSON = function (json) {\n    return Index.create(json.dimensions);\n  };\n  return Index;\n}, {\n  isClass: true\n});\n\n/**\r\n * Receives an array of booleans and returns an array of Numbers for Index\r\n * @param {Array} booleanArrayIndex An array of booleans\r\n * @return {Array} A set of numbers ready for index\r\n */\nfunction _booleansArrayToNumbersForIndex(booleanArrayIndex) {\n  // gets an array of booleans and returns an array of numbers\n  var indexOfNumbers = [];\n  booleanArrayIndex.forEach((bool, idx) => {\n    if (bool) {\n      indexOfNumbers.push(idx);\n    }\n  });\n  return indexOfNumbers;\n}","map":{"version":3,"names":["isArray","isMatrix","isRange","clone","isInteger","factory","name","dependencies","createIndexClass","_ref","ImmutableDenseMatrix","getMatrixDataType","Index","ranges","SyntaxError","_dimensions","_sourceSize","_isScalar","i","ii","arguments","length","arg","argIsArray","argIsMatrix","sourceSize","push","m","_createImmutableMatrix","_booleansArrayToNumbersForIndex","valueOf","_data","size","TypeError","prototype","type","isIndex","l","index","create","apply","d","max","values","range","min","forEach","callback","dimension","dim","isObjectProperty","getObjectProperty","isScalar","toArray","array","toString","strings","JSON","stringify","join","toJSON","mathjs","dimensions","fromJSON","json","isClass","booleanArrayIndex","indexOfNumbers","bool","idx"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js"],"sourcesContent":["import { isArray, isMatrix, isRange } from '../../utils/is.js';\r\nimport { clone } from '../../utils/object.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'Index';\r\nvar dependencies = ['ImmutableDenseMatrix', 'getMatrixDataType'];\r\nexport var createIndexClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    ImmutableDenseMatrix,\r\n    getMatrixDataType\r\n  } = _ref;\r\n  /**\r\n   * Create an index. An Index can store ranges and sets for multiple dimensions.\r\n   * Matrix.get, Matrix.set, and math.subset accept an Index as input.\r\n   *\r\n   * Usage:\r\n   *     const index = new Index(range1, range2, matrix1, array1, ...)\r\n   *\r\n   * Where each parameter can be any of:\r\n   *     A number\r\n   *     A string (containing a name of an object property)\r\n   *     An instance of Range\r\n   *     An Array with the Set values\r\n   *     An Array with Booleans\r\n   *     A Matrix with the Set values\r\n   *     A Matrix with Booleans\r\n   *\r\n   * The parameters start, end, and step must be integer numbers.\r\n   *\r\n   * @class Index\r\n   * @Constructor Index\r\n   * @param {...*} ranges\r\n   */\r\n  function Index(ranges) {\r\n    if (!(this instanceof Index)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n    this._dimensions = [];\r\n    this._sourceSize = [];\r\n    this._isScalar = true;\r\n    for (var i = 0, ii = arguments.length; i < ii; i++) {\r\n      var arg = arguments[i];\r\n      var argIsArray = isArray(arg);\r\n      var argIsMatrix = isMatrix(arg);\r\n      var sourceSize = null;\r\n      if (isRange(arg)) {\r\n        this._dimensions.push(arg);\r\n        this._isScalar = false;\r\n      } else if (argIsArray || argIsMatrix) {\r\n        // create matrix\r\n        var m = void 0;\r\n        if (getMatrixDataType(arg) === 'boolean') {\r\n          if (argIsArray) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg).valueOf());\r\n          if (argIsMatrix) m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg._data).valueOf());\r\n          sourceSize = arg.valueOf().length;\r\n        } else {\r\n          m = _createImmutableMatrix(arg.valueOf());\r\n        }\r\n        this._dimensions.push(m);\r\n        // size\r\n        var size = m.size();\r\n        // scalar\r\n        if (size.length !== 1 || size[0] !== 1 || sourceSize !== null) {\r\n          this._isScalar = false;\r\n        }\r\n      } else if (typeof arg === 'number') {\r\n        this._dimensions.push(_createImmutableMatrix([arg]));\r\n      } else if (typeof arg === 'string') {\r\n        // object property (arguments.count should be 1)\r\n        this._dimensions.push(arg);\r\n      } else {\r\n        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');\r\n      }\r\n      this._sourceSize.push(sourceSize);\r\n      // TODO: implement support for wildcard '*'\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Index.prototype.type = 'Index';\r\n  Index.prototype.isIndex = true;\r\n  function _createImmutableMatrix(arg) {\r\n    // loop array elements\r\n    for (var i = 0, l = arg.length; i < l; i++) {\r\n      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {\r\n        throw new TypeError('Index parameters must be positive integer numbers');\r\n      }\r\n    }\r\n    // create matrix\r\n    return new ImmutableDenseMatrix(arg);\r\n  }\r\n\r\n  /**\r\n   * Create a clone of the index\r\n   * @memberof Index\r\n   * @return {Index} clone\r\n   */\r\n  Index.prototype.clone = function () {\r\n    var index = new Index();\r\n    index._dimensions = clone(this._dimensions);\r\n    index._isScalar = this._isScalar;\r\n    index._sourceSize = this._sourceSize;\r\n    return index;\r\n  };\r\n\r\n  /**\r\n   * Create an index from an array with ranges/numbers\r\n   * @memberof Index\r\n   * @param {Array.<Array | number>} ranges\r\n   * @return {Index} index\r\n   * @private\r\n   */\r\n  Index.create = function (ranges) {\r\n    var index = new Index();\r\n    Index.apply(index, ranges);\r\n    return index;\r\n  };\r\n\r\n  /**\r\n   * Retrieve the size of the index, the number of elements for each dimension.\r\n   * @memberof Index\r\n   * @returns {number[]} size\r\n   */\r\n  Index.prototype.size = function () {\r\n    var size = [];\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var d = this._dimensions[i];\r\n      size[i] = typeof d === 'string' ? 1 : d.size()[0];\r\n    }\r\n    return size;\r\n  };\r\n\r\n  /**\r\n   * Get the maximum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} max\r\n   */\r\n  Index.prototype.max = function () {\r\n    var values = [];\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var range = this._dimensions[i];\r\n      values[i] = typeof range === 'string' ? range : range.max();\r\n    }\r\n    return values;\r\n  };\r\n\r\n  /**\r\n   * Get the minimum value for each of the indexes ranges.\r\n   * @memberof Index\r\n   * @returns {number[]} min\r\n   */\r\n  Index.prototype.min = function () {\r\n    var values = [];\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var range = this._dimensions[i];\r\n      values[i] = typeof range === 'string' ? range : range.min();\r\n    }\r\n    return values;\r\n  };\r\n\r\n  /**\r\n   * Loop over each of the ranges of the index\r\n   * @memberof Index\r\n   * @param {Function} callback   Called for each range with a Range as first\r\n   *                              argument, the dimension as second, and the\r\n   *                              index object as third.\r\n   */\r\n  Index.prototype.forEach = function (callback) {\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      callback(this._dimensions[i], i, this);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Retrieve the dimension for the given index\r\n   * @memberof Index\r\n   * @param {Number} dim                  Number of the dimension\r\n   * @returns {Range | null} range\r\n   */\r\n  Index.prototype.dimension = function (dim) {\r\n    if (typeof dim !== 'number') {\r\n      return null;\r\n    }\r\n    return this._dimensions[dim] || null;\r\n  };\r\n\r\n  /**\r\n   * Test whether this index contains an object property\r\n   * @returns {boolean} Returns true if the index is an object property\r\n   */\r\n  Index.prototype.isObjectProperty = function () {\r\n    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';\r\n  };\r\n\r\n  /**\r\n   * Returns the object property name when the Index holds a single object property,\r\n   * else returns null\r\n   * @returns {string | null}\r\n   */\r\n  Index.prototype.getObjectProperty = function () {\r\n    return this.isObjectProperty() ? this._dimensions[0] : null;\r\n  };\r\n\r\n  /**\r\n   * Test whether this index contains only a single value.\r\n   *\r\n   * This is the case when the index is created with only scalar values as ranges,\r\n   * not for ranges resolving into a single value.\r\n   * @memberof Index\r\n   * @return {boolean} isScalar\r\n   */\r\n  Index.prototype.isScalar = function () {\r\n    return this._isScalar;\r\n  };\r\n\r\n  /**\r\n   * Expand the Index into an array.\r\n   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\r\n  Index.prototype.toArray = function () {\r\n    var array = [];\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var dimension = this._dimensions[i];\r\n      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());\r\n    }\r\n    return array;\r\n  };\r\n\r\n  /**\r\n   * Get the primitive value of the Index, a two dimensional array.\r\n   * Equivalent to Index.toArray().\r\n   * @memberof Index\r\n   * @returns {Array} array\r\n   */\r\n  Index.prototype.valueOf = Index.prototype.toArray;\r\n\r\n  /**\r\n   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'\r\n   * @memberof Index\r\n   * @returns {String} str\r\n   */\r\n  Index.prototype.toString = function () {\r\n    var strings = [];\r\n    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {\r\n      var dimension = this._dimensions[i];\r\n      if (typeof dimension === 'string') {\r\n        strings.push(JSON.stringify(dimension));\r\n      } else {\r\n        strings.push(dimension.toString());\r\n      }\r\n    }\r\n    return '[' + strings.join(', ') + ']';\r\n  };\r\n\r\n  /**\r\n   * Get a JSON representation of the Index\r\n   * @memberof Index\r\n   * @returns {Object} Returns a JSON object structured as:\r\n   *                   `{\"mathjs\": \"Index\", \"ranges\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   */\r\n  Index.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'Index',\r\n      dimensions: this._dimensions\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Instantiate an Index from a JSON object\r\n   * @memberof Index\r\n   * @param {Object} json A JSON object structured as:\r\n   *                     `{\"mathjs\": \"Index\", \"dimensions\": [{\"mathjs\": \"Range\", start: 0, end: 10, step:1}, ...]}`\r\n   * @return {Index}\r\n   */\r\n  Index.fromJSON = function (json) {\r\n    return Index.create(json.dimensions);\r\n  };\r\n  return Index;\r\n}, {\r\n  isClass: true\r\n});\r\n\r\n/**\r\n * Receives an array of booleans and returns an array of Numbers for Index\r\n * @param {Array} booleanArrayIndex An array of booleans\r\n * @return {Array} A set of numbers ready for index\r\n */\r\nfunction _booleansArrayToNumbersForIndex(booleanArrayIndex) {\r\n  // gets an array of booleans and returns an array of numbers\r\n  var indexOfNumbers = [];\r\n  booleanArrayIndex.forEach((bool, idx) => {\r\n    if (bool) {\r\n      indexOfNumbers.push(idx);\r\n    }\r\n  });\r\n  return indexOfNumbers;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}