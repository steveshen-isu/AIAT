{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'multiply';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    equalScalar,\n    dot\n  } = _ref;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n            break;\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n            break;\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n        break;\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n            break;\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n            break;\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n        break;\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (N)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {number}             Scalar value\r\n   */\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    }\n    return dot(a, b);\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Matrix         (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Dense Matrix   (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b dense\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var alength = asize[0];\n    var bcolumns = bsize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var c = [];\n\n    // loop matrix columns\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]);\n      // loop vector\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n      c[j] = sum;\n    }\n\n    // return matrix\n    return a.createDenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (M)\r\n   */\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Matrix         (NxC)\r\n   *\r\n   * @return {Matrix}             Matrix         (MxC)\r\n   */\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix  (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector (M)\r\n   */\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b dense\n    var bdata = b._data;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = asize[0];\n    var acolumns = asize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var c = [];\n\n    // loop matrix a rows\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i];\n      // sum (do not initialize it with zero)\n      var sum = mf(row[0], bdata[0]);\n      // loop matrix a columns\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n      c[i] = sum;\n    }\n\n    // return matrix\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            DenseMatrix    (NxC)\r\n   *\r\n   * @return {Matrix}             DenseMatrix    (MxC)\r\n   */\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // getDataType()\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b dense\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var c = [];\n\n    // loop matrix a rows\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i];\n      // initialize row array\n      c[i] = [];\n      // loop matrix b columns\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]);\n        // loop matrix a columns\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n        c[i][j] = sum;\n      }\n    }\n\n    // return matrix\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            SparseMatrix   (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix   (MxC)\r\n   */\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype || a.getDataType();\n    // b sparse\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();\n    // validate b matrix\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    }\n    // rows & columns\n    var arows = asize[0];\n    var bcolumns = bsize[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n    // equalScalar signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]);\n      // convert 0 to the same datatype\n      zero = typed.convert(0, dt);\n    }\n\n    // result\n    var cvalues = [];\n    var cindex = [];\n    var cptr = [];\n    // c matrix\n    var c = b.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n\n    // loop b columns\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length;\n      // indeces in column jb\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1];\n      // do not process column jb if no data exists\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0;\n        // loop a rows\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1;\n          // C[i, jb]\n          var cij = void 0;\n          // values in b column j\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb];\n            // check value has been initialized\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]);\n              // update mark\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          }\n          // check column has been processed and value != 0\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    }\n    // update ptr\n    cptr[bcolumns] = cindex.length;\n\n    // return sparse matrix\n    return c;\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix    (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             SparseMatrix    (M, 1)\r\n   */\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\n    // validate a matrix\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    }\n    // b dense\n    var bdata = b._data;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = a._size[0];\n    var brows = b._size[0];\n    // result\n    var cvalues = [];\n    var cindex = [];\n    var cptr = [];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n    // equalScalar signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]);\n      // convert 0 to the same datatype\n      zero = typed.convert(0, dt);\n    }\n\n    // workspace\n    var x = [];\n    // vector with marks indicating a value x[i] exists in a given column\n    var w = [];\n\n    // update ptr\n    cptr[0] = 0;\n    // rows in b\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib];\n      // check b[ib] != 0, avoid loops\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka];\n          // check value exists in current j\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true;\n            // add i to pattern of C\n            cindex.push(ia);\n            // x(ia) = A\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    }\n    // copy values from x to column jb of c\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p];\n      // copy value\n      cvalues[p] = x[ic];\n    }\n    // update ptr\n    cptr[1] = cindex.length;\n\n    // matrix to return\n    return a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            DenseMatrix       (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\n    // validate a matrix\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    }\n    // b dense\n    var bdata = b._data;\n    var bdt = b._datatype || b.getDataType();\n    // rows & columns\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1];\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n    // equalScalar signature to use\n    var eq = equalScalar;\n    // zero value\n    var zero = 0;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]);\n      // convert 0 to the same datatype\n      zero = typed.convert(0, dt);\n    }\n\n    // result\n    var cvalues = [];\n    var cindex = [];\n    var cptr = [];\n    // c matrix\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n\n    // workspace\n    var x = [];\n    // vector with marks indicating a value x[i] exists in a given column\n    var w = [];\n\n    // loop b columns\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length;\n      // mark in workspace for current column\n      var mark = jb + 1;\n      // rows in jb\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb];\n        // check b[ib, jb] != 0, avoid loops\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka];\n            // check value exists in current j\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark;\n              // add i to pattern of C\n              cindex.push(ia);\n              // x(ia) = A\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      }\n      // copy values from x to column jb of c\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p];\n        // copy value\n        cvalues[p] = x[ic];\n      }\n    }\n    // update ptr\n    cptr[bcolumns] = cindex.length;\n\n    // return sparse matrix\n    return c;\n  }\n\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            SparseMatrix      (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\n    // b sparse\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();\n\n    // rows & columns\n    var arows = a._size[0];\n    var bcolumns = b._size[1];\n    // flag indicating both matrices (a & b) contain data\n    var values = avalues && bvalues;\n\n    // datatype\n    var dt;\n    // addScalar signature to use\n    var af = addScalar;\n    // multiplyScalar signature to use\n    var mf = multiplyScalar;\n\n    // process data types\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\n      // datatype\n      dt = adt;\n      // find signatures that matches (dt, dt)\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    }\n\n    // result\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = [];\n    // c matrix\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\n    });\n\n    // workspace\n    var x = values ? [] : undefined;\n    // vector with marks indicating a value x[i] exists in a given column\n    var w = [];\n    // variables\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;\n    // loop b columns\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length;\n      // mark in workspace for current column\n      var mark = jb + 1;\n      // B values & index in j\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb];\n        // check we need to process values\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka];\n            // check value exists in current j\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark;\n              // add i to pattern of C\n              cindex.push(ia);\n              // x(ia) = A\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka];\n            // check value exists in current j\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark;\n              // add i to pattern of C\n              cindex.push(ia);\n            }\n          }\n        }\n      }\n      // check we need to process matrix values (pattern matrix)\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p];\n          // copy value\n          cvalues[p] = x[ic];\n        }\n      }\n    }\n    // update ptr\n    cptr[bcolumns] = cindex.length;\n\n    // return sparse matrix\n    return c;\n  }\n\n  /**\r\n   * Multiply two or more values, `x * y`.\r\n   * For matrices, the matrix product is calculated.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.multiply(x, y)\r\n   *    math.multiply(x, y, z, ...)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.multiply(4, 5.2)        // returns number 20.8\r\n   *    math.multiply(2, 3, 4)       // returns number 24\r\n   *\r\n   *    const a = math.complex(2, 3)\r\n   *    const b = math.complex(4, 1)\r\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\r\n   *\r\n   *    const c = [[1, 2], [4, 3]]\r\n   *    const d = [[1, 2, 3], [3, -4, 7]]\r\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\r\n   *\r\n   *    const e = math.unit('2.1 km')\r\n   *    math.multiply(3, e)          // returns Unit 6.3 km\r\n   *\r\n   * See also:\r\n   *\r\n   *    divide, prod, cross, dot\r\n   *\r\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\r\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\r\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\r\n   */\n  return typed(name, multiplyScalar, {\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n\n    'Array, Array': typed.referTo('Matrix, Matrix', selfMM => (x, y) => {\n      // check dimensions\n      _validateMatrixDimensions(arraySize(x), arraySize(y));\n\n      // use dense matrix implementation\n      var m = selfMM(matrix(x), matrix(y));\n      // return array or scalar\n      return isMatrix(m) ? m.valueOf() : m;\n    }),\n    'Matrix, Matrix': function Matrix_Matrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size();\n\n      // check dimensions\n      _validateMatrixDimensions(xsize, ysize);\n\n      // process dimensions\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        }\n        // Vector * Matrix\n        return _multiplyVectorMatrix(x, y);\n      }\n      // process y dimensions\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      }\n      // Matrix * Matrix\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': typed.referTo('Matrix,Matrix', selfMM => (x, y) => selfMM(x, matrix(y))),\n    'Array, Matrix': typed.referToSelf(self => (x, y) => {\n      // use Matrix * Matrix implementation\n      return self(matrix(x, y.storage()), y);\n    }),\n    'SparseMatrix, any': function SparseMatrix_any(x, y) {\n      return matAlgo11xS0s(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrix_any(x, y) {\n      return matAlgo14xDs(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function any_SparseMatrix(x, y) {\n      return matAlgo11xS0s(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function any_DenseMatrix(x, y) {\n      return matAlgo14xDs(y, x, multiplyScalar, true);\n    },\n    'Array, any': function Array_any(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function any_Array(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {\n      var result = self(x, y);\n      for (var i = 0; i < rest.length; i++) {\n        result = self(result, rest[i]);\n      }\n      return result;\n    })\n  });\n});","map":{"version":3,"names":["factory","isMatrix","arraySize","createMatAlgo11xS0s","createMatAlgo14xDs","name","dependencies","createMultiply","_ref","typed","matrix","addScalar","multiplyScalar","equalScalar","dot","matAlgo11xS0s","matAlgo14xDs","_validateMatrixDimensions","size1","size2","length","RangeError","Error","_multiplyVectorVector","a","b","n","_multiplyVectorMatrix","storage","_multiplyVectorDenseMatrix","adata","_data","asize","_size","adt","_datatype","getDataType","bdata","bsize","bdt","alength","bcolumns","dt","af","mf","find","c","j","sum","i","createDenseMatrix","data","size","datatype","undefined","_multiplyMatrixVector","_multiplyDenseMatrixVector","_multiplySparseMatrixVector","_multiplyMatrixMatrix","_multiplyDenseMatrixDenseMatrix","_multiplyDenseMatrixSparseMatrix","_multiplySparseMatrixDenseMatrix","_multiplySparseMatrixSparseMatrix","arows","acolumns","row","x","bvalues","_values","bindex","_index","bptr","_ptr","eq","zero","convert","cvalues","cindex","cptr","createSparseMatrix","values","index","ptr","jb","kb0","kb1","last","mark","cij","kb","ib","push","avalues","aindex","aptr","brows","w","vbi","ka0","ka1","ka","ia","p1","p","ic","vbij","p0","referTo","selfMM","y","m","valueOf","Matrix_Matrix","xsize","ysize","referToSelf","self","SparseMatrix_any","DenseMatrix_any","any_SparseMatrix","any_DenseMatrix","Array_any","any_Array","rest","result"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/arithmetic/multiply.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { isMatrix } from '../../utils/is.js';\r\nimport { arraySize } from '../../utils/array.js';\r\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\r\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\r\nvar name = 'multiply';\r\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\r\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    addScalar,\r\n    multiplyScalar,\r\n    equalScalar,\r\n    dot\r\n  } = _ref;\r\n  var matAlgo11xS0s = createMatAlgo11xS0s({\r\n    typed,\r\n    equalScalar\r\n  });\r\n  var matAlgo14xDs = createMatAlgo14xDs({\r\n    typed\r\n  });\r\n  function _validateMatrixDimensions(size1, size2) {\r\n    // check left operand dimensions\r\n    switch (size1.length) {\r\n      case 1:\r\n        // check size2\r\n        switch (size2.length) {\r\n          case 1:\r\n            // Vector x Vector\r\n            if (size1[0] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\r\n            }\r\n            break;\r\n          case 2:\r\n            // Vector x Matrix\r\n            if (size1[0] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\r\n        }\r\n        break;\r\n      case 2:\r\n        // check size2\r\n        switch (size2.length) {\r\n          case 1:\r\n            // Matrix x Vector\r\n            if (size1[1] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\r\n            }\r\n            break;\r\n          case 2:\r\n            // Matrix x Matrix\r\n            if (size1[1] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (N)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {number}             Scalar value\r\n   */\r\n  function _multiplyVectorVector(a, b, n) {\r\n    // check empty vector\r\n    if (n === 0) {\r\n      throw new Error('Cannot multiply two empty vectors');\r\n    }\r\n    return dot(a, b);\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Matrix         (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\r\n  function _multiplyVectorMatrix(a, b) {\r\n    // process storage\r\n    if (b.storage() !== 'dense') {\r\n      throw new Error('Support for SparseMatrix not implemented');\r\n    }\r\n    return _multiplyVectorDenseMatrix(a, b);\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Dense Matrix   (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\r\n  function _multiplyVectorDenseMatrix(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype || a.getDataType();\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bsize = b._size;\r\n    var bdt = b._datatype || b.getDataType();\r\n    // rows & columns\r\n    var alength = asize[0];\r\n    var bcolumns = bsize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var c = [];\r\n\r\n    // loop matrix columns\r\n    for (var j = 0; j < bcolumns; j++) {\r\n      // sum (do not initialize it with zero)\r\n      var sum = mf(adata[0], bdata[0][j]);\r\n      // loop vector\r\n      for (var i = 1; i < alength; i++) {\r\n        // multiply & accumulate\r\n        sum = af(sum, mf(adata[i], bdata[i][j]));\r\n      }\r\n      c[j] = sum;\r\n    }\r\n\r\n    // return matrix\r\n    return a.createDenseMatrix({\r\n      data: c,\r\n      size: [bcolumns],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (M)\r\n   */\r\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\r\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\r\n    'SparseMatrix, any': _multiplySparseMatrixVector\r\n  });\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Matrix         (NxC)\r\n   *\r\n   * @return {Matrix}             Matrix         (MxC)\r\n   */\r\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\r\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\r\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\r\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\r\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\r\n  });\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix  (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector (M)\r\n   */\r\n  function _multiplyDenseMatrixVector(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype || a.getDataType();\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bdt = b._datatype || b.getDataType();\r\n    // rows & columns\r\n    var arows = asize[0];\r\n    var acolumns = asize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var c = [];\r\n\r\n    // loop matrix a rows\r\n    for (var i = 0; i < arows; i++) {\r\n      // current row\r\n      var row = adata[i];\r\n      // sum (do not initialize it with zero)\r\n      var sum = mf(row[0], bdata[0]);\r\n      // loop matrix a columns\r\n      for (var j = 1; j < acolumns; j++) {\r\n        // multiply & accumulate\r\n        sum = af(sum, mf(row[j], bdata[j]));\r\n      }\r\n      c[i] = sum;\r\n    }\r\n\r\n    // return matrix\r\n    return a.createDenseMatrix({\r\n      data: c,\r\n      size: [arows],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            DenseMatrix    (NxC)\r\n   *\r\n   * @return {Matrix}             DenseMatrix    (MxC)\r\n   */\r\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\r\n    // getDataType()\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype || a.getDataType();\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bsize = b._size;\r\n    var bdt = b._datatype || b.getDataType();\r\n    // rows & columns\r\n    var arows = asize[0];\r\n    var acolumns = asize[1];\r\n    var bcolumns = bsize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var c = [];\r\n\r\n    // loop matrix a rows\r\n    for (var i = 0; i < arows; i++) {\r\n      // current row\r\n      var row = adata[i];\r\n      // initialize row array\r\n      c[i] = [];\r\n      // loop matrix b columns\r\n      for (var j = 0; j < bcolumns; j++) {\r\n        // sum (avoid initializing sum to zero)\r\n        var sum = mf(row[0], bdata[0][j]);\r\n        // loop matrix a columns\r\n        for (var x = 1; x < acolumns; x++) {\r\n          // multiply & accumulate\r\n          sum = af(sum, mf(row[x], bdata[x][j]));\r\n        }\r\n        c[i][j] = sum;\r\n      }\r\n    }\r\n\r\n    // return matrix\r\n    return a.createDenseMatrix({\r\n      data: c,\r\n      size: [arows, bcolumns],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            SparseMatrix   (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix   (MxC)\r\n   */\r\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype || a.getDataType();\r\n    // b sparse\r\n    var bvalues = b._values;\r\n    var bindex = b._index;\r\n    var bptr = b._ptr;\r\n    var bsize = b._size;\r\n    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();\r\n    // validate b matrix\r\n    if (!bvalues) {\r\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\r\n    }\r\n    // rows & columns\r\n    var arows = asize[0];\r\n    var bcolumns = bsize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n    // equalScalar signature to use\r\n    var eq = equalScalar;\r\n    // zero value\r\n    var zero = 0;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n      eq = typed.find(equalScalar, [dt, dt]);\r\n      // convert 0 to the same datatype\r\n      zero = typed.convert(0, dt);\r\n    }\r\n\r\n    // result\r\n    var cvalues = [];\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // c matrix\r\n    var c = b.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, bcolumns],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n\r\n    // loop b columns\r\n    for (var jb = 0; jb < bcolumns; jb++) {\r\n      // update ptr\r\n      cptr[jb] = cindex.length;\r\n      // indeces in column jb\r\n      var kb0 = bptr[jb];\r\n      var kb1 = bptr[jb + 1];\r\n      // do not process column jb if no data exists\r\n      if (kb1 > kb0) {\r\n        // last row mark processed\r\n        var last = 0;\r\n        // loop a rows\r\n        for (var i = 0; i < arows; i++) {\r\n          // column mark\r\n          var mark = i + 1;\r\n          // C[i, jb]\r\n          var cij = void 0;\r\n          // values in b column j\r\n          for (var kb = kb0; kb < kb1; kb++) {\r\n            // row\r\n            var ib = bindex[kb];\r\n            // check value has been initialized\r\n            if (last !== mark) {\r\n              // first value in column jb\r\n              cij = mf(adata[i][ib], bvalues[kb]);\r\n              // update mark\r\n              last = mark;\r\n            } else {\r\n              // accumulate value\r\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\r\n            }\r\n          }\r\n          // check column has been processed and value != 0\r\n          if (last === mark && !eq(cij, zero)) {\r\n            // push row & value\r\n            cindex.push(i);\r\n            cvalues.push(cij);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // update ptr\r\n    cptr[bcolumns] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix    (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             SparseMatrix    (M, 1)\r\n   */\r\n  function _multiplySparseMatrixVector(a, b) {\r\n    // a sparse\r\n    var avalues = a._values;\r\n    var aindex = a._index;\r\n    var aptr = a._ptr;\r\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\r\n    // validate a matrix\r\n    if (!avalues) {\r\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\r\n    }\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bdt = b._datatype || b.getDataType();\r\n    // rows & columns\r\n    var arows = a._size[0];\r\n    var brows = b._size[0];\r\n    // result\r\n    var cvalues = [];\r\n    var cindex = [];\r\n    var cptr = [];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n    // equalScalar signature to use\r\n    var eq = equalScalar;\r\n    // zero value\r\n    var zero = 0;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n      eq = typed.find(equalScalar, [dt, dt]);\r\n      // convert 0 to the same datatype\r\n      zero = typed.convert(0, dt);\r\n    }\r\n\r\n    // workspace\r\n    var x = [];\r\n    // vector with marks indicating a value x[i] exists in a given column\r\n    var w = [];\r\n\r\n    // update ptr\r\n    cptr[0] = 0;\r\n    // rows in b\r\n    for (var ib = 0; ib < brows; ib++) {\r\n      // b[ib]\r\n      var vbi = bdata[ib];\r\n      // check b[ib] != 0, avoid loops\r\n      if (!eq(vbi, zero)) {\r\n        // A values & index in ib column\r\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n          // a row\r\n          var ia = aindex[ka];\r\n          // check value exists in current j\r\n          if (!w[ia]) {\r\n            // ia is new entry in j\r\n            w[ia] = true;\r\n            // add i to pattern of C\r\n            cindex.push(ia);\r\n            // x(ia) = A\r\n            x[ia] = mf(vbi, avalues[ka]);\r\n          } else {\r\n            // i exists in C already\r\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // copy values from x to column jb of c\r\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\r\n      // row\r\n      var ic = cindex[p];\r\n      // copy value\r\n      cvalues[p] = x[ic];\r\n    }\r\n    // update ptr\r\n    cptr[1] = cindex.length;\r\n\r\n    // matrix to return\r\n    return a.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, 1],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            DenseMatrix       (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\r\n  function _multiplySparseMatrixDenseMatrix(a, b) {\r\n    // a sparse\r\n    var avalues = a._values;\r\n    var aindex = a._index;\r\n    var aptr = a._ptr;\r\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\r\n    // validate a matrix\r\n    if (!avalues) {\r\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\r\n    }\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bdt = b._datatype || b.getDataType();\r\n    // rows & columns\r\n    var arows = a._size[0];\r\n    var brows = b._size[0];\r\n    var bcolumns = b._size[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n    // equalScalar signature to use\r\n    var eq = equalScalar;\r\n    // zero value\r\n    var zero = 0;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n      eq = typed.find(equalScalar, [dt, dt]);\r\n      // convert 0 to the same datatype\r\n      zero = typed.convert(0, dt);\r\n    }\r\n\r\n    // result\r\n    var cvalues = [];\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // c matrix\r\n    var c = a.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, bcolumns],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n\r\n    // workspace\r\n    var x = [];\r\n    // vector with marks indicating a value x[i] exists in a given column\r\n    var w = [];\r\n\r\n    // loop b columns\r\n    for (var jb = 0; jb < bcolumns; jb++) {\r\n      // update ptr\r\n      cptr[jb] = cindex.length;\r\n      // mark in workspace for current column\r\n      var mark = jb + 1;\r\n      // rows in jb\r\n      for (var ib = 0; ib < brows; ib++) {\r\n        // b[ib, jb]\r\n        var vbij = bdata[ib][jb];\r\n        // check b[ib, jb] != 0, avoid loops\r\n        if (!eq(vbij, zero)) {\r\n          // A values & index in ib column\r\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n            // a row\r\n            var ia = aindex[ka];\r\n            // check value exists in current j\r\n            if (w[ia] !== mark) {\r\n              // ia is new entry in j\r\n              w[ia] = mark;\r\n              // add i to pattern of C\r\n              cindex.push(ia);\r\n              // x(ia) = A\r\n              x[ia] = mf(vbij, avalues[ka]);\r\n            } else {\r\n              // i exists in C already\r\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // copy values from x to column jb of c\r\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\r\n        // row\r\n        var ic = cindex[p];\r\n        // copy value\r\n        cvalues[p] = x[ic];\r\n      }\r\n    }\r\n    // update ptr\r\n    cptr[bcolumns] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            SparseMatrix      (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\r\n  function _multiplySparseMatrixSparseMatrix(a, b) {\r\n    // a sparse\r\n    var avalues = a._values;\r\n    var aindex = a._index;\r\n    var aptr = a._ptr;\r\n    var adt = a._datatype || a._data === undefined ? a._datatype : a.getDataType();\r\n    // b sparse\r\n    var bvalues = b._values;\r\n    var bindex = b._index;\r\n    var bptr = b._ptr;\r\n    var bdt = b._datatype || b._data === undefined ? b._datatype : b.getDataType();\r\n\r\n    // rows & columns\r\n    var arows = a._size[0];\r\n    var bcolumns = b._size[1];\r\n    // flag indicating both matrices (a & b) contain data\r\n    var values = avalues && bvalues;\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string' && adt !== 'mixed') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var cvalues = values ? [] : undefined;\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // c matrix\r\n    var c = a.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, bcolumns],\r\n      datatype: adt === a._datatype && bdt === b._datatype ? dt : undefined\r\n    });\r\n\r\n    // workspace\r\n    var x = values ? [] : undefined;\r\n    // vector with marks indicating a value x[i] exists in a given column\r\n    var w = [];\r\n    // variables\r\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;\r\n    // loop b columns\r\n    for (var jb = 0; jb < bcolumns; jb++) {\r\n      // update ptr\r\n      cptr[jb] = cindex.length;\r\n      // mark in workspace for current column\r\n      var mark = jb + 1;\r\n      // B values & index in j\r\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\r\n        // b row\r\n        ib = bindex[kb];\r\n        // check we need to process values\r\n        if (values) {\r\n          // loop values in a[:,ib]\r\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n            // row\r\n            ia = aindex[ka];\r\n            // check value exists in current j\r\n            if (w[ia] !== mark) {\r\n              // ia is new entry in j\r\n              w[ia] = mark;\r\n              // add i to pattern of C\r\n              cindex.push(ia);\r\n              // x(ia) = A\r\n              x[ia] = mf(bvalues[kb], avalues[ka]);\r\n            } else {\r\n              // i exists in C already\r\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\r\n            }\r\n          }\r\n        } else {\r\n          // loop values in a[:,ib]\r\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n            // row\r\n            ia = aindex[ka];\r\n            // check value exists in current j\r\n            if (w[ia] !== mark) {\r\n              // ia is new entry in j\r\n              w[ia] = mark;\r\n              // add i to pattern of C\r\n              cindex.push(ia);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // check we need to process matrix values (pattern matrix)\r\n      if (values) {\r\n        // copy values from x to column jb of c\r\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\r\n          // row\r\n          var ic = cindex[p];\r\n          // copy value\r\n          cvalues[p] = x[ic];\r\n        }\r\n      }\r\n    }\r\n    // update ptr\r\n    cptr[bcolumns] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Multiply two or more values, `x * y`.\r\n   * For matrices, the matrix product is calculated.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.multiply(x, y)\r\n   *    math.multiply(x, y, z, ...)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.multiply(4, 5.2)        // returns number 20.8\r\n   *    math.multiply(2, 3, 4)       // returns number 24\r\n   *\r\n   *    const a = math.complex(2, 3)\r\n   *    const b = math.complex(4, 1)\r\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\r\n   *\r\n   *    const c = [[1, 2], [4, 3]]\r\n   *    const d = [[1, 2, 3], [3, -4, 7]]\r\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\r\n   *\r\n   *    const e = math.unit('2.1 km')\r\n   *    math.multiply(3, e)          // returns Unit 6.3 km\r\n   *\r\n   * See also:\r\n   *\r\n   *    divide, prod, cross, dot\r\n   *\r\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\r\n   * @param  {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\r\n   * @return {number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\r\n   */\r\n  return typed(name, multiplyScalar, {\r\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\r\n\r\n    'Array, Array': typed.referTo('Matrix, Matrix', selfMM => (x, y) => {\r\n      // check dimensions\r\n      _validateMatrixDimensions(arraySize(x), arraySize(y));\r\n\r\n      // use dense matrix implementation\r\n      var m = selfMM(matrix(x), matrix(y));\r\n      // return array or scalar\r\n      return isMatrix(m) ? m.valueOf() : m;\r\n    }),\r\n    'Matrix, Matrix': function Matrix_Matrix(x, y) {\r\n      // dimensions\r\n      var xsize = x.size();\r\n      var ysize = y.size();\r\n\r\n      // check dimensions\r\n      _validateMatrixDimensions(xsize, ysize);\r\n\r\n      // process dimensions\r\n      if (xsize.length === 1) {\r\n        // process y dimensions\r\n        if (ysize.length === 1) {\r\n          // Vector * Vector\r\n          return _multiplyVectorVector(x, y, xsize[0]);\r\n        }\r\n        // Vector * Matrix\r\n        return _multiplyVectorMatrix(x, y);\r\n      }\r\n      // process y dimensions\r\n      if (ysize.length === 1) {\r\n        // Matrix * Vector\r\n        return _multiplyMatrixVector(x, y);\r\n      }\r\n      // Matrix * Matrix\r\n      return _multiplyMatrixMatrix(x, y);\r\n    },\r\n    'Matrix, Array': typed.referTo('Matrix,Matrix', selfMM => (x, y) => selfMM(x, matrix(y))),\r\n    'Array, Matrix': typed.referToSelf(self => (x, y) => {\r\n      // use Matrix * Matrix implementation\r\n      return self(matrix(x, y.storage()), y);\r\n    }),\r\n    'SparseMatrix, any': function SparseMatrix_any(x, y) {\r\n      return matAlgo11xS0s(x, y, multiplyScalar, false);\r\n    },\r\n    'DenseMatrix, any': function DenseMatrix_any(x, y) {\r\n      return matAlgo14xDs(x, y, multiplyScalar, false);\r\n    },\r\n    'any, SparseMatrix': function any_SparseMatrix(x, y) {\r\n      return matAlgo11xS0s(y, x, multiplyScalar, true);\r\n    },\r\n    'any, DenseMatrix': function any_DenseMatrix(x, y) {\r\n      return matAlgo14xDs(y, x, multiplyScalar, true);\r\n    },\r\n    'Array, any': function Array_any(x, y) {\r\n      // use matrix implementation\r\n      return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();\r\n    },\r\n    'any, Array': function any_Array(x, y) {\r\n      // use matrix implementation\r\n      return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();\r\n    },\r\n    'any, any': multiplyScalar,\r\n    'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {\r\n      var result = self(x, y);\r\n      for (var i = 0; i < rest.length; i++) {\r\n        result = self(result, rest[i]);\r\n      }\r\n      return result;\r\n    })\r\n  });\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}