{"ast":null,"code":"import { broadcastSizes, broadcastTo } from '../../../utils/array.js';\nimport { deepStrictEqual } from '../../../utils/object.js';\n\n/**\r\n* Broadcasts two matrices, and return both in an array\r\n* It checks if it's possible with broadcasting rules\r\n*\r\n* @param {Matrix}   A      First Matrix\r\n* @param {Matrix}   B      Second Matrix\r\n*\r\n* @return {Matrix[]}      [ broadcastedA, broadcastedB ]\r\n*/\n\nexport function broadcast(A, B) {\n  if (deepStrictEqual(A.size(), B.size())) {\n    // If matrices have the same size return them\n    return [A, B];\n  }\n\n  // calculate the broadcasted sizes\n  var newSize = broadcastSizes(A.size(), B.size());\n\n  // return the array with the two broadcasted matrices\n  return [A, B].map(M => _broadcastTo(M, newSize));\n}\n\n/**\r\n * Broadcasts a matrix to the given size.\r\n *\r\n * @param {Matrix} M - The matrix to be broadcasted.\r\n * @param {number[]} size - The desired size of the broadcasted matrix.\r\n * @returns {Matrix} The broadcasted matrix.\r\n * @throws {Error} If the size parameter is not an array of numbers.\r\n */\nfunction _broadcastTo(M, size) {\n  if (deepStrictEqual(M.size(), size)) {\n    return M;\n  }\n  return M.create(broadcastTo(M.valueOf(), size), M.datatype());\n}","map":{"version":3,"names":["broadcastSizes","broadcastTo","deepStrictEqual","broadcast","A","B","size","newSize","map","M","_broadcastTo","create","valueOf","datatype"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js"],"sourcesContent":["import { broadcastSizes, broadcastTo } from '../../../utils/array.js';\r\nimport { deepStrictEqual } from '../../../utils/object.js';\r\n\r\n/**\r\n* Broadcasts two matrices, and return both in an array\r\n* It checks if it's possible with broadcasting rules\r\n*\r\n* @param {Matrix}   A      First Matrix\r\n* @param {Matrix}   B      Second Matrix\r\n*\r\n* @return {Matrix[]}      [ broadcastedA, broadcastedB ]\r\n*/\r\n\r\nexport function broadcast(A, B) {\r\n  if (deepStrictEqual(A.size(), B.size())) {\r\n    // If matrices have the same size return them\r\n    return [A, B];\r\n  }\r\n\r\n  // calculate the broadcasted sizes\r\n  var newSize = broadcastSizes(A.size(), B.size());\r\n\r\n  // return the array with the two broadcasted matrices\r\n  return [A, B].map(M => _broadcastTo(M, newSize));\r\n}\r\n\r\n/**\r\n * Broadcasts a matrix to the given size.\r\n *\r\n * @param {Matrix} M - The matrix to be broadcasted.\r\n * @param {number[]} size - The desired size of the broadcasted matrix.\r\n * @returns {Matrix} The broadcasted matrix.\r\n * @throws {Error} If the size parameter is not an array of numbers.\r\n */\r\nfunction _broadcastTo(M, size) {\r\n  if (deepStrictEqual(M.size(), size)) {\r\n    return M;\r\n  }\r\n  return M.create(broadcastTo(M.valueOf(), size), M.datatype());\r\n}"],"mappings":"AAAA,SAASA,cAAc,EAAEC,WAAW,QAAQ,yBAAyB;AACrE,SAASC,eAAe,QAAQ,0BAA0B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,SAASA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC9B,IAAIH,eAAe,CAACE,CAAC,CAACE,IAAI,CAAC,CAAC,EAAED,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE;IACvC;IACA,OAAO,CAACF,CAAC,EAAEC,CAAC,CAAC;EACf;;EAEA;EACA,IAAIE,OAAO,GAAGP,cAAc,CAACI,CAAC,CAACE,IAAI,CAAC,CAAC,EAAED,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;;EAEhD;EACA,OAAO,CAACF,CAAC,EAAEC,CAAC,CAAC,CAACG,GAAG,CAACC,CAAC,IAAIC,YAAY,CAACD,CAAC,EAAEF,OAAO,CAAC,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,YAAYA,CAACD,CAAC,EAAEH,IAAI,EAAE;EAC7B,IAAIJ,eAAe,CAACO,CAAC,CAACH,IAAI,CAAC,CAAC,EAAEA,IAAI,CAAC,EAAE;IACnC,OAAOG,CAAC;EACV;EACA,OAAOA,CAAC,CAACE,MAAM,CAACV,WAAW,CAACQ,CAAC,CAACG,OAAO,CAAC,CAAC,EAAEN,IAAI,CAAC,EAAEG,CAAC,CAACI,QAAQ,CAAC,CAAC,CAAC;AAC/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}