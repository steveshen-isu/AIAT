{"ast":null,"code":"/* eslint-disable no-loss-of-precision */\n\n// References\n// ----------\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\n\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\nimport { factory } from '../../utils/factory.js';\nimport { copysign } from '../../utils/number.js';\nvar name = 'lgamma';\nvar dependencies = ['Complex', 'typed'];\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Complex,\n    typed\n  } = _ref;\n  // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\n  // sufficient accuracy.\n  //\n  // These two values are copied from Scipy implementation:\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\n  var SMALL_RE = 7;\n  var SMALL_IM = 7;\n\n  /**\r\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\r\n   *\r\n   * If you cannot access the paper, can also get these values from the formula in [2].\r\n   *\r\n   *    1 /     12 = 0.00833333333333333333333333333333\r\n   *    1 /    360 = 0.00277777777777777777777777777778\r\n   * ...\r\n   * 3617 / 133400 = 0.02955065359477124183006535947712\r\n   */\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\n\n  /**\r\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\r\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lgamma(n)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.lgamma(5)       // returns 3.178053830347945\r\n   *    math.lgamma(0)       // returns Infinity\r\n   *    math.lgamma(-0.5)    // returns NaN\r\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\r\n   *\r\n   * See also:\r\n   *\r\n   *    gamma\r\n   *\r\n   * @param {number | Complex} n   A real or complex number\r\n   * @return {number | Complex}    The log gamma of `n`\r\n   */\n  return typed(name, {\n    number: lgammaNumber,\n    Complex: lgammaComplex,\n    BigNumber: function BigNumber() {\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\n    }\n  });\n  function lgammaComplex(n) {\n    var TWOPI = 6.2831853071795864769252842; // 2*pi\n    var LOGPI = 1.1447298858494001741434262; // log(pi)\n\n    var REFLECTION = 0.1;\n    if (n.isNaN()) {\n      return new Complex(NaN, NaN);\n    } else if (n.im === 0) {\n      return new Complex(lgammaNumber(n.re), 0);\n    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\n      return lgammaStirling(n);\n    } else if (n.re <= REFLECTION) {\n      // Reflection formula. see Proposition 3.1 in [1]\n      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);\n      var a = n.mul(Math.PI).sin().log();\n      var b = lgammaComplex(new Complex(1 - n.re, -n.im));\n      return new Complex(LOGPI, tmp).sub(a).sub(b);\n    } else if (n.im >= 0) {\n      return lgammaRecurrence(n);\n    } else {\n      return lgammaRecurrence(n.conjugate()).conjugate();\n    }\n  }\n  function lgammaStirling(z) {\n    // formula ref in [2]\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\n\n    // left part\n\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);\n\n    // right part\n\n    var rz = new Complex(1, 0).div(z);\n    var rzz = rz.div(z);\n    var a = coeffs[0];\n    var b = coeffs[1];\n    var r = 2 * rzz.re;\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\n    for (var i = 2; i < 8; i++) {\n      var tmp = b;\n      b = -s * a + coeffs[i];\n      a = r * a + tmp;\n    }\n    var rightPart = rz.mul(rzz.mul(a).add(b));\n\n    // plus left and right\n\n    return leftPart.add(rightPart);\n  }\n  function lgammaRecurrence(z) {\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\n\n    var signflips = 0;\n    var sb = 0;\n    var shiftprod = z;\n    z = z.add(1);\n    while (z.re <= SMALL_RE) {\n      shiftprod = shiftprod.mul(z);\n      var nsb = shiftprod.im < 0 ? 1 : 0;\n      if (nsb !== 0 && sb === 0) signflips++;\n      sb = nsb;\n      z = z.add(1);\n    }\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex(0, signflips * 2 * Math.PI * 1));\n  }\n});","map":{"version":3,"names":["lgammaNumber","lnSqrt2PI","factory","copysign","name","dependencies","createLgamma","_ref","Complex","typed","SMALL_RE","SMALL_IM","coeffs","number","lgammaComplex","BigNumber","Error","n","TWOPI","LOGPI","REFLECTION","isNaN","NaN","im","re","Math","abs","lgammaStirling","tmp","floor","a","mul","PI","sin","log","b","sub","lgammaRecurrence","conjugate","z","leftPart","add","rz","div","rzz","r","s","i","rightPart","signflips","sb","shiftprod","nsb"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/probability/lgamma.js"],"sourcesContent":["/* eslint-disable no-loss-of-precision */\r\n\r\n// References\r\n// ----------\r\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\r\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\r\n\r\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { copysign } from '../../utils/number.js';\r\nvar name = 'lgamma';\r\nvar dependencies = ['Complex', 'typed'];\r\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Complex,\r\n    typed\r\n  } = _ref;\r\n  // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\r\n  // sufficient accuracy.\r\n  //\r\n  // These two values are copied from Scipy implementation:\r\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\r\n  var SMALL_RE = 7;\r\n  var SMALL_IM = 7;\r\n\r\n  /**\r\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\r\n   *\r\n   * If you cannot access the paper, can also get these values from the formula in [2].\r\n   *\r\n   *    1 /     12 = 0.00833333333333333333333333333333\r\n   *    1 /    360 = 0.00277777777777777777777777777778\r\n   * ...\r\n   * 3617 / 133400 = 0.02955065359477124183006535947712\r\n   */\r\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\r\n\r\n  /**\r\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\r\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lgamma(n)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.lgamma(5)       // returns 3.178053830347945\r\n   *    math.lgamma(0)       // returns Infinity\r\n   *    math.lgamma(-0.5)    // returns NaN\r\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\r\n   *\r\n   * See also:\r\n   *\r\n   *    gamma\r\n   *\r\n   * @param {number | Complex} n   A real or complex number\r\n   * @return {number | Complex}    The log gamma of `n`\r\n   */\r\n  return typed(name, {\r\n    number: lgammaNumber,\r\n    Complex: lgammaComplex,\r\n    BigNumber: function BigNumber() {\r\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\r\n    }\r\n  });\r\n  function lgammaComplex(n) {\r\n    var TWOPI = 6.2831853071795864769252842; // 2*pi\r\n    var LOGPI = 1.1447298858494001741434262; // log(pi)\r\n\r\n    var REFLECTION = 0.1;\r\n    if (n.isNaN()) {\r\n      return new Complex(NaN, NaN);\r\n    } else if (n.im === 0) {\r\n      return new Complex(lgammaNumber(n.re), 0);\r\n    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\r\n      return lgammaStirling(n);\r\n    } else if (n.re <= REFLECTION) {\r\n      // Reflection formula. see Proposition 3.1 in [1]\r\n      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);\r\n      var a = n.mul(Math.PI).sin().log();\r\n      var b = lgammaComplex(new Complex(1 - n.re, -n.im));\r\n      return new Complex(LOGPI, tmp).sub(a).sub(b);\r\n    } else if (n.im >= 0) {\r\n      return lgammaRecurrence(n);\r\n    } else {\r\n      return lgammaRecurrence(n.conjugate()).conjugate();\r\n    }\r\n  }\r\n  function lgammaStirling(z) {\r\n    // formula ref in [2]\r\n    // computation ref:\r\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\r\n\r\n    // left part\r\n\r\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\r\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\r\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);\r\n\r\n    // right part\r\n\r\n    var rz = new Complex(1, 0).div(z);\r\n    var rzz = rz.div(z);\r\n    var a = coeffs[0];\r\n    var b = coeffs[1];\r\n    var r = 2 * rzz.re;\r\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\r\n    for (var i = 2; i < 8; i++) {\r\n      var tmp = b;\r\n      b = -s * a + coeffs[i];\r\n      a = r * a + tmp;\r\n    }\r\n    var rightPart = rz.mul(rzz.mul(a).add(b));\r\n\r\n    // plus left and right\r\n\r\n    return leftPart.add(rightPart);\r\n  }\r\n  function lgammaRecurrence(z) {\r\n    // computation ref:\r\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\r\n\r\n    var signflips = 0;\r\n    var sb = 0;\r\n    var shiftprod = z;\r\n    z = z.add(1);\r\n    while (z.re <= SMALL_RE) {\r\n      shiftprod = shiftprod.mul(z);\r\n      var nsb = shiftprod.im < 0 ? 1 : 0;\r\n      if (nsb !== 0 && sb === 0) signflips++;\r\n      sb = nsb;\r\n      z = z.add(1);\r\n    }\r\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex(0, signflips * 2 * Math.PI * 1));\r\n  }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}