{"ast":null,"code":"import { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { safeNumberType } from '../../utils/number.js';\nimport { createUtil } from './simplify/util.js';\nimport { noBignumber, noFraction } from '../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  var {\n    isCommutative,\n    isAssociative,\n    allChildren,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n\n  /**\r\n   * simplifyConstant() takes a mathjs expression (either a Node representing\r\n   * a parse tree or a string which it parses to produce a node), and replaces\r\n   * any subexpression of it consisting entirely of constants with the computed\r\n   * value of that subexpression.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.simplifyConstant(expr)\r\n   *     math.simplifyConstant(expr, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\r\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\r\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, simplifyCore, resolve, derivative\r\n   *\r\n   * @param {Node | string} node\r\n   *     The expression to be simplified\r\n   * @param {Object} options\r\n   *     Simplification options, as per simplify()\r\n   * @return {Node} Returns expression with constant subexpressions evaluated\r\n   */\n  var simplifyConstant = typed('simplifyConstant', {\n    Node: node => _ensureNode(foldFraction(node, {})),\n    'Node, Object': function Node_Object(expr, options) {\n      return _ensureNode(foldFraction(expr, options));\n    }\n  });\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n    return thing;\n  }\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    bigint: function bigint(n) {\n      if (n < 0n) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n      return new ConstantNode(n);\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\n    }\n  });\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n    return _toNode(thing);\n  }\n\n  // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n    return n;\n  }\n\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n  var _toNumber = typed({\n    'string, Object': function string_Object(s, options) {\n      var numericType = safeNumberType(s, config);\n      if (numericType === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n        return bignumber(s);\n      } else if (numericType === 'bigint') {\n        return BigInt(s);\n      } else if (numericType === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function Fraction_Object(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'BigNumber, Object': function BigNumber_Object(s, options) {\n      return s;\n    },\n    // we don't need options here\n\n    'number, Object': function number_Object(s, options) {\n      return _exactFraction(s, options);\n    },\n    'bigint, Object': function bigint_Object(s, options) {\n      return s;\n    },\n    'Complex, Object': function Complex_Object(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function Matrix_Object(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function Array_Object(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n  function _fractionToNode(f) {\n    // note: we convert await from bigint values, because bigint values gives issues with divisions: 1n/2n=0n and not 0.5\n    var fromBigInt = value => config.number === 'BigNumber' && bignumber ? bignumber(value) : Number(value);\n    var numeratorValue = f.s * f.n;\n    var numeratorNode = numeratorValue < 0n ? new OperatorNode('-', 'unaryMinus', [new ConstantNode(-fromBigInt(numeratorValue))]) : new ConstantNode(fromBigInt(numeratorValue));\n    return f.d === 1n ? numeratorNode : new OperatorNode('/', 'divide', [numeratorNode, new ConstantNode(fromBigInt(f.d))]);\n  }\n\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\r\n       * just in the first or second dimensions because (a) arrays\r\n       * of more than two dimensions are likely rare, and (b) pulling\r\n       * out the third or higher dimension would be pretty intricate.\r\n       * The price is that we miss simplifying [..3d array][x,y,1]\r\n       */\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n          for (var item of fromItems) {\n            if (isArrayNode(item)) {\n              tryItems.push(item.items[second - 1]);\n            } else if (isMatrix(obj)) {\n              tryItems.push(item[second - 1]);\n            } else {\n              break;\n            }\n          }\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n      return obj;\n    }\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n\n  /*\r\n   * Create a binary tree from a list of Fractions and Nodes.\r\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\r\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\r\n   * @param args - list of Fractions and Nodes\r\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\r\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\r\n   * if args.length is 1, returns args[0]\r\n   * @return - Either a Node representing a binary expression or Fraction\r\n   */\n  function foldOp(fn, args, makeNode, options) {\n    var first = args.shift();\n\n    // In the following reduction, sofar always has one of the three following\n    // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]\n    var reduction = args.reduce((sofar, next) => {\n      if (!isNode(next)) {\n        var last = sofar.pop();\n        if (isNode(last)) {\n          return [last, next];\n        }\n        // Two constants in a row, try to fold them into one\n        try {\n          sofar.push(_eval(fn, [last, next], options));\n          return sofar;\n        } catch (ignoreandcontinue) {\n          sofar.push(last);\n          // fall through to Node case\n        }\n      }\n\n      // Encountered a Node, or failed folding --\n      // collapse everything so far into a single tree:\n      sofar.push(_ensureNode(sofar.pop()));\n      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);\n      return [makeNode([newtree, _ensureNode(next)])];\n    }, [first]);\n    if (reduction.length === 1) {\n      return reduction[0];\n    }\n    // Might end up with a tree and a constant at the end:\n    return makeNode([reduction[0], _toNode(reduction[1])]);\n  }\n\n  // destroys the original node and returns a folded one\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n          case 'bigint':\n            return _toNumber(node.value, options);\n          case 'string':\n            return node.value;\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n        return node;\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n          if (!operatorFunctions.includes(node.name)) {\n            var args = node.args.map(arg => foldFraction(arg, options));\n\n            // If all args are numbers\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            }\n\n            // Size of a matrix does not depend on entries\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n              return matrix(sz);\n            }\n\n            // Convert all args to nodes and construct a symbolic function call\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {\n            // treat as operator\n          }\n        }\n      /* falls through */\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n          var _args;\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(arg => foldFraction(arg, options));\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(arg => foldFraction(arg, options));\n            res = foldOp(fn, _args, makeNode, options);\n          }\n          return res;\n        }\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(item => foldFraction(item, options));\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n          return matrix(foldItems);\n        }\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\n        }\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n          return new ObjectNode(foldProps);\n        }\n      case 'AssignmentNode':\n      /* falls through */\n      case 'BlockNode':\n      /* falls through */\n      case 'FunctionAssignmentNode':\n      /* falls through */\n      case 'RangeNode':\n      /* falls through */\n      case 'ConditionalNode':\n      /* falls through */\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n  return simplifyConstant;\n});","map":{"version":3,"names":["isFraction","isMatrix","isNode","isArrayNode","isConstantNode","isIndexNode","isObjectNode","isOperatorNode","factory","safeNumberType","createUtil","noBignumber","noFraction","name","dependencies","createSimplifyConstant","_ref","typed","config","mathWithTransform","matrix","fraction","bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","Node","node","_ensureNode","foldFraction","Node_Object","expr","options","_removeFractions","thing","valueOf","Array","map","_eval","fnname","args","apply","ignore","_toNumber","_toNode","Fraction","_fractionToNode","number","n","unaryMinusNode","BigNumber","bigint","Complex","s","Error","string","Matrix","m","e","_exactFraction","exactFractions","isFinite","f","fractionsLimit","Infinity","d","string_Object","numericType","undefined","BigInt","parseFloat","Fraction_Object","BigNumber_Object","number_Object","bigint_Object","Complex_Object","im","re","Matrix_Object","Array_Object","fromBigInt","value","Number","numeratorValue","numeratorNode","_foldAccessor","obj","index","remainingDims","from","dimensions","length","first","shift","items","second","tryItems","fromItems","item","push","splice","key","properties","foldOp","fn","makeNode","reduction","reduce","sofar","next","last","pop","ignoreandcontinue","newtree","type","isNaN","rawArgs","operatorFunctions","includes","arg","some","sz","section","toString","_args","res","isUnary","context","consts","vars","i","unshift","content","object","foldItems","foldProps","prop","concat"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js"],"sourcesContent":["import { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { safeNumberType } from '../../utils/number.js';\r\nimport { createUtil } from './simplify/util.js';\r\nimport { noBignumber, noFraction } from '../../utils/noop.js';\r\nvar name = 'simplifyConstant';\r\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\r\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    config,\r\n    mathWithTransform,\r\n    matrix,\r\n    fraction,\r\n    bignumber,\r\n    AccessorNode,\r\n    ArrayNode,\r\n    ConstantNode,\r\n    FunctionNode,\r\n    IndexNode,\r\n    ObjectNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  } = _ref;\r\n  var {\r\n    isCommutative,\r\n    isAssociative,\r\n    allChildren,\r\n    createMakeNodeFunction\r\n  } = createUtil({\r\n    FunctionNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  });\r\n\r\n  /**\r\n   * simplifyConstant() takes a mathjs expression (either a Node representing\r\n   * a parse tree or a string which it parses to produce a node), and replaces\r\n   * any subexpression of it consisting entirely of constants with the computed\r\n   * value of that subexpression.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.simplifyConstant(expr)\r\n   *     math.simplifyConstant(expr, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\r\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\r\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, simplifyCore, resolve, derivative\r\n   *\r\n   * @param {Node | string} node\r\n   *     The expression to be simplified\r\n   * @param {Object} options\r\n   *     Simplification options, as per simplify()\r\n   * @return {Node} Returns expression with constant subexpressions evaluated\r\n   */\r\n  var simplifyConstant = typed('simplifyConstant', {\r\n    Node: node => _ensureNode(foldFraction(node, {})),\r\n    'Node, Object': function Node_Object(expr, options) {\r\n      return _ensureNode(foldFraction(expr, options));\r\n    }\r\n  });\r\n  function _removeFractions(thing) {\r\n    if (isFraction(thing)) {\r\n      return thing.valueOf();\r\n    }\r\n    if (thing instanceof Array) {\r\n      return thing.map(_removeFractions);\r\n    }\r\n    if (isMatrix(thing)) {\r\n      return matrix(_removeFractions(thing.valueOf()));\r\n    }\r\n    return thing;\r\n  }\r\n  function _eval(fnname, args, options) {\r\n    try {\r\n      return mathWithTransform[fnname].apply(null, args);\r\n    } catch (ignore) {\r\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\r\n      args = args.map(_removeFractions);\r\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\r\n    }\r\n  }\r\n  var _toNode = typed({\r\n    Fraction: _fractionToNode,\r\n    number: function number(n) {\r\n      if (n < 0) {\r\n        return unaryMinusNode(new ConstantNode(-n));\r\n      }\r\n      return new ConstantNode(n);\r\n    },\r\n    BigNumber: function BigNumber(n) {\r\n      if (n < 0) {\r\n        return unaryMinusNode(new ConstantNode(-n));\r\n      }\r\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\r\n    },\r\n    bigint: function bigint(n) {\r\n      if (n < 0n) {\r\n        return unaryMinusNode(new ConstantNode(-n));\r\n      }\r\n      return new ConstantNode(n);\r\n    },\r\n    Complex: function Complex(s) {\r\n      throw new Error('Cannot convert Complex number to Node');\r\n    },\r\n    string: function string(s) {\r\n      return new ConstantNode(s);\r\n    },\r\n    Matrix: function Matrix(m) {\r\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\r\n    }\r\n  });\r\n  function _ensureNode(thing) {\r\n    if (isNode(thing)) {\r\n      return thing;\r\n    }\r\n    return _toNode(thing);\r\n  }\r\n\r\n  // convert a number to a fraction only if it can be expressed exactly,\r\n  // and when both numerator and denominator are small enough\r\n  function _exactFraction(n, options) {\r\n    var exactFractions = options && options.exactFractions !== false;\r\n    if (exactFractions && isFinite(n) && fraction) {\r\n      var f = fraction(n);\r\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\r\n\r\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\r\n        return f;\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\r\n  // BigNumbers are left alone\r\n  var _toNumber = typed({\r\n    'string, Object': function string_Object(s, options) {\r\n      var numericType = safeNumberType(s, config);\r\n      if (numericType === 'BigNumber') {\r\n        if (bignumber === undefined) {\r\n          noBignumber();\r\n        }\r\n        return bignumber(s);\r\n      } else if (numericType === 'bigint') {\r\n        return BigInt(s);\r\n      } else if (numericType === 'Fraction') {\r\n        if (fraction === undefined) {\r\n          noFraction();\r\n        }\r\n        return fraction(s);\r\n      } else {\r\n        var n = parseFloat(s);\r\n        return _exactFraction(n, options);\r\n      }\r\n    },\r\n    'Fraction, Object': function Fraction_Object(s, options) {\r\n      return s;\r\n    },\r\n    // we don't need options here\r\n\r\n    'BigNumber, Object': function BigNumber_Object(s, options) {\r\n      return s;\r\n    },\r\n    // we don't need options here\r\n\r\n    'number, Object': function number_Object(s, options) {\r\n      return _exactFraction(s, options);\r\n    },\r\n    'bigint, Object': function bigint_Object(s, options) {\r\n      return s;\r\n    },\r\n    'Complex, Object': function Complex_Object(s, options) {\r\n      if (s.im !== 0) {\r\n        return s;\r\n      }\r\n      return _exactFraction(s.re, options);\r\n    },\r\n    'Matrix, Object': function Matrix_Object(s, options) {\r\n      return matrix(_exactFraction(s.valueOf()));\r\n    },\r\n    'Array, Object': function Array_Object(s, options) {\r\n      return s.map(_exactFraction);\r\n    }\r\n  });\r\n  function unaryMinusNode(n) {\r\n    return new OperatorNode('-', 'unaryMinus', [n]);\r\n  }\r\n  function _fractionToNode(f) {\r\n    // note: we convert await from bigint values, because bigint values gives issues with divisions: 1n/2n=0n and not 0.5\r\n    var fromBigInt = value => config.number === 'BigNumber' && bignumber ? bignumber(value) : Number(value);\r\n    var numeratorValue = f.s * f.n;\r\n    var numeratorNode = numeratorValue < 0n ? new OperatorNode('-', 'unaryMinus', [new ConstantNode(-fromBigInt(numeratorValue))]) : new ConstantNode(fromBigInt(numeratorValue));\r\n    return f.d === 1n ? numeratorNode : new OperatorNode('/', 'divide', [numeratorNode, new ConstantNode(fromBigInt(f.d))]);\r\n  }\r\n\r\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\r\n  function _foldAccessor(obj, index, options) {\r\n    if (!isIndexNode(index)) {\r\n      // don't know what to do with that...\r\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\r\n    }\r\n    if (isArrayNode(obj) || isMatrix(obj)) {\r\n      var remainingDims = Array.from(index.dimensions);\r\n      /* We will resolve constant indices one at a time, looking\r\n       * just in the first or second dimensions because (a) arrays\r\n       * of more than two dimensions are likely rare, and (b) pulling\r\n       * out the third or higher dimension would be pretty intricate.\r\n       * The price is that we miss simplifying [..3d array][x,y,1]\r\n       */\r\n      while (remainingDims.length > 0) {\r\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\r\n          var first = _toNumber(remainingDims.shift().value, options);\r\n          if (isArrayNode(obj)) {\r\n            obj = obj.items[first - 1];\r\n          } else {\r\n            // matrix\r\n            obj = obj.valueOf()[first - 1];\r\n            if (obj instanceof Array) {\r\n              obj = matrix(obj);\r\n            }\r\n          }\r\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\r\n          var second = _toNumber(remainingDims[1].value, options);\r\n          var tryItems = [];\r\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\r\n          for (var item of fromItems) {\r\n            if (isArrayNode(item)) {\r\n              tryItems.push(item.items[second - 1]);\r\n            } else if (isMatrix(obj)) {\r\n              tryItems.push(item[second - 1]);\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          if (tryItems.length === fromItems.length) {\r\n            if (isArrayNode(obj)) {\r\n              obj = new ArrayNode(tryItems);\r\n            } else {\r\n              // matrix\r\n              obj = matrix(tryItems);\r\n            }\r\n            remainingDims.splice(1, 1);\r\n          } else {\r\n            // extracting slice along 2nd dimension failed, give up\r\n            break;\r\n          }\r\n        } else {\r\n          // neither 1st or 2nd dimension is constant, give up\r\n          break;\r\n        }\r\n      }\r\n      if (remainingDims.length === index.dimensions.length) {\r\n        /* No successful constant indexing */\r\n        return new AccessorNode(_ensureNode(obj), index);\r\n      }\r\n      if (remainingDims.length > 0) {\r\n        /* Indexed some but not all dimensions */\r\n        index = new IndexNode(remainingDims);\r\n        return new AccessorNode(_ensureNode(obj), index);\r\n      }\r\n      /* All dimensions were constant, access completely resolved */\r\n      return obj;\r\n    }\r\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\r\n      var key = index.dimensions[0].value;\r\n      if (key in obj.properties) {\r\n        return obj.properties[key];\r\n      }\r\n      return new ConstantNode(); // undefined\r\n    }\r\n    /* Don't know how to index this sort of obj, at least not with this index */\r\n    return new AccessorNode(_ensureNode(obj), index);\r\n  }\r\n\r\n  /*\r\n   * Create a binary tree from a list of Fractions and Nodes.\r\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\r\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\r\n   * @param args - list of Fractions and Nodes\r\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\r\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\r\n   * if args.length is 1, returns args[0]\r\n   * @return - Either a Node representing a binary expression or Fraction\r\n   */\r\n  function foldOp(fn, args, makeNode, options) {\r\n    var first = args.shift();\r\n\r\n    // In the following reduction, sofar always has one of the three following\r\n    // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]\r\n    var reduction = args.reduce((sofar, next) => {\r\n      if (!isNode(next)) {\r\n        var last = sofar.pop();\r\n        if (isNode(last)) {\r\n          return [last, next];\r\n        }\r\n        // Two constants in a row, try to fold them into one\r\n        try {\r\n          sofar.push(_eval(fn, [last, next], options));\r\n          return sofar;\r\n        } catch (ignoreandcontinue) {\r\n          sofar.push(last);\r\n          // fall through to Node case\r\n        }\r\n      }\r\n\r\n      // Encountered a Node, or failed folding --\r\n      // collapse everything so far into a single tree:\r\n      sofar.push(_ensureNode(sofar.pop()));\r\n      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);\r\n      return [makeNode([newtree, _ensureNode(next)])];\r\n    }, [first]);\r\n    if (reduction.length === 1) {\r\n      return reduction[0];\r\n    }\r\n    // Might end up with a tree and a constant at the end:\r\n    return makeNode([reduction[0], _toNode(reduction[1])]);\r\n  }\r\n\r\n  // destroys the original node and returns a folded one\r\n  function foldFraction(node, options) {\r\n    switch (node.type) {\r\n      case 'SymbolNode':\r\n        return node;\r\n      case 'ConstantNode':\r\n        switch (typeof node.value) {\r\n          case 'number':\r\n            return _toNumber(node.value, options);\r\n          case 'bigint':\r\n            return _toNumber(node.value, options);\r\n          case 'string':\r\n            return node.value;\r\n          default:\r\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\r\n        }\r\n        return node;\r\n      case 'FunctionNode':\r\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\r\n          return node;\r\n        }\r\n        {\r\n          // Process operators as OperatorNode\r\n          var operatorFunctions = ['add', 'multiply'];\r\n          if (!operatorFunctions.includes(node.name)) {\r\n            var args = node.args.map(arg => foldFraction(arg, options));\r\n\r\n            // If all args are numbers\r\n            if (!args.some(isNode)) {\r\n              try {\r\n                return _eval(node.name, args, options);\r\n              } catch (ignoreandcontinue) {}\r\n            }\r\n\r\n            // Size of a matrix does not depend on entries\r\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\r\n              var sz = [];\r\n              var section = args[0];\r\n              while (isArrayNode(section)) {\r\n                sz.push(section.items.length);\r\n                section = section.items[0];\r\n              }\r\n              return matrix(sz);\r\n            }\r\n\r\n            // Convert all args to nodes and construct a symbolic function call\r\n            return new FunctionNode(node.name, args.map(_ensureNode));\r\n          } else {\r\n            // treat as operator\r\n          }\r\n        }\r\n      /* falls through */\r\n      case 'OperatorNode':\r\n        {\r\n          var fn = node.fn.toString();\r\n          var _args;\r\n          var res;\r\n          var makeNode = createMakeNodeFunction(node);\r\n          if (isOperatorNode(node) && node.isUnary()) {\r\n            _args = [foldFraction(node.args[0], options)];\r\n            if (!isNode(_args[0])) {\r\n              res = _eval(fn, _args, options);\r\n            } else {\r\n              res = makeNode(_args);\r\n            }\r\n          } else if (isAssociative(node, options.context)) {\r\n            _args = allChildren(node, options.context);\r\n            _args = _args.map(arg => foldFraction(arg, options));\r\n            if (isCommutative(fn, options.context)) {\r\n              // commutative binary operator\r\n              var consts = [];\r\n              var vars = [];\r\n              for (var i = 0; i < _args.length; i++) {\r\n                if (!isNode(_args[i])) {\r\n                  consts.push(_args[i]);\r\n                } else {\r\n                  vars.push(_args[i]);\r\n                }\r\n              }\r\n              if (consts.length > 1) {\r\n                res = foldOp(fn, consts, makeNode, options);\r\n                vars.unshift(res);\r\n                res = foldOp(fn, vars, makeNode, options);\r\n              } else {\r\n                // we won't change the children order since it's not neccessary\r\n                res = foldOp(fn, _args, makeNode, options);\r\n              }\r\n            } else {\r\n              // non-commutative binary operator\r\n              res = foldOp(fn, _args, makeNode, options);\r\n            }\r\n          } else {\r\n            // non-associative binary operator\r\n            _args = node.args.map(arg => foldFraction(arg, options));\r\n            res = foldOp(fn, _args, makeNode, options);\r\n          }\r\n          return res;\r\n        }\r\n      case 'ParenthesisNode':\r\n        // remove the uneccessary parenthesis\r\n        return foldFraction(node.content, options);\r\n      case 'AccessorNode':\r\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\r\n      case 'ArrayNode':\r\n        {\r\n          var foldItems = node.items.map(item => foldFraction(item, options));\r\n          if (foldItems.some(isNode)) {\r\n            return new ArrayNode(foldItems.map(_ensureNode));\r\n          }\r\n          /* All literals -- return a Matrix so we can operate on it */\r\n          return matrix(foldItems);\r\n        }\r\n      case 'IndexNode':\r\n        {\r\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\r\n        }\r\n      case 'ObjectNode':\r\n        {\r\n          var foldProps = {};\r\n          for (var prop in node.properties) {\r\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\r\n          }\r\n          return new ObjectNode(foldProps);\r\n        }\r\n      case 'AssignmentNode':\r\n      /* falls through */\r\n      case 'BlockNode':\r\n      /* falls through */\r\n      case 'FunctionAssignmentNode':\r\n      /* falls through */\r\n      case 'RangeNode':\r\n      /* falls through */\r\n      case 'ConditionalNode':\r\n      /* falls through */\r\n      default:\r\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\r\n    }\r\n  }\r\n  return simplifyConstant;\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}