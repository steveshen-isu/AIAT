{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { flatten } from '../../utils/array.js';\nimport { isComplex } from '../../utils/is.js';\nvar name = 'hypot';\nvar dependencies = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];\nexport var createHypot = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    abs,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    sqrt,\n    smaller,\n    isPositive\n  } = _ref;\n  /**\r\n   * Calculate the hypotenuse of a list with values. The hypotenuse is defined as:\r\n   *\r\n   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)\r\n   *\r\n   * For matrix input, the hypotenuse is calculated for all values in the matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.hypot(a, b, ...)\r\n   *     math.hypot([a, b, c, ...])\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.hypot(3, 4)      // 5\r\n   *     math.hypot(3, 4, 5)   // 7.0710678118654755\r\n   *     math.hypot([3, 4, 5]) // 7.0710678118654755\r\n   *     math.hypot(-2)        // 2\r\n   *\r\n   * See also:\r\n   *\r\n   *     abs, norm\r\n   *\r\n   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.\r\n   *                                                          Matrix and Array input is flattened and returns a\r\n   *                                                          single number for the whole matrix.\r\n   * @return {number | BigNumber} Returns the hypothenusa of the input values.\r\n   */\n  return typed(name, {\n    '... number | BigNumber': _hypot,\n    Array: _hypot,\n    Matrix: M => _hypot(flatten(M.toArray()))\n  });\n\n  /**\r\n   * Calculate the hypotenuse for an Array with values\r\n   * @param {Array.<number | BigNumber>} args\r\n   * @return {number | BigNumber} Returns the result\r\n   * @private\r\n   */\n  function _hypot(args) {\n    // code based on `hypot` from es6-shim:\n    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633\n    var result = 0;\n    var largest = 0;\n    for (var i = 0; i < args.length; i++) {\n      if (isComplex(args[i])) {\n        throw new TypeError('Unexpected type of argument to hypot');\n      }\n      var value = abs(args[i]);\n      if (smaller(largest, value)) {\n        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));\n        result = addScalar(result, 1);\n        largest = value;\n      } else {\n        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);\n      }\n    }\n    return multiplyScalar(largest, sqrt(result));\n  }\n});","map":{"version":3,"names":["factory","flatten","isComplex","name","dependencies","createHypot","_ref","typed","abs","addScalar","divideScalar","multiplyScalar","sqrt","smaller","isPositive","_hypot","Array","Matrix","M","toArray","args","result","largest","i","length","TypeError","value"],"sources":["C:/Users/ROG/ai-solver/node_modules/mathjs/lib/esm/function/arithmetic/hypot.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { flatten } from '../../utils/array.js';\r\nimport { isComplex } from '../../utils/is.js';\r\nvar name = 'hypot';\r\nvar dependencies = ['typed', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'sqrt', 'smaller', 'isPositive'];\r\nexport var createHypot = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    abs,\r\n    addScalar,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    sqrt,\r\n    smaller,\r\n    isPositive\r\n  } = _ref;\r\n  /**\r\n   * Calculate the hypotenuse of a list with values. The hypotenuse is defined as:\r\n   *\r\n   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)\r\n   *\r\n   * For matrix input, the hypotenuse is calculated for all values in the matrix.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.hypot(a, b, ...)\r\n   *     math.hypot([a, b, c, ...])\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.hypot(3, 4)      // 5\r\n   *     math.hypot(3, 4, 5)   // 7.0710678118654755\r\n   *     math.hypot([3, 4, 5]) // 7.0710678118654755\r\n   *     math.hypot(-2)        // 2\r\n   *\r\n   * See also:\r\n   *\r\n   *     abs, norm\r\n   *\r\n   * @param {... number | BigNumber | Array | Matrix} args    A list with numeric values or an Array or Matrix.\r\n   *                                                          Matrix and Array input is flattened and returns a\r\n   *                                                          single number for the whole matrix.\r\n   * @return {number | BigNumber} Returns the hypothenusa of the input values.\r\n   */\r\n  return typed(name, {\r\n    '... number | BigNumber': _hypot,\r\n    Array: _hypot,\r\n    Matrix: M => _hypot(flatten(M.toArray()))\r\n  });\r\n\r\n  /**\r\n   * Calculate the hypotenuse for an Array with values\r\n   * @param {Array.<number | BigNumber>} args\r\n   * @return {number | BigNumber} Returns the result\r\n   * @private\r\n   */\r\n  function _hypot(args) {\r\n    // code based on `hypot` from es6-shim:\r\n    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633\r\n    var result = 0;\r\n    var largest = 0;\r\n    for (var i = 0; i < args.length; i++) {\r\n      if (isComplex(args[i])) {\r\n        throw new TypeError('Unexpected type of argument to hypot');\r\n      }\r\n      var value = abs(args[i]);\r\n      if (smaller(largest, value)) {\r\n        result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));\r\n        result = addScalar(result, 1);\r\n        largest = value;\r\n      } else {\r\n        result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);\r\n      }\r\n    }\r\n    return multiplyScalar(largest, sqrt(result));\r\n  }\r\n});"],"mappings":"AAAA,SAASA,OAAO,QAAQ,wBAAwB;AAChD,SAASC,OAAO,QAAQ,sBAAsB;AAC9C,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,IAAIC,IAAI,GAAG,OAAO;AAClB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,cAAc,EAAE,gBAAgB,EAAE,MAAM,EAAE,SAAS,EAAE,YAAY,CAAC;AACnH,OAAO,IAAIC,WAAW,GAAG,eAAeL,OAAO,CAACG,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EAC1E,IAAI;IACFC,KAAK;IACLC,GAAG;IACHC,SAAS;IACTC,YAAY;IACZC,cAAc;IACdC,IAAI;IACJC,OAAO;IACPC;EACF,CAAC,GAAGR,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,KAAK,CAACJ,IAAI,EAAE;IACjB,wBAAwB,EAAEY,MAAM;IAChCC,KAAK,EAAED,MAAM;IACbE,MAAM,EAAEC,CAAC,IAAIH,MAAM,CAACd,OAAO,CAACiB,CAAC,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1C,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;EACE,SAASJ,MAAMA,CAACK,IAAI,EAAE;IACpB;IACA;IACA,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,OAAO,GAAG,CAAC;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,IAAIrB,SAAS,CAACkB,IAAI,CAACG,CAAC,CAAC,CAAC,EAAE;QACtB,MAAM,IAAIE,SAAS,CAAC,sCAAsC,CAAC;MAC7D;MACA,IAAIC,KAAK,GAAGlB,GAAG,CAACY,IAAI,CAACG,CAAC,CAAC,CAAC;MACxB,IAAIV,OAAO,CAACS,OAAO,EAAEI,KAAK,CAAC,EAAE;QAC3BL,MAAM,GAAGV,cAAc,CAACU,MAAM,EAAEV,cAAc,CAACD,YAAY,CAACY,OAAO,EAAEI,KAAK,CAAC,EAAEhB,YAAY,CAACY,OAAO,EAAEI,KAAK,CAAC,CAAC,CAAC;QAC3GL,MAAM,GAAGZ,SAAS,CAACY,MAAM,EAAE,CAAC,CAAC;QAC7BC,OAAO,GAAGI,KAAK;MACjB,CAAC,MAAM;QACLL,MAAM,GAAGZ,SAAS,CAACY,MAAM,EAAEP,UAAU,CAACY,KAAK,CAAC,GAAGf,cAAc,CAACD,YAAY,CAACgB,KAAK,EAAEJ,OAAO,CAAC,EAAEZ,YAAY,CAACgB,KAAK,EAAEJ,OAAO,CAAC,CAAC,GAAGI,KAAK,CAAC;MACpI;IACF;IACA,OAAOf,cAAc,CAACW,OAAO,EAAEV,IAAI,CAACS,MAAM,CAAC,CAAC;EAC9C;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}